{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { l as normalize } from '../../Common/Core/Math/index.js';\nimport vtkCaseTable from './ImageMarchingCubes/caseTable.js';\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingCubes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingCubes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingCubes');\n  const ids = [];\n  const voxelScalars = [];\n  const voxelGradients = [];\n  const voxelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  // Retrieve scalars and voxel coordinates. i-j-k is origin of voxel.\n  publicAPI.getVoxelScalars = (i, j, k, slice, dims, origin, spacing, s) => {\n    // First get the indices for the voxel\n    ids[0] = k * slice + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + 1; // i+1, j, k\n    ids[2] = ids[0] + dims[0]; // i, j+1, k\n    ids[3] = ids[2] + 1; // i+1, j+1, k\n    ids[4] = ids[0] + slice; // i, j, k+1\n    ids[5] = ids[4] + 1; // i+1, j, k+1\n    ids[6] = ids[4] + dims[0]; // i, j+1, k+1\n    ids[7] = ids[6] + 1; // i+1, j+1, k+1\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 8; ++ii) {\n      voxelScalars[ii] = s[ids[ii]];\n    }\n  };\n\n  // Retrieve voxel coordinates. i-j-k is origin of voxel.\n  publicAPI.getVoxelPoints = (i, j, k, origin, spacing) => {\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    voxelPts[0] = origin[0] + i * spacing[0]; // 0\n    voxelPts[1] = origin[1] + j * spacing[1];\n    voxelPts[2] = origin[2] + k * spacing[2];\n    voxelPts[3] = voxelPts[0] + spacing[0]; // 1\n    voxelPts[4] = voxelPts[1];\n    voxelPts[5] = voxelPts[2];\n    voxelPts[6] = voxelPts[0]; // 2\n    voxelPts[7] = voxelPts[1] + spacing[1];\n    voxelPts[8] = voxelPts[2];\n    voxelPts[9] = voxelPts[3]; // 3\n    voxelPts[10] = voxelPts[7];\n    voxelPts[11] = voxelPts[2];\n    voxelPts[12] = voxelPts[0]; // 4\n    voxelPts[13] = voxelPts[1];\n    voxelPts[14] = voxelPts[2] + spacing[2];\n    voxelPts[15] = voxelPts[3]; // 5\n    voxelPts[16] = voxelPts[1];\n    voxelPts[17] = voxelPts[14];\n    voxelPts[18] = voxelPts[0]; // 6\n    voxelPts[19] = voxelPts[7];\n    voxelPts[20] = voxelPts[14];\n    voxelPts[21] = voxelPts[3]; // 7\n    voxelPts[22] = voxelPts[7];\n    voxelPts[23] = voxelPts[14];\n  };\n\n  // Compute point gradient at i-j-k location\n  publicAPI.getPointGradient = (i, j, k, dims, slice, spacing, s, g) => {\n    let sp;\n    let sm;\n\n    // x-direction\n    if (i === 0) {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else if (i === dims[0] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = 0.5 * (sm - sp) / spacing[0];\n    }\n\n    // y-direction\n    if (j === 0) {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else if (j === dims[1] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = 0.5 * (sm - sp) / spacing[1];\n    }\n\n    // z-direction\n    if (k === 0) {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else if (k === dims[2] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = 0.5 * (sm - sp) / spacing[2];\n    }\n  };\n\n  // Compute voxel gradient values. I-j-k is origin point of voxel.\n  publicAPI.getVoxelGradients = (i, j, k, dims, slice, spacing, scalars) => {\n    const g = [];\n    publicAPI.getPointGradient(i, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[0] = g[0];\n    voxelGradients[1] = g[1];\n    voxelGradients[2] = g[2];\n    publicAPI.getPointGradient(i + 1, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[3] = g[0];\n    voxelGradients[4] = g[1];\n    voxelGradients[5] = g[2];\n    publicAPI.getPointGradient(i, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[6] = g[0];\n    voxelGradients[7] = g[1];\n    voxelGradients[8] = g[2];\n    publicAPI.getPointGradient(i + 1, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[9] = g[0];\n    voxelGradients[10] = g[1];\n    voxelGradients[11] = g[2];\n    publicAPI.getPointGradient(i, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[12] = g[0];\n    voxelGradients[13] = g[1];\n    voxelGradients[14] = g[2];\n    publicAPI.getPointGradient(i + 1, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[15] = g[0];\n    voxelGradients[16] = g[1];\n    voxelGradients[17] = g[2];\n    publicAPI.getPointGradient(i, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[18] = g[0];\n    voxelGradients[19] = g[1];\n    voxelGradients[20] = g[2];\n    publicAPI.getPointGradient(i + 1, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[21] = g[0];\n    voxelGradients[22] = g[1];\n    voxelGradients[23] = g[2];\n  };\n  publicAPI.produceTriangles = (cVal, i, j, k, extent, slice, dims, origin, spacing, scalars, points, tris, normals) => {\n    const CASE_MASK = [1, 2, 4, 8, 16, 32, 64, 128];\n    const VERT_MAP = [0, 1, 3, 2, 4, 5, 7, 6];\n    const xyz = [];\n    const n = [];\n    let pId;\n    publicAPI.getVoxelScalars(i, j, k, slice, dims, origin, spacing, scalars);\n    let index = 0;\n    for (let idx = 0; idx < 8; idx++) {\n      if (voxelScalars[VERT_MAP[idx]] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n    const voxelTris = vtkCaseTable.getCase(index);\n    if (voxelTris[0] < 0) {\n      return; // don't get the voxel coordinates, nothing to do\n    }\n    publicAPI.getVoxelPoints(i + extent[0], j + extent[2], k + extent[4], origin, spacing);\n    if (model.computeNormals) {\n      publicAPI.getVoxelGradients(i, j, k, dims, slice, spacing, scalars);\n    }\n    for (let idx = 0; voxelTris[idx] >= 0; idx += 3) {\n      tris.push(3);\n      for (let eid = 0; eid < 3; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(voxelTris[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - voxelScalars[edgeVerts[0]]) / (voxelScalars[edgeVerts[1]] - voxelScalars[edgeVerts[0]]);\n          const x0 = voxelPts.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);\n          const x1 = voxelPts.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);\n          xyz[0] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[1] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[2] = x0[2] + t * (x1[2] - x0[2]);\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.computeNormals) {\n            const n0 = voxelGradients.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);\n            const n1 = voxelGradients.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);\n            n[0] = n0[0] + t * (n1[0] - n0[0]);\n            n[1] = n0[1] + t * (n1[1] - n0[1]);\n            n[2] = n0[2] + t * (n1[2] - n0[2]);\n            normalize(n);\n            normals.push(n[0], n[1], n[2]);\n          }\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        tris.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    console.time('mcubes');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const s = input.getPointData().getScalars().getData();\n\n    // Points - dynamic array\n    const pBuffer = [];\n\n    // Cells - dynamic array\n    const tBuffer = [];\n\n    // Normals\n    const nBuffer = [];\n\n    // Loop over all voxels, determine case and process\n    const extent = input.getExtent();\n    const slice = dims[0] * dims[1];\n    for (let k = 0; k < dims[2] - 1; ++k) {\n      for (let j = 0; j < dims[1] - 1; ++j) {\n        for (let i = 0; i < dims[0] - 1; ++i) {\n          publicAPI.produceTriangles(model.contourValue, i, j, k, extent, slice, dims, origin, spacing, s, pBuffer, tBuffer, nBuffer);\n        }\n      }\n    }\n    edgeLocator.initialize();\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(pBuffer), 3);\n    polydata.getPolys().setData(new Uint32Array(tBuffer));\n    if (model.computeNormals) {\n      const nData = new Float32Array(nBuffer);\n      const normals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: nData,\n        name: 'Normals'\n      });\n      polydata.getPointData().setNormals(normals);\n    }\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('mcubes');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValue: 0,\n  computeNormals: false,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['contourValue', 'computeNormals', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingCubes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingCubes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingCubes$1 = {\n  newInstance,\n  extend\n};\nexport { vtkImageMarchingCubes$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkDataArray","vtkEdgeLocator","vtkPolyData","l","normalize","vtkCaseTable","vtkErrorMacro","vtkDebugMacro","vtkImageMarchingCubes","publicAPI","model","classHierarchy","push","ids","voxelScalars","voxelGradients","voxelPts","edgeLocator","newInstance","getVoxelScalars","i","j","k","slice","dims","origin","spacing","s","ii","getVoxelPoints","getPointGradient","g","sp","sm","getVoxelGradients","scalars","produceTriangles","cVal","extent","points","tris","normals","CASE_MASK","VERT_MAP","xyz","n","pId","index","idx","voxelTris","getCase","computeNormals","eid","edgeVerts","getEdge","undefined","mergePoints","isInsertedEdge","value","t","x0","x1","length","n0","n1","insertEdge","requestData","inData","outData","input","console","time","getOrigin","getSpacing","getDimensions","getPointData","getScalars","getData","pBuffer","tBuffer","nBuffer","getExtent","contourValue","initialize","polydata","getPoints","setData","Float32Array","getPolys","Uint32Array","nData","numberOfComponents","values","name","setNormals","timeEnd","DEFAULT_VALUES","extend","initialValues","arguments","Object","assign","obj","algo","setGet","vtkImageMarchingCubes$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Filters/General/ImageMarchingCubes.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { l as normalize } from '../../Common/Core/Math/index.js';\nimport vtkCaseTable from './ImageMarchingCubes/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingCubes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingCubes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingCubes');\n  const ids = [];\n  const voxelScalars = [];\n  const voxelGradients = [];\n  const voxelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  // Retrieve scalars and voxel coordinates. i-j-k is origin of voxel.\n  publicAPI.getVoxelScalars = (i, j, k, slice, dims, origin, spacing, s) => {\n    // First get the indices for the voxel\n    ids[0] = k * slice + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + 1; // i+1, j, k\n    ids[2] = ids[0] + dims[0]; // i, j+1, k\n    ids[3] = ids[2] + 1; // i+1, j+1, k\n    ids[4] = ids[0] + slice; // i, j, k+1\n    ids[5] = ids[4] + 1; // i+1, j, k+1\n    ids[6] = ids[4] + dims[0]; // i, j+1, k+1\n    ids[7] = ids[6] + 1; // i+1, j+1, k+1\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 8; ++ii) {\n      voxelScalars[ii] = s[ids[ii]];\n    }\n  };\n\n  // Retrieve voxel coordinates. i-j-k is origin of voxel.\n  publicAPI.getVoxelPoints = (i, j, k, origin, spacing) => {\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    voxelPts[0] = origin[0] + i * spacing[0]; // 0\n    voxelPts[1] = origin[1] + j * spacing[1];\n    voxelPts[2] = origin[2] + k * spacing[2];\n    voxelPts[3] = voxelPts[0] + spacing[0]; // 1\n    voxelPts[4] = voxelPts[1];\n    voxelPts[5] = voxelPts[2];\n    voxelPts[6] = voxelPts[0]; // 2\n    voxelPts[7] = voxelPts[1] + spacing[1];\n    voxelPts[8] = voxelPts[2];\n    voxelPts[9] = voxelPts[3]; // 3\n    voxelPts[10] = voxelPts[7];\n    voxelPts[11] = voxelPts[2];\n    voxelPts[12] = voxelPts[0]; // 4\n    voxelPts[13] = voxelPts[1];\n    voxelPts[14] = voxelPts[2] + spacing[2];\n    voxelPts[15] = voxelPts[3]; // 5\n    voxelPts[16] = voxelPts[1];\n    voxelPts[17] = voxelPts[14];\n    voxelPts[18] = voxelPts[0]; // 6\n    voxelPts[19] = voxelPts[7];\n    voxelPts[20] = voxelPts[14];\n    voxelPts[21] = voxelPts[3]; // 7\n    voxelPts[22] = voxelPts[7];\n    voxelPts[23] = voxelPts[14];\n  };\n\n  // Compute point gradient at i-j-k location\n  publicAPI.getPointGradient = (i, j, k, dims, slice, spacing, s, g) => {\n    let sp;\n    let sm;\n\n    // x-direction\n    if (i === 0) {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else if (i === dims[0] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = (sm - sp) / spacing[0];\n    } else {\n      sp = s[i + 1 + j * dims[0] + k * slice];\n      sm = s[i - 1 + j * dims[0] + k * slice];\n      g[0] = 0.5 * (sm - sp) / spacing[0];\n    }\n\n    // y-direction\n    if (j === 0) {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else if (j === dims[1] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = (sm - sp) / spacing[1];\n    } else {\n      sp = s[i + (j + 1) * dims[0] + k * slice];\n      sm = s[i + (j - 1) * dims[0] + k * slice];\n      g[1] = 0.5 * (sm - sp) / spacing[1];\n    }\n\n    // z-direction\n    if (k === 0) {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + k * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else if (k === dims[2] - 1) {\n      sp = s[i + j * dims[0] + k * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = (sm - sp) / spacing[2];\n    } else {\n      sp = s[i + j * dims[0] + (k + 1) * slice];\n      sm = s[i + j * dims[0] + (k - 1) * slice];\n      g[2] = 0.5 * (sm - sp) / spacing[2];\n    }\n  };\n\n  // Compute voxel gradient values. I-j-k is origin point of voxel.\n  publicAPI.getVoxelGradients = (i, j, k, dims, slice, spacing, scalars) => {\n    const g = [];\n    publicAPI.getPointGradient(i, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[0] = g[0];\n    voxelGradients[1] = g[1];\n    voxelGradients[2] = g[2];\n    publicAPI.getPointGradient(i + 1, j, k, dims, slice, spacing, scalars, g);\n    voxelGradients[3] = g[0];\n    voxelGradients[4] = g[1];\n    voxelGradients[5] = g[2];\n    publicAPI.getPointGradient(i, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[6] = g[0];\n    voxelGradients[7] = g[1];\n    voxelGradients[8] = g[2];\n    publicAPI.getPointGradient(i + 1, j + 1, k, dims, slice, spacing, scalars, g);\n    voxelGradients[9] = g[0];\n    voxelGradients[10] = g[1];\n    voxelGradients[11] = g[2];\n    publicAPI.getPointGradient(i, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[12] = g[0];\n    voxelGradients[13] = g[1];\n    voxelGradients[14] = g[2];\n    publicAPI.getPointGradient(i + 1, j, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[15] = g[0];\n    voxelGradients[16] = g[1];\n    voxelGradients[17] = g[2];\n    publicAPI.getPointGradient(i, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[18] = g[0];\n    voxelGradients[19] = g[1];\n    voxelGradients[20] = g[2];\n    publicAPI.getPointGradient(i + 1, j + 1, k + 1, dims, slice, spacing, scalars, g);\n    voxelGradients[21] = g[0];\n    voxelGradients[22] = g[1];\n    voxelGradients[23] = g[2];\n  };\n  publicAPI.produceTriangles = (cVal, i, j, k, extent, slice, dims, origin, spacing, scalars, points, tris, normals) => {\n    const CASE_MASK = [1, 2, 4, 8, 16, 32, 64, 128];\n    const VERT_MAP = [0, 1, 3, 2, 4, 5, 7, 6];\n    const xyz = [];\n    const n = [];\n    let pId;\n    publicAPI.getVoxelScalars(i, j, k, slice, dims, origin, spacing, scalars);\n    let index = 0;\n    for (let idx = 0; idx < 8; idx++) {\n      if (voxelScalars[VERT_MAP[idx]] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const voxelTris = vtkCaseTable.getCase(index);\n    if (voxelTris[0] < 0) {\n      return; // don't get the voxel coordinates, nothing to do\n    }\n\n    publicAPI.getVoxelPoints(i + extent[0], j + extent[2], k + extent[4], origin, spacing);\n    if (model.computeNormals) {\n      publicAPI.getVoxelGradients(i, j, k, dims, slice, spacing, scalars);\n    }\n    for (let idx = 0; voxelTris[idx] >= 0; idx += 3) {\n      tris.push(3);\n      for (let eid = 0; eid < 3; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(voxelTris[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - voxelScalars[edgeVerts[0]]) / (voxelScalars[edgeVerts[1]] - voxelScalars[edgeVerts[0]]);\n          const x0 = voxelPts.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);\n          const x1 = voxelPts.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);\n          xyz[0] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[1] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[2] = x0[2] + t * (x1[2] - x0[2]);\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.computeNormals) {\n            const n0 = voxelGradients.slice(edgeVerts[0] * 3, (edgeVerts[0] + 1) * 3);\n            const n1 = voxelGradients.slice(edgeVerts[1] * 3, (edgeVerts[1] + 1) * 3);\n            n[0] = n0[0] + t * (n1[0] - n0[0]);\n            n[1] = n0[1] + t * (n1[1] - n0[1]);\n            n[2] = n0[2] + t * (n1[2] - n0[2]);\n            normalize(n);\n            normals.push(n[0], n[1], n[2]);\n          }\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        tris.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    console.time('mcubes');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const s = input.getPointData().getScalars().getData();\n\n    // Points - dynamic array\n    const pBuffer = [];\n\n    // Cells - dynamic array\n    const tBuffer = [];\n\n    // Normals\n    const nBuffer = [];\n\n    // Loop over all voxels, determine case and process\n    const extent = input.getExtent();\n    const slice = dims[0] * dims[1];\n    for (let k = 0; k < dims[2] - 1; ++k) {\n      for (let j = 0; j < dims[1] - 1; ++j) {\n        for (let i = 0; i < dims[0] - 1; ++i) {\n          publicAPI.produceTriangles(model.contourValue, i, j, k, extent, slice, dims, origin, spacing, s, pBuffer, tBuffer, nBuffer);\n        }\n      }\n    }\n    edgeLocator.initialize();\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(pBuffer), 3);\n    polydata.getPolys().setData(new Uint32Array(tBuffer));\n    if (model.computeNormals) {\n      const nData = new Float32Array(nBuffer);\n      const normals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        values: nData,\n        name: 'Normals'\n      });\n      polydata.getPointData().setNormals(normals);\n    }\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('mcubes');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValue: 0,\n  computeNormals: false,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['contourValue', 'computeNormals', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingCubes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingCubes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingCubes$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingCubes$1 as default, extend, newInstance };\n"],"mappings":";;;;;;;AAAA,SAASA,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AAC7C,OAAOC,YAAY,MAAM,gCAAgC;AACzD,OAAOC,cAAc,MAAM,uCAAuC;AAClE,OAAOC,WAAW,MAAM,oCAAoC;AAC5D,SAASC,CAAC,IAAIC,SAAS,QAAQ,iCAAiC;AAChE,OAAOC,YAAY,MAAM,mCAAmC;AAE5D,MAAM;EACJC,aAAa;EACbC;AACF,CAAC,GAAGR,KAAK;;AAET;AACA;AACA;;AAEA,SAASS,qBAAqBA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAC/C;EACAA,KAAK,CAACC,cAAc,CAACC,IAAI,CAAC,uBAAuB,CAAC;EAClD,MAAMC,GAAG,GAAG,EAAE;EACd,MAAMC,YAAY,GAAG,EAAE;EACvB,MAAMC,cAAc,GAAG,EAAE;EACzB,MAAMC,QAAQ,GAAG,EAAE;EACnB,MAAMC,WAAW,GAAGhB,cAAc,CAACiB,WAAW,CAAC,CAAC;;EAEhD;EACAT,SAAS,CAACU,eAAe,GAAG,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAEC,OAAO,EAAEC,CAAC,KAAK;IACxE;IACAd,GAAG,CAAC,CAAC,CAAC,GAAGS,CAAC,GAAGC,KAAK,GAAGF,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGJ,CAAC,CAAC,CAAC;IACtCP,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IACrBA,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAGW,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3BX,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IACrBA,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAGU,KAAK,CAAC,CAAC;IACzBV,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IACrBA,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAGW,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3BX,GAAG,CAAC,CAAC,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;;IAErB;IACA,KAAK,IAAIe,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG,CAAC,EAAE,EAAEA,EAAE,EAAE;MAC7Bd,YAAY,CAACc,EAAE,CAAC,GAAGD,CAAC,CAACd,GAAG,CAACe,EAAE,CAAC,CAAC;IAC/B;EACF,CAAC;;EAED;EACAnB,SAAS,CAACoB,cAAc,GAAG,CAACT,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEG,MAAM,EAAEC,OAAO,KAAK;IACvD;IACAV,QAAQ,CAAC,CAAC,CAAC,GAAGS,MAAM,CAAC,CAAC,CAAC,GAAGL,CAAC,GAAGM,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1CV,QAAQ,CAAC,CAAC,CAAC,GAAGS,MAAM,CAAC,CAAC,CAAC,GAAGJ,CAAC,GAAGK,OAAO,CAAC,CAAC,CAAC;IACxCV,QAAQ,CAAC,CAAC,CAAC,GAAGS,MAAM,CAAC,CAAC,CAAC,GAAGH,CAAC,GAAGI,OAAO,CAAC,CAAC,CAAC;IACxCV,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,GAAGU,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IACxCV,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;IACzBA,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;IACzBA,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3BA,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,GAAGU,OAAO,CAAC,CAAC,CAAC;IACtCV,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;IACzBA,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;IAC1BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;IAC1BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;IAC1BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,GAAGU,OAAO,CAAC,CAAC,CAAC;IACvCV,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;IAC1BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,EAAE,CAAC;IAC3BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;IAC1BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,EAAE,CAAC;IAC3BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;IAC1BA,QAAQ,CAAC,EAAE,CAAC,GAAGA,QAAQ,CAAC,EAAE,CAAC;EAC7B,CAAC;;EAED;EACAP,SAAS,CAACqB,gBAAgB,GAAG,CAACV,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAEC,CAAC,EAAEI,CAAC,KAAK;IACpE,IAAIC,EAAE;IACN,IAAIC,EAAE;;IAEN;IACA,IAAIb,CAAC,KAAK,CAAC,EAAE;MACXY,EAAE,GAAGL,CAAC,CAACP,CAAC,GAAG,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACvCU,EAAE,GAAGN,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACnCQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAACE,EAAE,GAAGD,EAAE,IAAIN,OAAO,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM,IAAIN,CAAC,KAAKI,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MAC5BQ,EAAE,GAAGL,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACnCU,EAAE,GAAGN,CAAC,CAACP,CAAC,GAAG,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACvCQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAACE,EAAE,GAAGD,EAAE,IAAIN,OAAO,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM;MACLM,EAAE,GAAGL,CAAC,CAACP,CAAC,GAAG,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACvCU,EAAE,GAAGN,CAAC,CAACP,CAAC,GAAG,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACvCQ,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIE,EAAE,GAAGD,EAAE,CAAC,GAAGN,OAAO,CAAC,CAAC,CAAC;IACrC;;IAEA;IACA,IAAIL,CAAC,KAAK,CAAC,EAAE;MACXW,EAAE,GAAGL,CAAC,CAACP,CAAC,GAAG,CAACC,CAAC,GAAG,CAAC,IAAIG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACzCU,EAAE,GAAGN,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACnCQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAACE,EAAE,GAAGD,EAAE,IAAIN,OAAO,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM,IAAIL,CAAC,KAAKG,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MAC5BQ,EAAE,GAAGL,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACnCU,EAAE,GAAGN,CAAC,CAACP,CAAC,GAAG,CAACC,CAAC,GAAG,CAAC,IAAIG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACzCQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAACE,EAAE,GAAGD,EAAE,IAAIN,OAAO,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM;MACLM,EAAE,GAAGL,CAAC,CAACP,CAAC,GAAG,CAACC,CAAC,GAAG,CAAC,IAAIG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACzCU,EAAE,GAAGN,CAAC,CAACP,CAAC,GAAG,CAACC,CAAC,GAAG,CAAC,IAAIG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACzCQ,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIE,EAAE,GAAGD,EAAE,CAAC,GAAGN,OAAO,CAAC,CAAC,CAAC;IACrC;;IAEA;IACA,IAAIJ,CAAC,KAAK,CAAC,EAAE;MACXU,EAAE,GAAGL,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAG,CAACF,CAAC,GAAG,CAAC,IAAIC,KAAK,CAAC;MACzCU,EAAE,GAAGN,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACnCQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAACE,EAAE,GAAGD,EAAE,IAAIN,OAAO,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM,IAAIJ,CAAC,KAAKE,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MAC5BQ,EAAE,GAAGL,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAGF,CAAC,GAAGC,KAAK,CAAC;MACnCU,EAAE,GAAGN,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAG,CAACF,CAAC,GAAG,CAAC,IAAIC,KAAK,CAAC;MACzCQ,CAAC,CAAC,CAAC,CAAC,GAAG,CAACE,EAAE,GAAGD,EAAE,IAAIN,OAAO,CAAC,CAAC,CAAC;IAC/B,CAAC,MAAM;MACLM,EAAE,GAAGL,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAG,CAACF,CAAC,GAAG,CAAC,IAAIC,KAAK,CAAC;MACzCU,EAAE,GAAGN,CAAC,CAACP,CAAC,GAAGC,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAG,CAACF,CAAC,GAAG,CAAC,IAAIC,KAAK,CAAC;MACzCQ,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,IAAIE,EAAE,GAAGD,EAAE,CAAC,GAAGN,OAAO,CAAC,CAAC,CAAC;IACrC;EACF,CAAC;;EAED;EACAjB,SAAS,CAACyB,iBAAiB,GAAG,CAACd,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,KAAK;IACxE,MAAMJ,CAAC,GAAG,EAAE;IACZtB,SAAS,CAACqB,gBAAgB,CAACV,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,EAAEJ,CAAC,CAAC;IACrEhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBtB,SAAS,CAACqB,gBAAgB,CAACV,CAAC,GAAG,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,EAAEJ,CAAC,CAAC;IACzEhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBtB,SAAS,CAACqB,gBAAgB,CAACV,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,EAAEJ,CAAC,CAAC;IACzEhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBtB,SAAS,CAACqB,gBAAgB,CAACV,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,EAAEJ,CAAC,CAAC;IAC7EhB,cAAc,CAAC,CAAC,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACxBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBtB,SAAS,CAACqB,gBAAgB,CAACV,CAAC,EAAEC,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,EAAEJ,CAAC,CAAC;IACzEhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBtB,SAAS,CAACqB,gBAAgB,CAACV,CAAC,GAAG,CAAC,EAAEC,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,EAAEJ,CAAC,CAAC;IAC7EhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBtB,SAAS,CAACqB,gBAAgB,CAACV,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,EAAEJ,CAAC,CAAC;IAC7EhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBtB,SAAS,CAACqB,gBAAgB,CAACV,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,EAAEJ,CAAC,CAAC;IACjFhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;IACzBhB,cAAc,CAAC,EAAE,CAAC,GAAGgB,CAAC,CAAC,CAAC,CAAC;EAC3B,CAAC;EACDtB,SAAS,CAAC2B,gBAAgB,GAAG,CAACC,IAAI,EAAEjB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEgB,MAAM,EAAEf,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAEC,OAAO,EAAES,OAAO,EAAEI,MAAM,EAAEC,IAAI,EAAEC,OAAO,KAAK;IACpH,MAAMC,SAAS,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC;IAC/C,MAAMC,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACzC,MAAMC,GAAG,GAAG,EAAE;IACd,MAAMC,CAAC,GAAG,EAAE;IACZ,IAAIC,GAAG;IACPrC,SAAS,CAACU,eAAe,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAEC,OAAO,EAAES,OAAO,CAAC;IACzE,IAAIY,KAAK,GAAG,CAAC;IACb,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;MAChC,IAAIlC,YAAY,CAAC6B,QAAQ,CAACK,GAAG,CAAC,CAAC,IAAIX,IAAI,EAAE;QACvCU,KAAK,IAAIL,SAAS,CAACM,GAAG,CAAC,CAAC,CAAC;MAC3B;IACF;IAEA,MAAMC,SAAS,GAAG5C,YAAY,CAAC6C,OAAO,CAACH,KAAK,CAAC;IAC7C,IAAIE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MACpB,OAAO,CAAC;IACV;IAEAxC,SAAS,CAACoB,cAAc,CAACT,CAAC,GAAGkB,MAAM,CAAC,CAAC,CAAC,EAAEjB,CAAC,GAAGiB,MAAM,CAAC,CAAC,CAAC,EAAEhB,CAAC,GAAGgB,MAAM,CAAC,CAAC,CAAC,EAAEb,MAAM,EAAEC,OAAO,CAAC;IACtF,IAAIhB,KAAK,CAACyC,cAAc,EAAE;MACxB1C,SAAS,CAACyB,iBAAiB,CAACd,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEE,IAAI,EAAED,KAAK,EAAEG,OAAO,EAAES,OAAO,CAAC;IACrE;IACA,KAAK,IAAIa,GAAG,GAAG,CAAC,EAAEC,SAAS,CAACD,GAAG,CAAC,IAAI,CAAC,EAAEA,GAAG,IAAI,CAAC,EAAE;MAC/CR,IAAI,CAAC5B,IAAI,CAAC,CAAC,CAAC;MACZ,KAAK,IAAIwC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;QAChC,MAAMC,SAAS,GAAGhD,YAAY,CAACiD,OAAO,CAACL,SAAS,CAACD,GAAG,GAAGI,GAAG,CAAC,CAAC;QAC5DN,GAAG,GAAGS,SAAS;QACf,IAAI7C,KAAK,CAAC8C,WAAW,EAAE;UACrBV,GAAG,GAAG7B,WAAW,CAACwC,cAAc,CAAC5C,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAExC,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEK,KAAK;QAC/E;QACA,IAAIZ,GAAG,KAAKS,SAAS,EAAE;UACrB,MAAMI,CAAC,GAAG,CAACtB,IAAI,GAAGvB,YAAY,CAACuC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAKvC,YAAY,CAACuC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAGvC,YAAY,CAACuC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;UACzG,MAAMO,EAAE,GAAG5C,QAAQ,CAACO,KAAK,CAAC8B,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAACA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;UACnE,MAAMQ,EAAE,GAAG7C,QAAQ,CAACO,KAAK,CAAC8B,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAACA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;UACnET,GAAG,CAAC,CAAC,CAAC,GAAGgB,EAAE,CAAC,CAAC,CAAC,GAAGD,CAAC,IAAIE,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,CAAC;UACpChB,GAAG,CAAC,CAAC,CAAC,GAAGgB,EAAE,CAAC,CAAC,CAAC,GAAGD,CAAC,IAAIE,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,CAAC;UACpChB,GAAG,CAAC,CAAC,CAAC,GAAGgB,EAAE,CAAC,CAAC,CAAC,GAAGD,CAAC,IAAIE,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,CAAC;UACpCd,GAAG,GAAGP,MAAM,CAACuB,MAAM,GAAG,CAAC;UACvBvB,MAAM,CAAC3B,IAAI,CAACgC,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;UACnC,IAAIlC,KAAK,CAACyC,cAAc,EAAE;YACxB,MAAMY,EAAE,GAAGhD,cAAc,CAACQ,KAAK,CAAC8B,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAACA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACzE,MAAMW,EAAE,GAAGjD,cAAc,CAACQ,KAAK,CAAC8B,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAACA,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACzER,CAAC,CAAC,CAAC,CAAC,GAAGkB,EAAE,CAAC,CAAC,CAAC,GAAGJ,CAAC,IAAIK,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,CAAC;YAClClB,CAAC,CAAC,CAAC,CAAC,GAAGkB,EAAE,CAAC,CAAC,CAAC,GAAGJ,CAAC,IAAIK,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,CAAC;YAClClB,CAAC,CAAC,CAAC,CAAC,GAAGkB,EAAE,CAAC,CAAC,CAAC,GAAGJ,CAAC,IAAIK,EAAE,CAAC,CAAC,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,CAAC;YAClC3D,SAAS,CAACyC,CAAC,CAAC;YACZJ,OAAO,CAAC7B,IAAI,CAACiC,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC;UAChC;UACA,IAAInC,KAAK,CAAC8C,WAAW,EAAE;YACrBvC,WAAW,CAACgD,UAAU,CAACpD,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAExC,GAAG,CAACwC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAEP,GAAG,CAAC;UACnE;QACF;QACAN,IAAI,CAAC5B,IAAI,CAACkC,GAAG,CAAC;MAChB;IACF;EACF,CAAC;EACDrC,SAAS,CAACyD,WAAW,GAAG,CAACC,MAAM,EAAEC,OAAO,KAAK;IAC3C;IACA,MAAMC,KAAK,GAAGF,MAAM,CAAC,CAAC,CAAC;IACvB,IAAI,CAACE,KAAK,EAAE;MACV/D,aAAa,CAAC,0BAA0B,CAAC;MACzC;IACF;IACAgE,OAAO,CAACC,IAAI,CAAC,QAAQ,CAAC;;IAEtB;IACA,MAAM9C,MAAM,GAAG4C,KAAK,CAACG,SAAS,CAAC,CAAC;IAChC,MAAM9C,OAAO,GAAG2C,KAAK,CAACI,UAAU,CAAC,CAAC;IAClC,MAAMjD,IAAI,GAAG6C,KAAK,CAACK,aAAa,CAAC,CAAC;IAClC,MAAM/C,CAAC,GAAG0C,KAAK,CAACM,YAAY,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;;IAErD;IACA,MAAMC,OAAO,GAAG,EAAE;;IAElB;IACA,MAAMC,OAAO,GAAG,EAAE;;IAElB;IACA,MAAMC,OAAO,GAAG,EAAE;;IAElB;IACA,MAAM1C,MAAM,GAAG+B,KAAK,CAACY,SAAS,CAAC,CAAC;IAChC,MAAM1D,KAAK,GAAGC,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;IAC/B,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,EAAEF,CAAC,EAAE;MACpC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,EAAEH,CAAC,EAAE;QACpC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,EAAEJ,CAAC,EAAE;UACpCX,SAAS,CAAC2B,gBAAgB,CAAC1B,KAAK,CAACwE,YAAY,EAAE9D,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEgB,MAAM,EAAEf,KAAK,EAAEC,IAAI,EAAEC,MAAM,EAAEC,OAAO,EAAEC,CAAC,EAAEmD,OAAO,EAAEC,OAAO,EAAEC,OAAO,CAAC;QAC7H;MACF;IACF;IACA/D,WAAW,CAACkE,UAAU,CAAC,CAAC;;IAExB;IACA,MAAMC,QAAQ,GAAGlF,WAAW,CAACgB,WAAW,CAAC,CAAC;IAC1CkE,QAAQ,CAACC,SAAS,CAAC,CAAC,CAACC,OAAO,CAAC,IAAIC,YAAY,CAACT,OAAO,CAAC,EAAE,CAAC,CAAC;IAC1DM,QAAQ,CAACI,QAAQ,CAAC,CAAC,CAACF,OAAO,CAAC,IAAIG,WAAW,CAACV,OAAO,CAAC,CAAC;IACrD,IAAIrE,KAAK,CAACyC,cAAc,EAAE;MACxB,MAAMuC,KAAK,GAAG,IAAIH,YAAY,CAACP,OAAO,CAAC;MACvC,MAAMvC,OAAO,GAAGzC,YAAY,CAACkB,WAAW,CAAC;QACvCyE,kBAAkB,EAAE,CAAC;QACrBC,MAAM,EAAEF,KAAK;QACbG,IAAI,EAAE;MACR,CAAC,CAAC;MACFT,QAAQ,CAACT,YAAY,CAAC,CAAC,CAACmB,UAAU,CAACrD,OAAO,CAAC;IAC7C;IACA2B,OAAO,CAAC,CAAC,CAAC,GAAGgB,QAAQ;IACrB7E,aAAa,CAAC,iBAAiB,CAAC;IAChC+D,OAAO,CAACyB,OAAO,CAAC,QAAQ,CAAC;EAC3B,CAAC;AACH;;AAEA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAG;EACrBd,YAAY,EAAE,CAAC;EACf/B,cAAc,EAAE,KAAK;EACrBK,WAAW,EAAE;AACf,CAAC;;AAED;;AAEA,SAASyC,MAAMA,CAACxF,SAAS,EAAEC,KAAK,EAAE;EAChC,IAAIwF,aAAa,GAAGC,SAAS,CAACrC,MAAM,GAAG,CAAC,IAAIqC,SAAS,CAAC,CAAC,CAAC,KAAK5C,SAAS,GAAG4C,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EAC1FC,MAAM,CAACC,MAAM,CAAC3F,KAAK,EAAEsF,cAAc,EAAEE,aAAa,CAAC;;EAEnD;EACAnG,KAAK,CAACuG,GAAG,CAAC7F,SAAS,EAAEC,KAAK,CAAC;;EAE3B;EACAX,KAAK,CAACwG,IAAI,CAAC9F,SAAS,EAAEC,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;EAClCX,KAAK,CAACyG,MAAM,CAAC/F,SAAS,EAAEC,KAAK,EAAE,CAAC,cAAc,EAAE,gBAAgB,EAAE,aAAa,CAAC,CAAC;;EAEjF;EACAX,KAAK,CAACwG,IAAI,CAAC9F,SAAS,EAAEC,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;EAClCF,qBAAqB,CAACC,SAAS,EAAEC,KAAK,CAAC;AACzC;;AAEA;;AAEA,MAAMQ,WAAW,GAAGnB,KAAK,CAACmB,WAAW,CAAC+E,MAAM,EAAE,uBAAuB,CAAC;;AAEtE;;AAEA,IAAIQ,uBAAuB,GAAG;EAC5BvF,WAAW;EACX+E;AACF,CAAC;AAED,SAASQ,uBAAuB,IAAIC,OAAO,EAAET,MAAM,EAAE/E,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}