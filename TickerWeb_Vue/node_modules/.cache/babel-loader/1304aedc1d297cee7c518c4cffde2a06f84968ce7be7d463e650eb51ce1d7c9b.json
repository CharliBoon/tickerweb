{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport { e as distance2BetweenPoints } from '../Core/Math/index.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport vtkTriangle from './Triangle.js';\nimport vtkPoints from '../Core/Points.js';\nfunction intersectionStruct() {\n  return {\n    intersected: false,\n    subId: -1,\n    x: [0.0, 0.0, 0.0],\n    pCoords: [0.0, 0.0, 0.0],\n    t: -1\n  };\n}\nfunction vtkQuad(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkQuad');\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.getCellType = () => CellType.VTK_QUAD;\n  publicAPI.getNumberOfEdges = () => 4;\n  publicAPI.getNumberOfFaces = () => 0;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    let outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    let diagonalCase;\n    const point0 = model.points.getPoint(0, []);\n    const point1 = model.points.getPoint(1, []);\n    const point2 = model.points.getPoint(2, []);\n    const point3 = model.points.getPoint(3, []);\n    const d1 = distance2BetweenPoints(point0, point2);\n    const d2 = distance2BetweenPoints(point1, point3);\n\n    /* Figure out how to uniquely tessellate the quad. Watch out for\n     * equivalent triangulations (i.e., the triangulation is equivalent\n     * no matter where the diagonal). In this case use the point ids as\n     * a tie breaker to ensure unique triangulation across the quad.\n     */\n\n    // rare case; discriminate based on point id\n    if (d1 === d2) {\n      // find the maximum id\n      let id;\n      let maxId = 0;\n      let maxIdx = 0;\n      for (let i = 0; i < 4; i++) {\n        id = model.pointsIds[i];\n        if (id > maxId) {\n          maxId = id;\n          maxIdx = i;\n        }\n      }\n      if (maxIdx === 0 || maxIdx === 2) {\n        diagonalCase = 0;\n      } else {\n        diagonalCase = 1;\n      }\n    } else if (d1 < d2) {\n      diagonalCase = 0;\n    } else {\n      diagonalCase = 1;\n    }\n    let points = null;\n    if (!model.triangle) {\n      model.triangle = vtkTriangle.newInstance();\n      points = vtkPoints.newInstance();\n      points.setNumberOfPoints(3);\n      model.triangle.initialize(points);\n    } else {\n      points = model.triangle.getPoints();\n    }\n    let firstIntersect;\n    const firstIntersectTmpObj = intersectionStruct();\n    let secondIntersect;\n    const secondIntersectTmpObj = intersectionStruct();\n    let useFirstIntersection;\n    let useSecondIntersection;\n    switch (diagonalCase) {\n      case 0:\n        points.setPoint(0, ...point0);\n        points.setPoint(1, ...point1);\n        points.setPoint(2, ...point2);\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        points.setPoint(0, ...point2);\n        points.setPoint(1, ...point3);\n        points.setPoint(2, ...point0);\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1.0 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n      case 1:\n        points.setPoint(0, ...point0);\n        points.setPoint(1, ...point1);\n        points.setPoint(2, ...point3);\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        points.setPoint(0, ...point2);\n        points.setPoint(1, ...point3);\n        points.setPoint(2, ...point1);\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n    }\n    return outObj;\n  };\n  publicAPI.interpolationFunctions = (pcoords, weights) => {\n    const rm = 1 - pcoords[0];\n    const sm = 1 - pcoords[1];\n    weights[0] = rm * sm;\n    weights[1] = pcoords[0] * sm;\n    weights[2] = pcoords[0] * pcoords[1];\n    weights[3] = rm * pcoords[1];\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const point = [];\n\n    // Calculate the weights\n    publicAPI.interpolationFunctions(pcoords, weights);\n    x[0] = 0.0;\n    x[1] = 0.0;\n    x[2] = 0.0;\n    for (let i = 0; i < 4; i++) {\n      model.points.getPoint(i, point);\n      for (let j = 0; j < 3; j++) {\n        x[j] += point[j] * weights[i];\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkQuad(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkQuad');\n\n// ----------------------------------------------------------------------------\n\nvar vtkQuad$1 = {\n  newInstance,\n  extend\n};\nexport { vtkQuad$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkCell","e","distance2BetweenPoints","CellType","vtkTriangle","vtkPoints","intersectionStruct","intersected","subId","x","pCoords","t","vtkQuad","publicAPI","model","classHierarchy","push","getCellDimension","getCellType","VTK_QUAD","getNumberOfEdges","getNumberOfFaces","intersectWithLine","p1","p2","tol","pcoords","outObj","Number","MAX_VALUE","intersect","betweenPoints","diagonalCase","point0","points","getPoint","point1","point2","point3","d1","d2","id","maxId","maxIdx","i","pointsIds","triangle","newInstance","setNumberOfPoints","initialize","getPoints","firstIntersect","firstIntersectTmpObj","secondIntersect","secondIntersectTmpObj","useFirstIntersection","useSecondIntersection","setPoint","interpolationFunctions","weights","rm","sm","evaluateLocation","point","j","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","vtkQuad$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Common/DataModel/Quad.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport { e as distance2BetweenPoints } from '../Core/Math/index.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport vtkTriangle from './Triangle.js';\nimport vtkPoints from '../Core/Points.js';\n\nfunction intersectionStruct() {\n  return {\n    intersected: false,\n    subId: -1,\n    x: [0.0, 0.0, 0.0],\n    pCoords: [0.0, 0.0, 0.0],\n    t: -1\n  };\n}\nfunction vtkQuad(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkQuad');\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.getCellType = () => CellType.VTK_QUAD;\n  publicAPI.getNumberOfEdges = () => 4;\n  publicAPI.getNumberOfFaces = () => 0;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    let outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    let diagonalCase;\n    const point0 = model.points.getPoint(0, []);\n    const point1 = model.points.getPoint(1, []);\n    const point2 = model.points.getPoint(2, []);\n    const point3 = model.points.getPoint(3, []);\n    const d1 = distance2BetweenPoints(point0, point2);\n    const d2 = distance2BetweenPoints(point1, point3);\n\n    /* Figure out how to uniquely tessellate the quad. Watch out for\n     * equivalent triangulations (i.e., the triangulation is equivalent\n     * no matter where the diagonal). In this case use the point ids as\n     * a tie breaker to ensure unique triangulation across the quad.\n     */\n\n    // rare case; discriminate based on point id\n    if (d1 === d2) {\n      // find the maximum id\n      let id;\n      let maxId = 0;\n      let maxIdx = 0;\n      for (let i = 0; i < 4; i++) {\n        id = model.pointsIds[i];\n        if (id > maxId) {\n          maxId = id;\n          maxIdx = i;\n        }\n      }\n      if (maxIdx === 0 || maxIdx === 2) {\n        diagonalCase = 0;\n      } else {\n        diagonalCase = 1;\n      }\n    } else if (d1 < d2) {\n      diagonalCase = 0;\n    } else {\n      diagonalCase = 1;\n    }\n    let points = null;\n    if (!model.triangle) {\n      model.triangle = vtkTriangle.newInstance();\n      points = vtkPoints.newInstance();\n      points.setNumberOfPoints(3);\n      model.triangle.initialize(points);\n    } else {\n      points = model.triangle.getPoints();\n    }\n    let firstIntersect;\n    const firstIntersectTmpObj = intersectionStruct();\n    let secondIntersect;\n    const secondIntersectTmpObj = intersectionStruct();\n    let useFirstIntersection;\n    let useSecondIntersection;\n    switch (diagonalCase) {\n      case 0:\n        points.setPoint(0, ...point0);\n        points.setPoint(1, ...point1);\n        points.setPoint(2, ...point2);\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        points.setPoint(0, ...point2);\n        points.setPoint(1, ...point3);\n        points.setPoint(2, ...point0);\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1.0 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n      case 1:\n        points.setPoint(0, ...point0);\n        points.setPoint(1, ...point1);\n        points.setPoint(2, ...point3);\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        points.setPoint(0, ...point2);\n        points.setPoint(1, ...point3);\n        points.setPoint(2, ...point1);\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n    }\n    return outObj;\n  };\n  publicAPI.interpolationFunctions = (pcoords, weights) => {\n    const rm = 1 - pcoords[0];\n    const sm = 1 - pcoords[1];\n    weights[0] = rm * sm;\n    weights[1] = pcoords[0] * sm;\n    weights[2] = pcoords[0] * pcoords[1];\n    weights[3] = rm * pcoords[1];\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const point = [];\n\n    // Calculate the weights\n    publicAPI.interpolationFunctions(pcoords, weights);\n    x[0] = 0.0;\n    x[1] = 0.0;\n    x[2] = 0.0;\n    for (let i = 0; i < 4; i++) {\n      model.points.getPoint(i, point);\n      for (let j = 0; j < 3; j++) {\n        x[j] += point[j] * weights[i];\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkQuad(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkQuad');\n\n// ----------------------------------------------------------------------------\n\nvar vtkQuad$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkQuad$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}