{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport { mat4 } from 'gl-matrix';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUStorageBuffer from './StorageBuffer.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport vtkWebGPUTypes from './Types.js';\nimport { BlendMode } from '../Core/VolumeMapper/Constants.js';\nconst volFragTemplate = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n`;\nconst tmpMat4 = new Float64Array(16);\nconst tmp2Mat4 = new Float64Array(16);\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUVolumePassFSQ methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUVolumePassFSQ(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVolumePassFSQ');\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);']).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderVolume = (hash, pipeline, vertexInput) => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    let code = fDesc.getCode();\n    const compositeCalls = [];\n    const traverseCalls = [];\n    for (let i = 0; i < model.volumes.length; i++) {\n      // todo pass rowPos\n      const blendMode = model.volumes[i].getRenderable().getMapper().getBlendMode();\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeCalls.push(`    sampleColor = processVolume(volTexture${i}, ${i}, ${model.rowStarts[i]}, rayPosSC, tfunRows);`);\n        compositeCalls.push(`    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);\n      } else {\n        traverseCalls.push(`  sampleColor = traverseVals[${i}];`);\n        traverseCalls.push(`  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);\n      }\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::CompositeCalls', compositeCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseCalls', traverseCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseDec', [`var<private> traverseVals: array<vec4<f32>,${model.volumes.length}>;`]).result;\n\n    // call the full and partial methods as needed\n    let compositeWhileTraversing = false;\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeWhileTraversing = true;\n      } else if (blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseMax(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      } else if (blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseMin(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      } else if (blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseAverage(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      } else if (blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseAdditive(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      }\n    }\n    if (compositeWhileTraversing) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', ['    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);']).result;\n    }\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderVolume', publicAPI.replaceShaderVolume);\n  publicAPI.updateLUTImage = device => {\n    // depends on\n    // - volumes array (length and values) - mtime\n    // - tfun arrays - renderable/property mtime\n\n    let mtime = publicAPI.getMTime();\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i].getRenderable();\n      const image = vol.getMapper().getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime());\n    }\n    if (mtime < model.lutBuildTime.getMTime()) {\n      return;\n    }\n\n    // first determine how large the image should be\n    model.numRows = 0;\n    model.rowStarts = [];\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      model.rowStarts.push(model.numRows);\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      const numIComps = iComps ? numComp : 1;\n      model.numRows += numIComps;\n    }\n\n    // allocate the image array\n    const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);\n    const opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);\n    let imgRow = 0;\n    const tmpTable = new Float32Array(model.rowLength * 3);\n    const rowLength = model.rowLength;\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      const numIComps = iComps ? numComp : 1;\n      for (let c = 0; c < numIComps; ++c) {\n        const cfun = vprop.getRGBTransferFunction(c);\n        const cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);\n        let ioffset = imgRow * rowLength * 4;\n        for (let i = 0; i < rowLength; ++i) {\n          colorArray[ioffset + i * 4] = 255.0 * tmpTable[i * 3];\n          colorArray[ioffset + i * 4 + 1] = 255.0 * tmpTable[i * 3 + 1];\n          colorArray[ioffset + i * 4 + 2] = 255.0 * tmpTable[i * 3 + 2];\n          colorArray[ioffset + i * 4 + 3] = 255.0;\n          for (let co = 0; co < 4; co++) {\n            colorArray[ioffset + (rowLength + i) * 4 + co] = colorArray[ioffset + i * 4 + co];\n          }\n        }\n        const ofun = vprop.getScalarOpacity(c);\n        const opacityFactor = model.sampleDist / vprop.getScalarOpacityUnitDistance(c);\n        const oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1);\n        // adjust for sample distance etc\n        ioffset = imgRow * rowLength;\n        for (let i = 0; i < rowLength; ++i) {\n          opacityArray[ioffset + i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n          opacityArray[ioffset + i + rowLength] = opacityArray[ioffset + i];\n        }\n        imgRow += 2;\n      }\n    }\n    {\n      const treq = {\n        nativeArray: colorArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'rgba8unorm'\n      };\n      const newTex = device.getTextureManager().getTexture(treq);\n      const tview = newTex.createView('tfunTexture');\n      model.textureViews[2] = tview;\n    }\n    {\n      const treq = {\n        nativeArray: opacityArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'r16float'\n      };\n      const newTex = device.getTextureManager().getTexture(treq);\n      const tview = newTex.createView('ofunTexture');\n      model.textureViews[3] = tview;\n    }\n    model.lutBuildTime.modified();\n  };\n  publicAPI.updateSSBO = device => {\n    // if any of\n    // - color or opacity tfun ranges changed - volume Mtime\n    // - any volume matrix changed - volume MTime\n    // - stabilized center changed - ren.stabilizedMTime\n    // - any volume's input data worldtoindex or dimensions changed - input's mtime\n    //\n    let mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i].getRenderable();\n      const volMapr = vol.getMapper();\n      const image = volMapr.getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime(), volMapr.getMTime());\n    }\n    if (mtime < model.SSBO.getSendTime()) {\n      return;\n    }\n\n    // create the volumeSBBO\n    const center = model.WebGPURenderer.getStabilizedCenterByReference();\n    model.SSBO.clearData();\n    model.SSBO.setNumberOfInstances(model.volumes.length);\n\n    // create SCTC matrices  SC -> world -> model -> index -> tcoord\n    //\n    // when doing coord conversions from A to C recall\n    // the order is mat4.mult(AtoC, BtoC, AtoB);\n    //\n    const marray = new Float64Array(model.volumes.length * 16);\n    const vPlaneArray = new Float64Array(model.volumes.length * 16);\n    const tstepArray = new Float64Array(model.volumes.length * 4);\n    const shadeArray = new Float64Array(model.volumes.length * 4);\n    const spacingArray = new Float64Array(model.volumes.length * 4);\n    const ipScalarRangeArray = new Float64Array(model.volumes.length * 4);\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const image = volMapr.getInputData();\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center);\n      // tmpMat4 is now SC->World\n\n      const mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4);\n      // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmp4Mat is now SC->Model\n\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n      const modelToIndex = image.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4);\n      // tmpMat4 is now SC -> Index\n\n      const dims = image.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmpMat4 is now SC -> Tcoord\n\n      for (let j = 0; j < 16; j++) {\n        marray[vidx * 16 + j] = tmpMat4[j];\n      }\n      mat4.invert(tmpMat4, tmpMat4);\n      // now it is Tcoord To SC\n\n      for (let j = 0; j < 4; j++) {\n        vPlaneArray[vidx * 16 + j * 4] = tmpMat4[j * 4];\n        vPlaneArray[vidx * 16 + j * 4 + 1] = tmpMat4[j * 4 + 1];\n        vPlaneArray[vidx * 16 + j * 4 + 2] = tmpMat4[j * 4 + 2];\n        vPlaneArray[vidx * 16 + j * 4 + 3] = 0.0;\n      }\n      tstepArray[vidx * 4] = 1.0 / dims[0];\n      tstepArray[vidx * 4 + 1] = 1.0 / dims[1];\n      tstepArray[vidx * 4 + 2] = 1.0 / dims[2];\n      tstepArray[vidx * 4 + 3] = 1.0;\n      shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1.0 : 0.0;\n      const spacing = image.getSpacing();\n      spacingArray[vidx * 4] = spacing[0];\n      spacingArray[vidx * 4 + 1] = spacing[1];\n      spacingArray[vidx * 4 + 2] = spacing[2];\n      spacingArray[vidx * 4 + 3] = 1.0;\n\n      // handle filteringMode\n      const tScale = model.textureViews[vidx + 4].getTexture().getScale();\n      const ipScalarRange = volMapr.getIpScalarRange();\n      ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;\n      ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;\n      ipScalarRangeArray[vidx * 4 + 2] = volMapr.getFilterMode();\n    }\n    model.SSBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n    model.SSBO.addEntry('planeNormals', 'mat4x4<f32>');\n    model.SSBO.addEntry('shade', 'vec4<f32>');\n    model.SSBO.addEntry('tstep', 'vec4<f32>');\n    model.SSBO.addEntry('spacing', 'vec4<f32>');\n    model.SSBO.addEntry('ipScalarRange', 'vec4<f32>');\n    model.SSBO.setAllInstancesFromArray('SCTCMatrix', marray);\n    model.SSBO.setAllInstancesFromArray('planeNormals', vPlaneArray);\n    model.SSBO.setAllInstancesFromArray('shade', shadeArray);\n    model.SSBO.setAllInstancesFromArray('tstep', tstepArray);\n    model.SSBO.setAllInstancesFromArray('spacing', spacingArray);\n    model.SSBO.setAllInstancesFromArray('ipScalarRange', ipScalarRangeArray);\n    model.SSBO.send(device);\n\n    // now create the componentSSBO\n    model.componentSSBO.clearData();\n    model.componentSSBO.setNumberOfInstances(model.numRows);\n    const cScaleArray = new Float64Array(model.numRows);\n    const cShiftArray = new Float64Array(model.numRows);\n    const oScaleArray = new Float64Array(model.numRows);\n    const oShiftArray = new Float64Array(model.numRows);\n    const gominArray = new Float64Array(model.numRows);\n    const gomaxArray = new Float64Array(model.numRows);\n    const goshiftArray = new Float64Array(model.numRows);\n    const goscaleArray = new Float64Array(model.numRows);\n    let rowIdx = 0;\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      // const numIComps = iComps ? numComp : 1;\n\n      // half float?\n      const tformat = model.textureViews[vidx + 4].getTexture().getFormat();\n      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);\n      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';\n      const volInfo = {\n        scale: [255.0],\n        offset: [0.0]\n      };\n      if (halfFloat) {\n        volInfo.scale[0] = 1.0;\n      }\n\n      // three levels of shift scale combined into one\n      // for performance in the fragment shader\n      for (let compIdx = 0; compIdx < numComp; compIdx++) {\n        const target = iComps ? compIdx : 0;\n        const sscale = volInfo.scale[compIdx];\n        const ofun = vprop.getScalarOpacity(target);\n        const oRange = ofun.getRange();\n        const oscale = sscale / (oRange[1] - oRange[0]);\n        const oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);\n        oShiftArray[rowIdx] = oshift;\n        oScaleArray[rowIdx] = oscale;\n        const cfun = vprop.getRGBTransferFunction(target);\n        const cRange = cfun.getRange();\n        cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);\n        cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]);\n\n        // todo sscale for dependent should be based off of the A channel?\n        // not target (which is 0 in that case)\n        const useGO = vprop.getUseGradientOpacity(target);\n        if (useGO) {\n          const gomin = vprop.getGradientOpacityMinimumOpacity(target);\n          const gomax = vprop.getGradientOpacityMaximumOpacity(target);\n          gominArray[rowIdx] = gomin;\n          gomaxArray[rowIdx] = gomax;\n          const goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];\n          goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);\n          goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;\n        } else {\n          gominArray[rowIdx] = 1.0;\n          gomaxArray[rowIdx] = 1.0;\n          goscaleArray[rowIdx] = 0.0;\n          goshiftArray[rowIdx] = 1.0;\n        }\n        rowIdx++;\n      }\n    }\n    model.componentSSBO.addEntry('cScale', 'f32');\n    model.componentSSBO.addEntry('cShift', 'f32');\n    model.componentSSBO.addEntry('oScale', 'f32');\n    model.componentSSBO.addEntry('oShift', 'f32');\n    model.componentSSBO.addEntry('goShift', 'f32');\n    model.componentSSBO.addEntry('goScale', 'f32');\n    model.componentSSBO.addEntry('gomin', 'f32');\n    model.componentSSBO.addEntry('gomax', 'f32');\n    model.componentSSBO.setAllInstancesFromArray('cScale', cScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('cShift', cShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('oScale', oScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('oShift', oShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('goScale', goscaleArray);\n    model.componentSSBO.setAllInstancesFromArray('goShift', goshiftArray);\n    model.componentSSBO.setAllInstancesFromArray('gomin', gominArray);\n    model.componentSSBO.setAllInstancesFromArray('gomax', gomaxArray);\n    model.componentSSBO.send(device);\n  };\n  const superClassUpdateBuffers = publicAPI.updateBuffers;\n  publicAPI.updateBuffers = () => {\n    superClassUpdateBuffers();\n    // compute the min step size\n    let sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i];\n      const volMapr = vol.getRenderable().getMapper();\n      const sd = volMapr.getSampleDistance();\n      if (sd < sampleDist) {\n        sampleDist = sd;\n      }\n    }\n    if (model.sampleDist !== sampleDist) {\n      model.sampleDist = sampleDist;\n      model.UBO.setValue('SampleDistance', sampleDist);\n      model.UBO.sendIfNeeded(model.device);\n    }\n\n    // add in 3d volume textures\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const image = volMapr.getInputData();\n      const newTex = model.device.getTextureManager().getTextureForImageData(image);\n      if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {\n        const tview = newTex.createView(`volTexture${vidx}`);\n        model.textureViews[vidx + 4] = tview;\n      }\n    }\n\n    // clear any old leftovers\n    if (model.volumes.length < model.lastVolumeLength) {\n      // we may have gaps in the array right now so no splice\n      for (let i = model.volumes.length; i < model.lastVolumeLength; i++) {\n        model.textureViews.pop();\n      }\n    }\n    model.lastVolumeLength = model.volumes.length;\n    publicAPI.updateLUTImage(model.device);\n    publicAPI.updateSSBO(model.device);\n    if (!model.clampSampler) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: 'linear',\n        magFilter: 'linear'\n      });\n    }\n  };\n  publicAPI.computePipelineHash = () => {\n    model.pipelineHash = 'volfsq';\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n      model.pipelineHash += `${blendMode}`;\n    }\n  };\n\n  // marks modified when needed\n  publicAPI.setVolumes = val => {\n    if (!model.volumes || model.volumes.length !== val.length) {\n      model.volumes = [...val];\n      publicAPI.modified();\n      return;\n    }\n    for (let i = 0; i < val.length; i++) {\n      if (val[i] !== model.volumes[i]) {\n        model.volumes = [...val];\n        publicAPI.modified();\n        return;\n      }\n    }\n  };\n  const superclassGetBindables = publicAPI.getBindables;\n  publicAPI.getBindables = () => {\n    const bindables = superclassGetBindables();\n    bindables.push(model.componentSSBO);\n    bindables.push(model.clampSampler);\n    return bindables;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  volumes: null,\n  rowLength: 1024,\n  lastVolumeLength: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  model.fragmentShaderTemplate = volFragTemplate;\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SampleDistance', 'f32');\n  model.SSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'volumeSSBO'\n  });\n  model.componentSSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'componentSSBO'\n  });\n  model.lutBuildTime = {};\n  macro.obj(model.lutBuildTime, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkWebGPUVolumePassFSQ(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUVolumePassFSQ');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUVolumePassFSQ$1 = {\n  newInstance,\n  extend\n};\nexport { vtkWebGPUVolumePassFSQ$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","mat4","vtkWebGPUFullScreenQuad","vtkWebGPUUniformBuffer","vtkWebGPUShaderCache","vtkWebGPUStorageBuffer","vtkWebGPUSampler","vtkWebGPUTypes","BlendMode","volFragTemplate","tmpMat4","Float64Array","tmp2Mat4","vtkWebGPUVolumePassFSQ","publicAPI","model","classHierarchy","push","replaceShaderPosition","hash","pipeline","vertexInput","vDesc","getShaderDescription","addBuiltinOutput","code","getCode","substitute","result","setCode","fDesc","addBuiltinInput","shaderReplacements","set","replaceShaderVolume","compositeCalls","traverseCalls","i","volumes","length","blendMode","getRenderable","getMapper","getBlendMode","COMPOSITE_BLEND","rowStarts","compositeWhileTraversing","vidx","MAXIMUM_INTENSITY_BLEND","MINIMUM_INTENSITY_BLEND","AVERAGE_INTENSITY_BLEND","ADDITIVE_INTENSITY_BLEND","updateLUTImage","device","mtime","getMTime","vol","image","getInputData","Math","max","lutBuildTime","numRows","webgpuvol","actor","volMapr","vprop","getProperty","scalars","getPointData","getScalars","numComp","getNumberOfComponents","iComps","getIndependentComponents","numIComps","colorArray","Uint8ClampedArray","rowLength","opacityArray","Float32Array","imgRow","tmpTable","c","cfun","getRGBTransferFunction","cRange","getRange","getTable","ioffset","co","ofun","getScalarOpacity","opacityFactor","sampleDist","getScalarOpacityUnitDistance","oRange","treq","nativeArray","width","height","depth","format","newTex","getTextureManager","getTexture","tview","createView","textureViews","modified","updateSSBO","WebGPURenderer","getStabilizedTime","SSBO","getSendTime","center","getStabilizedCenterByReference","clearData","setNumberOfInstances","marray","vPlaneArray","tstepArray","shadeArray","spacingArray","ipScalarRangeArray","identity","translate","mcwcmat","getMatrix","transpose","invert","multiply","modelToIndex","getWorldToIndex","dims","getDimensions","scale","j","getShade","spacing","getSpacing","tScale","getScale","ipScalarRange","getIpScalarRange","getFilterMode","addEntry","setAllInstancesFromArray","send","componentSSBO","cScaleArray","cShiftArray","oScaleArray","oShiftArray","gominArray","gomaxArray","goshiftArray","goscaleArray","rowIdx","tformat","getFormat","tDetails","getDetailsFromTextureFormat","halfFloat","elementSize","sampleType","volInfo","offset","compIdx","target","sscale","oscale","oshift","useGO","getUseGradientOpacity","gomin","getGradientOpacityMinimumOpacity","gomax","getGradientOpacityMaximumOpacity","goRange","getGradientOpacityMinimumValue","getGradientOpacityMaximumValue","superClassUpdateBuffers","updateBuffers","getSampleDistance","sd","UBO","setValue","sendIfNeeded","getTextureForImageData","lastVolumeLength","pop","clampSampler","newInstance","label","create","minFilter","magFilter","computePipelineHash","pipelineHash","setVolumes","val","superclassGetBindables","getBindables","bindables","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","fragmentShaderTemplate","obj","vtkWebGPUVolumePassFSQ$1","default"],"sources":["C:/Users/Malcolm/my-vtkjs-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/VolumePassFSQ.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { mat4 } from 'gl-matrix';\nimport vtkWebGPUFullScreenQuad from './FullScreenQuad.js';\nimport vtkWebGPUUniformBuffer from './UniformBuffer.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUStorageBuffer from './StorageBuffer.js';\nimport vtkWebGPUSampler from './Sampler.js';\nimport vtkWebGPUTypes from './Types.js';\nimport { BlendMode } from '../Core/VolumeMapper/Constants.js';\n\nconst volFragTemplate = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n`;\nconst tmpMat4 = new Float64Array(16);\nconst tmp2Mat4 = new Float64Array(16);\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUVolumePassFSQ methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUVolumePassFSQ(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUVolumePassFSQ');\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);']).result;\n    vDesc.setCode(code);\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');\n  };\n  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  publicAPI.replaceShaderVolume = (hash, pipeline, vertexInput) => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    let code = fDesc.getCode();\n    const compositeCalls = [];\n    const traverseCalls = [];\n    for (let i = 0; i < model.volumes.length; i++) {\n      // todo pass rowPos\n      const blendMode = model.volumes[i].getRenderable().getMapper().getBlendMode();\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeCalls.push(`    sampleColor = processVolume(volTexture${i}, ${i}, ${model.rowStarts[i]}, rayPosSC, tfunRows);`);\n        compositeCalls.push(`    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);\n      } else {\n        traverseCalls.push(`  sampleColor = traverseVals[${i}];`);\n        traverseCalls.push(`  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);\n      }\n    }\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::CompositeCalls', compositeCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseCalls', traverseCalls).result;\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::TraverseDec', [`var<private> traverseVals: array<vec4<f32>,${model.volumes.length}>;`]).result;\n\n    // call the full and partial methods as needed\n    let compositeWhileTraversing = false;\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n      if (blendMode === BlendMode.COMPOSITE_BLEND) {\n        compositeWhileTraversing = true;\n      } else if (blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseMax(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      } else if (blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseMin(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      } else if (blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseAverage(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      } else if (blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {\n        code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', [`    traverseAdditive(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;\n      }\n    }\n    if (compositeWhileTraversing) {\n      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Volume::Loop', ['    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);']).result;\n    }\n    fDesc.setCode(code);\n  };\n  model.shaderReplacements.set('replaceShaderVolume', publicAPI.replaceShaderVolume);\n  publicAPI.updateLUTImage = device => {\n    // depends on\n    // - volumes array (length and values) - mtime\n    // - tfun arrays - renderable/property mtime\n\n    let mtime = publicAPI.getMTime();\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i].getRenderable();\n      const image = vol.getMapper().getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime());\n    }\n    if (mtime < model.lutBuildTime.getMTime()) {\n      return;\n    }\n\n    // first determine how large the image should be\n    model.numRows = 0;\n    model.rowStarts = [];\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      model.rowStarts.push(model.numRows);\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      const numIComps = iComps ? numComp : 1;\n      model.numRows += numIComps;\n    }\n\n    // allocate the image array\n    const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);\n    const opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);\n    let imgRow = 0;\n    const tmpTable = new Float32Array(model.rowLength * 3);\n    const rowLength = model.rowLength;\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      const numIComps = iComps ? numComp : 1;\n      for (let c = 0; c < numIComps; ++c) {\n        const cfun = vprop.getRGBTransferFunction(c);\n        const cRange = cfun.getRange();\n        cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);\n        let ioffset = imgRow * rowLength * 4;\n        for (let i = 0; i < rowLength; ++i) {\n          colorArray[ioffset + i * 4] = 255.0 * tmpTable[i * 3];\n          colorArray[ioffset + i * 4 + 1] = 255.0 * tmpTable[i * 3 + 1];\n          colorArray[ioffset + i * 4 + 2] = 255.0 * tmpTable[i * 3 + 2];\n          colorArray[ioffset + i * 4 + 3] = 255.0;\n          for (let co = 0; co < 4; co++) {\n            colorArray[ioffset + (rowLength + i) * 4 + co] = colorArray[ioffset + i * 4 + co];\n          }\n        }\n        const ofun = vprop.getScalarOpacity(c);\n        const opacityFactor = model.sampleDist / vprop.getScalarOpacityUnitDistance(c);\n        const oRange = ofun.getRange();\n        ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1);\n        // adjust for sample distance etc\n        ioffset = imgRow * rowLength;\n        for (let i = 0; i < rowLength; ++i) {\n          opacityArray[ioffset + i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n          opacityArray[ioffset + i + rowLength] = opacityArray[ioffset + i];\n        }\n        imgRow += 2;\n      }\n    }\n    {\n      const treq = {\n        nativeArray: colorArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'rgba8unorm'\n      };\n      const newTex = device.getTextureManager().getTexture(treq);\n      const tview = newTex.createView('tfunTexture');\n      model.textureViews[2] = tview;\n    }\n    {\n      const treq = {\n        nativeArray: opacityArray,\n        width: model.rowLength,\n        height: model.numRows * 2,\n        depth: 1,\n        format: 'r16float'\n      };\n      const newTex = device.getTextureManager().getTexture(treq);\n      const tview = newTex.createView('ofunTexture');\n      model.textureViews[3] = tview;\n    }\n    model.lutBuildTime.modified();\n  };\n  publicAPI.updateSSBO = device => {\n    // if any of\n    // - color or opacity tfun ranges changed - volume Mtime\n    // - any volume matrix changed - volume MTime\n    // - stabilized center changed - ren.stabilizedMTime\n    // - any volume's input data worldtoindex or dimensions changed - input's mtime\n    //\n    let mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i].getRenderable();\n      const volMapr = vol.getMapper();\n      const image = volMapr.getInputData();\n      mtime = Math.max(mtime, vol.getMTime(), image.getMTime(), volMapr.getMTime());\n    }\n    if (mtime < model.SSBO.getSendTime()) {\n      return;\n    }\n\n    // create the volumeSBBO\n    const center = model.WebGPURenderer.getStabilizedCenterByReference();\n    model.SSBO.clearData();\n    model.SSBO.setNumberOfInstances(model.volumes.length);\n\n    // create SCTC matrices  SC -> world -> model -> index -> tcoord\n    //\n    // when doing coord conversions from A to C recall\n    // the order is mat4.mult(AtoC, BtoC, AtoB);\n    //\n    const marray = new Float64Array(model.volumes.length * 16);\n    const vPlaneArray = new Float64Array(model.volumes.length * 16);\n    const tstepArray = new Float64Array(model.volumes.length * 4);\n    const shadeArray = new Float64Array(model.volumes.length * 4);\n    const spacingArray = new Float64Array(model.volumes.length * 4);\n    const ipScalarRangeArray = new Float64Array(model.volumes.length * 4);\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const image = volMapr.getInputData();\n      mat4.identity(tmpMat4);\n      mat4.translate(tmpMat4, tmpMat4, center);\n      // tmpMat4 is now SC->World\n\n      const mcwcmat = actor.getMatrix();\n      mat4.transpose(tmp2Mat4, mcwcmat);\n      mat4.invert(tmp2Mat4, tmp2Mat4);\n      // tmp2Mat4 is now world to model\n\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmp4Mat is now SC->Model\n\n      // the method on the data is world to index but the volume is in\n      // model coordinates so really in this context it is model to index\n      const modelToIndex = image.getWorldToIndex();\n      mat4.multiply(tmpMat4, modelToIndex, tmpMat4);\n      // tmpMat4 is now SC -> Index\n\n      const dims = image.getDimensions();\n      mat4.identity(tmp2Mat4);\n      mat4.scale(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);\n      mat4.multiply(tmpMat4, tmp2Mat4, tmpMat4);\n      // tmpMat4 is now SC -> Tcoord\n\n      for (let j = 0; j < 16; j++) {\n        marray[vidx * 16 + j] = tmpMat4[j];\n      }\n      mat4.invert(tmpMat4, tmpMat4);\n      // now it is Tcoord To SC\n\n      for (let j = 0; j < 4; j++) {\n        vPlaneArray[vidx * 16 + j * 4] = tmpMat4[j * 4];\n        vPlaneArray[vidx * 16 + j * 4 + 1] = tmpMat4[j * 4 + 1];\n        vPlaneArray[vidx * 16 + j * 4 + 2] = tmpMat4[j * 4 + 2];\n        vPlaneArray[vidx * 16 + j * 4 + 3] = 0.0;\n      }\n      tstepArray[vidx * 4] = 1.0 / dims[0];\n      tstepArray[vidx * 4 + 1] = 1.0 / dims[1];\n      tstepArray[vidx * 4 + 2] = 1.0 / dims[2];\n      tstepArray[vidx * 4 + 3] = 1.0;\n      shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1.0 : 0.0;\n      const spacing = image.getSpacing();\n      spacingArray[vidx * 4] = spacing[0];\n      spacingArray[vidx * 4 + 1] = spacing[1];\n      spacingArray[vidx * 4 + 2] = spacing[2];\n      spacingArray[vidx * 4 + 3] = 1.0;\n\n      // handle filteringMode\n      const tScale = model.textureViews[vidx + 4].getTexture().getScale();\n      const ipScalarRange = volMapr.getIpScalarRange();\n      ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;\n      ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;\n      ipScalarRangeArray[vidx * 4 + 2] = volMapr.getFilterMode();\n    }\n    model.SSBO.addEntry('SCTCMatrix', 'mat4x4<f32>');\n    model.SSBO.addEntry('planeNormals', 'mat4x4<f32>');\n    model.SSBO.addEntry('shade', 'vec4<f32>');\n    model.SSBO.addEntry('tstep', 'vec4<f32>');\n    model.SSBO.addEntry('spacing', 'vec4<f32>');\n    model.SSBO.addEntry('ipScalarRange', 'vec4<f32>');\n    model.SSBO.setAllInstancesFromArray('SCTCMatrix', marray);\n    model.SSBO.setAllInstancesFromArray('planeNormals', vPlaneArray);\n    model.SSBO.setAllInstancesFromArray('shade', shadeArray);\n    model.SSBO.setAllInstancesFromArray('tstep', tstepArray);\n    model.SSBO.setAllInstancesFromArray('spacing', spacingArray);\n    model.SSBO.setAllInstancesFromArray('ipScalarRange', ipScalarRangeArray);\n    model.SSBO.send(device);\n\n    // now create the componentSSBO\n    model.componentSSBO.clearData();\n    model.componentSSBO.setNumberOfInstances(model.numRows);\n    const cScaleArray = new Float64Array(model.numRows);\n    const cShiftArray = new Float64Array(model.numRows);\n    const oScaleArray = new Float64Array(model.numRows);\n    const oShiftArray = new Float64Array(model.numRows);\n    const gominArray = new Float64Array(model.numRows);\n    const gomaxArray = new Float64Array(model.numRows);\n    const goshiftArray = new Float64Array(model.numRows);\n    const goscaleArray = new Float64Array(model.numRows);\n    let rowIdx = 0;\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const vprop = actor.getProperty();\n      const image = volMapr.getInputData();\n      const scalars = image.getPointData() && image.getPointData().getScalars();\n      const numComp = scalars.getNumberOfComponents();\n      const iComps = vprop.getIndependentComponents();\n      // const numIComps = iComps ? numComp : 1;\n\n      // half float?\n      const tformat = model.textureViews[vidx + 4].getTexture().getFormat();\n      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);\n      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';\n      const volInfo = {\n        scale: [255.0],\n        offset: [0.0]\n      };\n      if (halfFloat) {\n        volInfo.scale[0] = 1.0;\n      }\n\n      // three levels of shift scale combined into one\n      // for performance in the fragment shader\n      for (let compIdx = 0; compIdx < numComp; compIdx++) {\n        const target = iComps ? compIdx : 0;\n        const sscale = volInfo.scale[compIdx];\n        const ofun = vprop.getScalarOpacity(target);\n        const oRange = ofun.getRange();\n        const oscale = sscale / (oRange[1] - oRange[0]);\n        const oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);\n        oShiftArray[rowIdx] = oshift;\n        oScaleArray[rowIdx] = oscale;\n        const cfun = vprop.getRGBTransferFunction(target);\n        const cRange = cfun.getRange();\n        cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);\n        cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]);\n\n        // todo sscale for dependent should be based off of the A channel?\n        // not target (which is 0 in that case)\n        const useGO = vprop.getUseGradientOpacity(target);\n        if (useGO) {\n          const gomin = vprop.getGradientOpacityMinimumOpacity(target);\n          const gomax = vprop.getGradientOpacityMaximumOpacity(target);\n          gominArray[rowIdx] = gomin;\n          gomaxArray[rowIdx] = gomax;\n          const goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];\n          goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);\n          goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;\n        } else {\n          gominArray[rowIdx] = 1.0;\n          gomaxArray[rowIdx] = 1.0;\n          goscaleArray[rowIdx] = 0.0;\n          goshiftArray[rowIdx] = 1.0;\n        }\n        rowIdx++;\n      }\n    }\n    model.componentSSBO.addEntry('cScale', 'f32');\n    model.componentSSBO.addEntry('cShift', 'f32');\n    model.componentSSBO.addEntry('oScale', 'f32');\n    model.componentSSBO.addEntry('oShift', 'f32');\n    model.componentSSBO.addEntry('goShift', 'f32');\n    model.componentSSBO.addEntry('goScale', 'f32');\n    model.componentSSBO.addEntry('gomin', 'f32');\n    model.componentSSBO.addEntry('gomax', 'f32');\n    model.componentSSBO.setAllInstancesFromArray('cScale', cScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('cShift', cShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('oScale', oScaleArray);\n    model.componentSSBO.setAllInstancesFromArray('oShift', oShiftArray);\n    model.componentSSBO.setAllInstancesFromArray('goScale', goscaleArray);\n    model.componentSSBO.setAllInstancesFromArray('goShift', goshiftArray);\n    model.componentSSBO.setAllInstancesFromArray('gomin', gominArray);\n    model.componentSSBO.setAllInstancesFromArray('gomax', gomaxArray);\n    model.componentSSBO.send(device);\n  };\n  const superClassUpdateBuffers = publicAPI.updateBuffers;\n  publicAPI.updateBuffers = () => {\n    superClassUpdateBuffers();\n    // compute the min step size\n    let sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();\n    for (let i = 0; i < model.volumes.length; i++) {\n      const vol = model.volumes[i];\n      const volMapr = vol.getRenderable().getMapper();\n      const sd = volMapr.getSampleDistance();\n      if (sd < sampleDist) {\n        sampleDist = sd;\n      }\n    }\n    if (model.sampleDist !== sampleDist) {\n      model.sampleDist = sampleDist;\n      model.UBO.setValue('SampleDistance', sampleDist);\n      model.UBO.sendIfNeeded(model.device);\n    }\n\n    // add in 3d volume textures\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const webgpuvol = model.volumes[vidx];\n      const actor = webgpuvol.getRenderable();\n      const volMapr = actor.getMapper();\n      const image = volMapr.getInputData();\n      const newTex = model.device.getTextureManager().getTextureForImageData(image);\n      if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {\n        const tview = newTex.createView(`volTexture${vidx}`);\n        model.textureViews[vidx + 4] = tview;\n      }\n    }\n\n    // clear any old leftovers\n    if (model.volumes.length < model.lastVolumeLength) {\n      // we may have gaps in the array right now so no splice\n      for (let i = model.volumes.length; i < model.lastVolumeLength; i++) {\n        model.textureViews.pop();\n      }\n    }\n    model.lastVolumeLength = model.volumes.length;\n    publicAPI.updateLUTImage(model.device);\n    publicAPI.updateSSBO(model.device);\n    if (!model.clampSampler) {\n      model.clampSampler = vtkWebGPUSampler.newInstance({\n        label: 'clampSampler'\n      });\n      model.clampSampler.create(model.device, {\n        minFilter: 'linear',\n        magFilter: 'linear'\n      });\n    }\n  };\n  publicAPI.computePipelineHash = () => {\n    model.pipelineHash = 'volfsq';\n    for (let vidx = 0; vidx < model.volumes.length; vidx++) {\n      const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();\n      model.pipelineHash += `${blendMode}`;\n    }\n  };\n\n  // marks modified when needed\n  publicAPI.setVolumes = val => {\n    if (!model.volumes || model.volumes.length !== val.length) {\n      model.volumes = [...val];\n      publicAPI.modified();\n      return;\n    }\n    for (let i = 0; i < val.length; i++) {\n      if (val[i] !== model.volumes[i]) {\n        model.volumes = [...val];\n        publicAPI.modified();\n        return;\n      }\n    }\n  };\n  const superclassGetBindables = publicAPI.getBindables;\n  publicAPI.getBindables = () => {\n    const bindables = superclassGetBindables();\n    bindables.push(model.componentSSBO);\n    bindables.push(model.clampSampler);\n    return bindables;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  volumes: null,\n  rowLength: 1024,\n  lastVolumeLength: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUFullScreenQuad.extend(publicAPI, model, initialValues);\n  model.fragmentShaderTemplate = volFragTemplate;\n  model.UBO = vtkWebGPUUniformBuffer.newInstance({\n    label: 'mapperUBO'\n  });\n  model.UBO.addEntry('SampleDistance', 'f32');\n  model.SSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'volumeSSBO'\n  });\n  model.componentSSBO = vtkWebGPUStorageBuffer.newInstance({\n    label: 'componentSSBO'\n  });\n  model.lutBuildTime = {};\n  macro.obj(model.lutBuildTime, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkWebGPUVolumePassFSQ(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUVolumePassFSQ');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUVolumePassFSQ$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUVolumePassFSQ$1 as default, extend, newInstance };\n"],"mappings":";;;;;;;AAAA,SAASA,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AAC7C,SAASC,IAAI,QAAQ,WAAW;AAChC,OAAOC,uBAAuB,MAAM,qBAAqB;AACzD,OAAOC,sBAAsB,MAAM,oBAAoB;AACvD,OAAOC,oBAAoB,MAAM,kBAAkB;AACnD,OAAOC,sBAAsB,MAAM,oBAAoB;AACvD,OAAOC,gBAAgB,MAAM,cAAc;AAC3C,OAAOC,cAAc,MAAM,YAAY;AACvC,SAASC,SAAS,QAAQ,mCAAmC;AAE7D,MAAMC,eAAe,GAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,MAAMC,OAAO,GAAG,IAAIC,YAAY,CAAC,EAAE,CAAC;AACpC,MAAMC,QAAQ,GAAG,IAAID,YAAY,CAAC,EAAE,CAAC;;AAErC;AACA;AACA;;AAEA,SAASE,sBAAsBA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAChD;EACAA,KAAK,CAACC,cAAc,CAACC,IAAI,CAAC,wBAAwB,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}