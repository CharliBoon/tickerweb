{"ast":null,"code":"import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  ref: \"vtkContainer\"\n};\nconst _hoisted_2 = {\n  class: \"controls\"\n};\nconst _hoisted_3 = [\"value\"];\nconst _hoisted_4 = [\"min\", \"max\", \"value\"];\nconst _hoisted_5 = [\"value\"];\nconst _hoisted_6 = [\"value\"];\nconst _hoisted_7 = [\"value\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", null, [_createElementVNode(\"div\", _hoisted_1, null, 512 /* NEED_PATCH */), _createElementVNode(\"table\", _hoisted_2, [_createElementVNode(\"tbody\", null, [_cache[12] || (_cache[12] = _createElementVNode(\"tr\", null, [_createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  }, [_createElementVNode(\"b\", null, \"Nodes\")]), _createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  })], -1 /* HOISTED */)), _createElementVNode(\"tr\", null, [_cache[6] || (_cache[6] = _createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  }, \"Representation\", -1 /* HOISTED */)), _createElementVNode(\"td\", null, [_createElementVNode(\"select\", {\n    style: {\n      \"width\": \"100%\"\n    },\n    value: $setup.node_representation,\n    onChange: _cache[0] || (_cache[0] = $event => $setup.setNodeRepresentation($event.target.value))\n  }, _cache[5] || (_cache[5] = [_createElementVNode(\"option\", {\n    value: \"0\"\n  }, \"Unscaled\", -1 /* HOISTED */), _createElementVNode(\"option\", {\n    value: \"1\"\n  }, \"Scaled\", -1 /* HOISTED */)]), 40 /* PROPS, NEED_HYDRATION */, _hoisted_3)])]), _cache[13] || (_cache[13] = _createElementVNode(\"tr\", null, [_createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  }, [_createElementVNode(\"b\", null, \"Events\")]), _createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  })], -1 /* HOISTED */)), _createElementVNode(\"tr\", null, [_cache[7] || (_cache[7] = _createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  }, \"TimeStamp\", -1 /* HOISTED */)), _createElementVNode(\"td\", null, [_createElementVNode(\"input\", {\n    type: \"range\",\n    min: $setup.events_timestamp_min,\n    max: $setup.events_timestamp_max,\n    value: $setup.events_timestamp,\n    onInput: _cache[1] || (_cache[1] = $event => $setup.setEventTimeStamp($event.target.value))\n  }, null, 40 /* PROPS, NEED_HYDRATION */, _hoisted_4)])]), _createElementVNode(\"tr\", null, [_cache[8] || (_cache[8] = _createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  }, \"Opacity\", -1 /* HOISTED */)), _createElementVNode(\"td\", null, [_createElementVNode(\"input\", {\n    type: \"range\",\n    min: \"0\",\n    max: \"100\",\n    value: $setup.events_opacity,\n    onInput: _cache[2] || (_cache[2] = $event => $setup.setEventOpacity($event.target.value))\n  }, null, 40 /* PROPS, NEED_HYDRATION */, _hoisted_5)])]), _cache[14] || (_cache[14] = _createElementVNode(\"tr\", null, [_createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  }, [_createElementVNode(\"b\", null, \"Plan\")]), _createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  })], -1 /* HOISTED */)), _createElementVNode(\"tr\", null, [_cache[9] || (_cache[9] = _createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  }, \"Opacity\", -1 /* HOISTED */)), _createElementVNode(\"td\", null, [_createElementVNode(\"input\", {\n    type: \"range\",\n    min: \"0\",\n    max: \"100\",\n    value: $setup.plan_opacity,\n    onInput: _cache[3] || (_cache[3] = $event => $setup.setPlanOpacity($event.target.value))\n  }, null, 40 /* PROPS, NEED_HYDRATION */, _hoisted_6)])]), _createElementVNode(\"tr\", null, [_cache[11] || (_cache[11] = _createElementVNode(\"td\", {\n    style: {\n      \"text-align\": \"left\"\n    }\n  }, \"Representation\", -1 /* HOISTED */)), _createElementVNode(\"td\", null, [_createElementVNode(\"select\", {\n    style: {\n      \"width\": \"100%\"\n    },\n    value: $setup.plan_representation,\n    onChange: _cache[4] || (_cache[4] = $event => $setup.setPlanRepresentation($event.target.value))\n  }, _cache[10] || (_cache[10] = [_createElementVNode(\"option\", {\n    value: \"0\"\n  }, \"Points\", -1 /* HOISTED */), _createElementVNode(\"option\", {\n    value: \"1\"\n  }, \"Wireframe\", -1 /* HOISTED */)]), 40 /* PROPS, NEED_HYDRATION */, _hoisted_7)])])])])]);\n}","map":{"version":3,"names":["ref","class","_createElementBlock","_createElementVNode","_hoisted_1","_hoisted_2","style","value","$setup","node_representation","onChange","_cache","$event","setNodeRepresentation","target","_hoisted_3","type","min","events_timestamp_min","max","events_timestamp_max","events_timestamp","onInput","setEventTimeStamp","_hoisted_4","events_opacity","setEventOpacity","_hoisted_5","plan_opacity","setPlanOpacity","_hoisted_6","plan_representation","setPlanRepresentation","_hoisted_7"],"sources":["C:\\Users\\Malcolm\\Projects\\Web\\TickerWeb\\TickerWeb_Vue\\src\\components\\TickerVTK.vue"],"sourcesContent":["<template>\n  <div>\n    <div ref=\"vtkContainer\" />\n    <table class=\"controls\">\n      <tbody>\n        <tr>\n          <td style=\"text-align:left\"><b>Nodes</b></td>\n          <td style=\"text-align:left\"> </td>\n        </tr>\n\t\t<tr>\n          <td style=\"text-align:left\">Representation</td>\n          <td>\n            <select\n              style=\"width: 100%\"\n              :value=\"node_representation\"\n              @change=\"setNodeRepresentation($event.target.value)\"\n            >\n              <option value=\"0\">Unscaled</option>\n              <option value=\"1\">Scaled</option>\n            </select>\n          </td>\n        </tr>\n        <tr>\n          <td style=\"text-align:left\"><b>Events</b></td>\n          <td style=\"text-align:left\"> </td>\n        </tr>\n        <tr>\n          <td style=\"text-align:left\">TimeStamp</td>\n          <td>\n            <input\n              type=\"range\"\n              :min=\"events_timestamp_min\"\n              :max=\"events_timestamp_max\"\n              :value=\"events_timestamp\"\n              @input=\"setEventTimeStamp($event.target.value)\"\n            />\n          </td>\n        </tr>\n\t\t<tr>\n          <td style=\"text-align:left\">Opacity</td>\n          <td>\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"100\"\n              :value=\"events_opacity\"\n              @input=\"setEventOpacity($event.target.value)\"\n            />\n          </td>\n        </tr>\t\t\n        <tr>\n          <td style=\"text-align:left\"><b>Plan</b></td>\n          <td style=\"text-align:left\"> </td>\n        </tr>\n\t\t<tr>\n          <td style=\"text-align:left\">Opacity</td>\n          <td>\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"100\"\n              :value=\"plan_opacity\"\n              @input=\"setPlanOpacity($event.target.value)\"\n            />\n          </td>\n        </tr>\n\t\t<tr>\n          <td style=\"text-align:left\">Representation</td>\n          <td>\n            <select\n              style=\"width: 100%\"\n              :value=\"plan_representation\"\n              @change=\"setPlanRepresentation($event.target.value)\"\n            >\n              <option value=\"0\">Points</option>\n              <option value=\"1\">Wireframe</option>\n            </select>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</template>\n\n<script>\nimport axios from 'axios';\nimport { ref, unref, onMounted, onBeforeUnmount, watchEffect, watch } from 'vue';\n// vtk\nimport '@kitware/vtk.js/Rendering/Profiles/Geometry'; // geometry rendering for WebGL, WebGPU\nimport '@kitware/vtk.js/Rendering/Profiles/Glyph';    // vtkGlyph3DMapper\nimport '@kitware/vtk.js/Rendering/Profiles/Molecule'; // vtkSphereMapper\nimport vtkFullScreenRenderWindow from '@kitware/vtk.js/Rendering/Misc/FullScreenRenderWindow';\nimport vtkActor                  from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper                 from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader      from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkXMLImageDataReader     from '@kitware/vtk.js/IO/XML/XMLImageDataReader';\nimport vtkGlyph3DMapper          from '@kitware/vtk.js/Rendering/Core/Glyph3DMapper'; \nimport vtkCubeSource             from '@kitware/vtk.js/Filters/Sources/CubeSource';\nimport vtkSphereMapper           from '@kitware/vtk.js/Rendering/Core/SphereMapper';\n//\nimport vtkPolyData               from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkPoints                 from '@kitware/vtk.js/Common/Core/Points';\nimport vtkCellArray              from '@kitware/vtk.js/Common/Core/CellArray'\nimport vtkLookupTable            from '@kitware/vtk.js/Common/Core/LookupTable';\nimport vtkDataArray              from '@kitware/vtk.js/Common/Core/DataArray';\n\nexport default {\n\n  setup() {\n  \n    const session = {user: 'malcolm', mine:'Bambanani'}\n    let nodes = {'data':[], 'meta':{}} // node data - response getNodes - for table, polydata\n    let events = {'data':[], 'meta':{}} // event data - response getEvents - for table, polydata\n\t\n\tlet bounds = new Array(6).fill(0.0)\n\t\n\tconst vtkContainer = ref(null);\n    const context = ref(null);\n\n    const node_representation  = ref(0);    \n\tconst events_opacity       = ref(50);\n    const events_timestamp     = ref(0);\n    const events_timestamp_min = ref(0);\n    const events_timestamp_max = ref(0);\n\tconst plan_opacity         = ref(100);\n    const plan_representation  = ref(1);\n\t\n    const textEncoder = new TextEncoder();\n    //const path = 'http://localhost:5000';\n\tconst path = 'http://192.168.0.2:5000';\n    \n\t// nodes\n\tconst node_lut = vtkLookupTable.newInstance(); // make custom LUT\n    const data = new Uint8Array([0, 255, 0, 255, 255, 165, 80, 255, 255, 0, 0, 255]); // RGBA: green, orange, red\n    const table = vtkDataArray.newInstance({values: data, numberOfComponents: 4}); // to VTK\n    node_lut.setTable(table); // LUT = green, orange, red\n\n\tconst node_glyph = vtkCubeSource.newInstance();\n\tconst node_mapper = vtkGlyph3DMapper.newInstance();\n\tconst node_actor = vtkActor.newInstance();\n\t//\n\tnode_mapper.setScalarModeToUsePointData()\n\tnode_mapper.setScalarVisibility(true)\n\tnode_mapper.setScalarRange(1, 3)\n    node_mapper.setLookupTable(node_lut)\n\tnode_mapper.setScaleFactor(10.0)\n    node_actor.setMapper(node_mapper)\n\t//node_actor.getProperty().setAmbient(0.5)\n\t\n\t// plan\n\tconst plan_reader = vtkXMLPolyDataReader.newInstance();\n\tconst plan_mapper = vtkMapper.newInstance();\n\tconst plan_actor  = vtkActor.newInstance();\n\t//\n\tplan_mapper.setInputConnection(plan_reader.getOutputPort());\n\tplan_actor.setMapper(plan_mapper)\n\tplan_actor.getProperty().setOpacity(0.25)\n\tplan_actor.getProperty().setColor(0.5, 0.5, 0.5)\n\t\n\t// volume\n\tconst volume_reader = vtkXMLImageDataReader.newInstance();\n\tconst volume_mapper = vtkMapper.newInstance();\n\tconst volume_actor  = vtkActor.newInstance();\n\t//\n\tvolume_mapper.setInputConnection(volume_reader.getOutputPort());\n\tvolume_actor.setMapper(volume_mapper)\n\tvolume_actor.getProperty().setOpacity(0.25)\n\tvolume_actor.getProperty().setColor(0.5, 0.5, 0.5)\n\t\n\t// events\n\tconst events_reader = vtkXMLPolyDataReader.newInstance();\n    const events_mapper = vtkSphereMapper.newInstance();\n\tconst events_actor  = vtkActor.newInstance();\n\t//\n\tevents_mapper.setInputConnection(events_reader.getOutputPort())\n\tevents_mapper.setScaleFactor(100.0);\n    events_mapper.setScaleArray('scale');\n\tevents_mapper.setScalarVisibility(true);\n\tevents_mapper.setScalarModeToUsePointData()\n\tevents_actor.setMapper(events_mapper)\n\tevents_actor.getProperty().setOpacity(0.5)\n\t\n    function setNodeRepresentation(rep) {\n      node_representation.value = Number(rep);\n    }\n\n\tfunction setEventOpacity(opacity) {\n      events_opacity.value = Number(opacity);\n    }\n\t\n    function setEventTimeStamp(res) {\n      events_timestamp.value = Number(res);\n    }\n\t\n\tfunction setPlanOpacity(opacity) {\n      plan_opacity.value = Number(opacity);\n    }\n\n    function setPlanRepresentation(rep) {\n      plan_representation.value = Number(rep);\n    }\n\t\n\t\n    async function onEventFilter(timestamp) {\n      const {renderWindow} = context.value\n      filterEventData(timestamp)\n      renderWindow.render()\n\t}\n\t\n\t// provide data to vtk pipelines ------------------------------------------\n\t\n\t// nodes\n\t\n\tfunction getNodes(args={}) {\n      return new Promise((resolve, reject) => {\n        axios.put(path+'/nodes', args)\n          .then((response_get) => {\n\t\t\tnodes = response_get.data\n            const pd = newPolyDataFromNodes(nodes)\n\t\t\tnode_mapper.setInputData(pd,0)\n\t\t\tnode_mapper.setInputData(node_glyph.getOutputData(),1)\n            resolve('nodes_data')\n          })\n          .catch((error) => {\n            reject(error)\n        })\n      })\n    }\n\t\n\tfunction newPolyDataFromNodes(nodes) {\n      const nodes_data = nodes['data']\n      const points = vtkPoints.newInstance()\n      points.setNumberOfPoints(nodes_data.length)\n      const arr_alerts = new Float32Array(nodes_data.length)\n      const arr_verts = []\n      \n      nodes_data.forEach((node, index) => {\n        arr_alerts[index] = node.alert\n        arr_verts.push(1,index)\n        points.setPoint(index, node.x, node.y, node.z);\n      })\n      const alerts = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: arr_alerts,\n        name: 'alerts',\n      })\n      const verts = vtkCellArray.newInstance({values: Uint16Array.from(arr_verts)})\n      const pd = vtkPolyData.newInstance()\n      pd.setPoints(points)\n      pd.setVerts(verts)\n      pd.getPointData().setScalars(alerts)\n      return pd\n    }\n\t\n\t// plan\n\t\n\tfunction getPlan(args={}) {\n      return new Promise((resolve, reject) => {\n        axios.put(path+'/plan_vtk', args)\n          .then((response_get) => {\n            plan_reader.parseAsArrayBuffer(textEncoder.encode(response_get.data))\t\t  \n            resolve('plan')\n          })\n          .catch((error) => {\n            reject(error)\n        })\n      })\n    }\n\t\n\t// volume\n\t\n\tfunction getVolume(args={}) {\n      return new Promise((resolve, reject) => {\n        axios.put(path+'/volume_vtk', args)\n          .then((response_get) => {\n            volume_reader.parseAsArrayBuffer(textEncoder.encode(response_get.data))\t\t  \n            console.log(volume_reader.GetOutput())\n            resolve('volume')\n          })\n          .catch((error) => {\n            reject(error)\n        })\n      })\n    }\n\t\n\t// events\n\t\n\tfunction getEvents(args={}) {\n      return new Promise((resolve, reject) => {\n        axios.put(path+'/events', args)\n          .then((response_get) => {\n\t\t\tevents = response_get.data\n            const pd = newPolyDataFromEvents(events)\n\t\t\tevents_mapper.setInputData(pd)\n            resolve('events_data')\n          })\n          .catch((error) => {\n            reject(error)\n        })\n      })\n    }\n\t\n\tfunction filterEventData(timestamp) {\n      const events_data = events.data.filter((event) => {\n        return event.timestamp > timestamp\n        }\n      )\n      const pd = newPolyDataFromEvents({'meta':events.meta, 'data':events_data})\n      events_mapper.setInputData(pd)\n    }\n\t\n\tfunction newPolyDataFromEvents(events) {\n      const events_data = events.data\n      const points = vtkPoints.newInstance()\n      points.setNumberOfPoints(events_data.length)\n      const arr_mags = new Float32Array(events_data.length)\n      const arr_timestamp = new Float32Array(events_data.length)\n      const arr_scale = new Float32Array(events_data.length)\n      const arr_verts = []\n      \n      const offset = 1.0\n      const min_mag = events['meta'].min_mag\n      const max_mag = events['meta'].max_mag\n      \n      events_data.forEach((event_data, index) => {\n        arr_mags[index] = event_data.mag\n        arr_scale[index] = (offset - min_mag + event_data.mag)/(offset - min_mag + max_mag)\n        arr_timestamp[index] = event_data.timestamp\n        arr_verts.push(1,index)\n        points.setPoint(index, event_data.x, event_data.y, event_data.z);\n      })\n      const mags = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: arr_mags,\n        name: 'mags',\n      })\n      const scale = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: arr_scale,\n        name: 'scale',\n      })\n      const timestamp = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: arr_timestamp,\n        name: 'timestamp',\n      })\n      const verts = vtkCellArray.newInstance({values: Uint16Array.from(arr_verts)})\n      const pd = vtkPolyData.newInstance()\n      pd.setPoints(points)\n      pd.setVerts(verts)\n      pd.getPointData().addArray(mags)\n      pd.getPointData().addArray(scale)\n      pd.getPointData().addArray(timestamp)\n      pd.getPointData().setActiveAttributeByName('timestamp', 0) // scalars\n      return pd   \t\n    }\n\t\n\t// all --------------------------------------------------------------------\n\t\n    async function getAllAndRender() {\n      const {renderWindow, renderer} = context.value\n      await getNodes({mine: session.mine})\n      bounds = node_mapper.getInputData().getBounds()\n      //await getNodes({mine: session.mine})\n      //bounds = node_reader.getOutputData().getBounds()\n      const buffer = 1000.0\n      bounds[0] -= buffer\n      bounds[1] += buffer\n      bounds[2] -= buffer\n      bounds[3] += buffer\n      bounds[4] -= buffer\n      bounds[5] += buffer\n      //\n      Promise.allSettled([getPlan({bounds: bounds, mine: session.mine}), getEvents({bounds: bounds, mine: session.mine, timestamp: 0.0}), getVolume({mine: session.mine})]).then(() => {\n        const range = events_mapper.getInputData().getPointData().getScalars().getRange()\n        events_timestamp_min.value = range[0]\n        events_timestamp_max.value = range[1]\n\t\tevents_timestamp.value = range[0]\n\t\tevents_mapper.setScalarRange(range)\n\t\trenderer.resetCamera()\n        renderWindow.render()\n      })\n\t}\n\t\n    function checkModified(){\n      return new Promise((resolve, reject) => {\n        axios.put(path+'/modified', {mine: session.mine})\n          .then((response_get) => {\n            console.log(response_get.data)\t\t  \n            resolve('plan')\n          })\n          .catch((error) => {\n            reject(error)\n        })\n      })\n    }\n\t\n\twatch(events_timestamp, (newValue) => {\n      onEventFilter(newValue)\n\t})\n\n    watchEffect(() => {\n      if (context.value) {\n        const {renderWindow } = context.value;\n\t\tconsole.log(unref(node_representation))\n\t\tnode_mapper.setScaleMode(unref(node_representation));\n\t\tnode_mapper.update()\n\t\tplan_actor.getProperty().setOpacity(unref(plan_opacity)*0.01);\n        plan_actor.getProperty().setRepresentation(unref(plan_representation))\n\t\tevents_actor.getProperty().setOpacity(unref(events_opacity)*0.01)\n\t\trenderWindow.render();\n      }\n    });\n\t\n    onMounted(() => {\n      console.log('onMounted')\n\t\n      if (!context.value) {\n        \n\t\tconst fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n          rootContainer: vtkContainer.value,\n          });\n         \n        const renderer = fullScreenRenderer.getRenderer()\n        const renderWindow = fullScreenRenderer.getRenderWindow()\n\t\t//\n        renderer.setBackground(1.0, 1.0, 1.0)\n\t\trenderer.setUseDepthPeeling(true) // depth peeling\n        renderer.setMaximumNumberOfPeels(100) // depth peeling\n        renderer.setOcclusionRatio(0.01) // depth peeling\n\t\t//\n\t\trenderer.addActor(node_actor)\n\t\trenderer.addActor(plan_actor)\n\t\trenderer.addActor(events_actor)\n\t\trenderer.addActor(volume_actor)\n\t\t\n\t\tcontext.value = {\n          fullScreenRenderer,\n          renderWindow,\n          renderer,\n          //\n          node_actor,\n          node_mapper,\n          node_glyph,\n          //\n          events_actor,\n          events_mapper,\n          //\n          plan_reader,\n          plan_mapper,\n          plan_actor,\n          //\n          volume_reader,\n          volume_mapper,\n          volume_actor,\n        };\n\t\t\n\t\t// render all and start monitoring for changes to incoming datasets\n\t\tgetAllAndRender()\n        setInterval(checkModified, 30000)\n      }\n    });\n\t\n\n\tonBeforeUnmount(() => {\n      if (context.value) {\n        const { renderer, renderWindow, fullScreenRenderer, node_actor, node_mapper, node_glyph, plan_reader, plan_actor, plan_mapper, events_actor, events_mapper} = context.value;\n        plan_actor.delete();\n        plan_mapper.delete();\n        plan_reader.delete();\n\t\tnode_actor.delete();\n        node_mapper.delete();\n\t\tnode_glyph.delete();\n        events_actor.delete();\n        events_mapper.delete();\n        //\n\t\trenderer.delete()\n\t\trenderWindow.delete()\n        //\n        fullScreenRenderer.delete();\n        context.value = null;\n      }\n    });\n\n    return {\n      vtkContainer,\n      setNodeRepresentation,\n      setEventOpacity,\n      setEventTimeStamp,\n      setPlanOpacity,\n      setPlanRepresentation,\n      plan_opacity,\n      plan_representation,\n      events_timestamp,\n      events_timestamp_min,\n      events_timestamp_max,\n      events_opacity,\n      node_representation,\n    };\n  }\n}\n</script>\n\n<style scoped>\n.controls {\n  position: absolute;\n  top: 25px;\n  left: 25px;\n  background: white;\n  padding: 12px;\n}\n</style>\n"],"mappings":";;EAESA,GAAG,EAAC;AAAc;;EAChBC,KAAK,EAAC;AAAU;mBAH3B;mBAAA;mBAAA;mBAAA;mBAAA;;uBACEC,mBAAA,CAgFM,cA/EJC,mBAAA,CAA0B,OAA1BC,UAA0B,+BAC1BD,mBAAA,CA6EQ,SA7ERE,UA6EQ,GA5ENF,mBAAA,CA2EQ,gB,4BA1ENA,mBAAA,CAGK,aAFHA,mBAAA,CAA6C;IAAzCG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,IAACH,mBAAA,CAAY,WAAT,OAAK,E,GACpCA,mBAAA,CAAkC;IAA9BG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,G,sBAEnCH,mBAAA,CAYW,a,0BAXHA,mBAAA,CAA+C;IAA3CG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,GAAC,gBAAc,sBAC1CH,mBAAA,CASK,aARHA,mBAAA,CAOS;IANPG,KAAmB,EAAnB;MAAA;IAAA,CAAmB;IAClBC,KAAK,EAAEC,MAAA,CAAAC,mBAAmB;IAC1BC,QAAM,EAAAC,MAAA,QAAAA,MAAA,MAAAC,MAAA,IAAEJ,MAAA,CAAAK,qBAAqB,CAACD,MAAM,CAACE,MAAM,CAACP,KAAK;gCAElDJ,mBAAA,CAAmC;IAA3BI,KAAK,EAAC;EAAG,GAAC,UAAQ,qBAC1BJ,mBAAA,CAAiC;IAAzBI,KAAK,EAAC;EAAG,GAAC,QAAM,oB,mCAlBtCQ,UAAA,E,iCAsBQZ,mBAAA,CAGK,aAFHA,mBAAA,CAA8C;IAA1CG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,IAACH,mBAAA,CAAa,WAAV,QAAM,E,GACrCA,mBAAA,CAAkC;IAA9BG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,G,sBAE7BH,mBAAA,CAWK,a,0BAVHA,mBAAA,CAA0C;IAAtCG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,GAAC,WAAS,sBACrCH,mBAAA,CAQK,aAPHA,mBAAA,CAME;IALAa,IAAI,EAAC,OAAO;IACXC,GAAG,EAAET,MAAA,CAAAU,oBAAoB;IACzBC,GAAG,EAAEX,MAAA,CAAAY,oBAAoB;IACzBb,KAAK,EAAEC,MAAA,CAAAa,gBAAgB;IACvBC,OAAK,EAAAX,MAAA,QAAAA,MAAA,MAAAC,MAAA,IAAEJ,MAAA,CAAAe,iBAAiB,CAACX,MAAM,CAACE,MAAM,CAACP,KAAK;2CAlC3DiB,UAAA,E,KAsCErB,mBAAA,CAWW,a,0BAVHA,mBAAA,CAAwC;IAApCG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,GAAC,SAAO,sBACnCH,mBAAA,CAQK,aAPHA,mBAAA,CAME;IALAa,IAAI,EAAC,OAAO;IACZC,GAAG,EAAC,GAAG;IACPE,GAAG,EAAC,KAAK;IACRZ,KAAK,EAAEC,MAAA,CAAAiB,cAAc;IACrBH,OAAK,EAAAX,MAAA,QAAAA,MAAA,MAAAC,MAAA,IAAEJ,MAAA,CAAAkB,eAAe,CAACd,MAAM,CAACE,MAAM,CAACP,KAAK;2CA9CzDoB,UAAA,E,iCAkDQxB,mBAAA,CAGK,aAFHA,mBAAA,CAA4C;IAAxCG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,IAACH,mBAAA,CAAW,WAAR,MAAI,E,GACnCA,mBAAA,CAAkC;IAA9BG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,G,sBAEnCH,mBAAA,CAWW,a,0BAVHA,mBAAA,CAAwC;IAApCG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,GAAC,SAAO,sBACnCH,mBAAA,CAQK,aAPHA,mBAAA,CAME;IALAa,IAAI,EAAC,OAAO;IACZC,GAAG,EAAC,GAAG;IACPE,GAAG,EAAC,KAAK;IACRZ,KAAK,EAAEC,MAAA,CAAAoB,YAAY;IACnBN,OAAK,EAAAX,MAAA,QAAAA,MAAA,MAAAC,MAAA,IAAEJ,MAAA,CAAAqB,cAAc,CAACjB,MAAM,CAACE,MAAM,CAACP,KAAK;2CA9DxDuB,UAAA,E,KAkEE3B,mBAAA,CAYW,a,4BAXHA,mBAAA,CAA+C;IAA3CG,KAAuB,EAAvB;MAAA;IAAA;EAAuB,GAAC,gBAAc,sBAC1CH,mBAAA,CASK,aARHA,mBAAA,CAOS;IANPG,KAAmB,EAAnB;MAAA;IAAA,CAAmB;IAClBC,KAAK,EAAEC,MAAA,CAAAuB,mBAAmB;IAC1BrB,QAAM,EAAAC,MAAA,QAAAA,MAAA,MAAAC,MAAA,IAAEJ,MAAA,CAAAwB,qBAAqB,CAACpB,MAAM,CAACE,MAAM,CAACP,KAAK;kCAElDJ,mBAAA,CAAiC;IAAzBI,KAAK,EAAC;EAAG,GAAC,QAAM,qBACxBJ,mBAAA,CAAoC;IAA5BI,KAAK,EAAC;EAAG,GAAC,WAAS,oB,mCA3EzC0B,UAAA,E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}