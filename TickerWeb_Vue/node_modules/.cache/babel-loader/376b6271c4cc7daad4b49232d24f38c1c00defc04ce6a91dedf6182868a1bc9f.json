{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeGestureManipulator from './CompositeGestureManipulator.js';\nimport vtkInteractorStyleManipulator from '../Style/InteractorStyleManipulator.js';\n\n// ----------------------------------------------------------------------------\n// vtkGestureCameraManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkGestureCameraManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkGestureCameraManipulator');\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onStartPinch = (interactor, scale) => {\n    model.previousScale = scale;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onStartRotate = (interactor, rotation) => {\n    model.previousRotation = rotation;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onStartPan = (interactor, translation) => {\n    model.previousTranslation = translation;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onPinch = (interactor, renderer, scale) => {\n    vtkInteractorStyleManipulator.dollyByFactor(interactor, renderer, scale / model.previousScale);\n    model.previousScale = scale;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onPan = (interactor, renderer, translation) => {\n    const camera = renderer.getActiveCamera();\n    const style = interactor.getInteractorStyle();\n\n    // Calculate the focal depth since we'll be using it a lot\n    let viewFocus = camera.getFocalPoint();\n    viewFocus = style.computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);\n    const focalDepth = viewFocus[2];\n    const trans = translation;\n    const lastTrans = model.previousTranslation;\n    const newPickPoint = style.computeDisplayToWorld(renderer, viewFocus[0] + trans[0] - lastTrans[0], viewFocus[1] + trans[1] - lastTrans[1], focalDepth);\n\n    // Has to recalc old mouse point since the viewport has moved,\n    // so can't move it outside the loop\n    const oldPickPoint = style.computeDisplayToWorld(renderer, viewFocus[0], viewFocus[1], focalDepth);\n\n    // Camera motion is reversed\n    const motionVector = [];\n    motionVector[0] = oldPickPoint[0] - newPickPoint[0];\n    motionVector[1] = oldPickPoint[1] - newPickPoint[1];\n    motionVector[2] = oldPickPoint[2] - newPickPoint[2];\n    viewFocus = camera.getFocalPoint();\n    const viewPoint = camera.getPosition();\n    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);\n    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);\n    if (interactor.getLightFollowCamera()) {\n      renderer.updateLightsGeometryToFollowCamera();\n    }\n    camera.orthogonalizeViewUp();\n    model.previousTranslation = translation;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onRotate = (interactor, renderer, rotation) => {\n    const camera = renderer.getActiveCamera();\n    camera.roll(rotation - model.previousRotation);\n    camera.orthogonalizeViewUp();\n    model.previousRotation = rotation;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeGestureManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n\n  // Object specific methods\n  vtkGestureCameraManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkGestureCameraManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkGestureCameraManipulator$1 = {\n  newInstance,\n  extend\n};\nexport { vtkGestureCameraManipulator$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkCompositeCameraManipulator","vtkCompositeGestureManipulator","vtkInteractorStyleManipulator","vtkGestureCameraManipulator","publicAPI","model","classHierarchy","push","onStartPinch","interactor","scale","previousScale","onStartRotate","rotation","previousRotation","onStartPan","translation","previousTranslation","onPinch","renderer","dollyByFactor","onPan","camera","getActiveCamera","style","getInteractorStyle","viewFocus","getFocalPoint","computeWorldToDisplay","focalDepth","trans","lastTrans","newPickPoint","computeDisplayToWorld","oldPickPoint","motionVector","viewPoint","getPosition","setFocalPoint","setPosition","getLightFollowCamera","updateLightsGeometryToFollowCamera","orthogonalizeViewUp","onRotate","roll","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","obj","newInstance","vtkGestureCameraManipulator$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Interaction/Manipulators/GestureCameraManipulator.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeGestureManipulator from './CompositeGestureManipulator.js';\nimport vtkInteractorStyleManipulator from '../Style/InteractorStyleManipulator.js';\n\n// ----------------------------------------------------------------------------\n// vtkGestureCameraManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkGestureCameraManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkGestureCameraManipulator');\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onStartPinch = (interactor, scale) => {\n    model.previousScale = scale;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onStartRotate = (interactor, rotation) => {\n    model.previousRotation = rotation;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onStartPan = (interactor, translation) => {\n    model.previousTranslation = translation;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onPinch = (interactor, renderer, scale) => {\n    vtkInteractorStyleManipulator.dollyByFactor(interactor, renderer, scale / model.previousScale);\n    model.previousScale = scale;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onPan = (interactor, renderer, translation) => {\n    const camera = renderer.getActiveCamera();\n    const style = interactor.getInteractorStyle();\n\n    // Calculate the focal depth since we'll be using it a lot\n    let viewFocus = camera.getFocalPoint();\n    viewFocus = style.computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);\n    const focalDepth = viewFocus[2];\n    const trans = translation;\n    const lastTrans = model.previousTranslation;\n    const newPickPoint = style.computeDisplayToWorld(renderer, viewFocus[0] + trans[0] - lastTrans[0], viewFocus[1] + trans[1] - lastTrans[1], focalDepth);\n\n    // Has to recalc old mouse point since the viewport has moved,\n    // so can't move it outside the loop\n    const oldPickPoint = style.computeDisplayToWorld(renderer, viewFocus[0], viewFocus[1], focalDepth);\n\n    // Camera motion is reversed\n    const motionVector = [];\n    motionVector[0] = oldPickPoint[0] - newPickPoint[0];\n    motionVector[1] = oldPickPoint[1] - newPickPoint[1];\n    motionVector[2] = oldPickPoint[2] - newPickPoint[2];\n    viewFocus = camera.getFocalPoint();\n    const viewPoint = camera.getPosition();\n    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);\n    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);\n    if (interactor.getLightFollowCamera()) {\n      renderer.updateLightsGeometryToFollowCamera();\n    }\n    camera.orthogonalizeViewUp();\n    model.previousTranslation = translation;\n  };\n\n  //---------------------------------------------------------------------------\n\n  publicAPI.onRotate = (interactor, renderer, rotation) => {\n    const camera = renderer.getActiveCamera();\n    camera.roll(rotation - model.previousRotation);\n    camera.orthogonalizeViewUp();\n    model.previousRotation = rotation;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeGestureManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n\n  // Object specific methods\n  vtkGestureCameraManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkGestureCameraManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkGestureCameraManipulator$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkGestureCameraManipulator$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}