{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport { d as dot } from '../../Common/Core/Math/index.js';\nimport vtkPicker from './Picker.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPointPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPointPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPointPicker');\n  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {\n    let tMin = Number.MAX_VALUE;\n    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {\n      const pickData = mapper.intersectWithLineForPointPicking(p1, p2);\n      if (pickData) {\n        tMin = pickData.t;\n        model.pointIJK = pickData.ijk;\n      }\n    } else if (mapper.isA('vtkMapper')) {\n      tMin = model.intersectActorWithLine(p1, p2, tolerance, mapper);\n    }\n    return tMin;\n  };\n  model.intersectActorWithLine = (p1, p2, tolerance, mapper) => {\n    // Get dataset\n    const input = mapper.getInputData();\n\n    // Determine appropriate info\n    let ptId = 0;\n    const numPts = input.getPoints().getNumberOfPoints();\n    if (numPts <= ptId) {\n      return 2.0;\n    }\n    const ray = [];\n    for (let i = 0; i < 3; i++) {\n      ray[i] = p2[i] - p1[i];\n    }\n    const rayFactor = dot(ray, ray);\n    if (rayFactor === 0.0) {\n      vtkErrorMacro('Cannot process points');\n      return 2.0;\n    }\n    let t;\n    let minPtId = -1;\n    let tMin = Number.MAX_VALUE;\n    let minPtDist = Number.MAX_VALUE;\n    const projXYZ = [];\n    const x = [];\n    const points = input.getPoints();\n    if (model.useCells) {\n      const cellData = input.getPolys().getData();\n      const nbPointsPerCell = cellData[0];\n      const nbCells = input.getPolys().getNumberOfCells();\n      for (let cellID = 0; cellID < nbCells; cellID++) {\n        const firstPointIndex = cellID * nbPointsPerCell + 1;\n        const lastPointIndex = firstPointIndex + nbPointsPerCell;\n        for (let pointIndex = firstPointIndex; pointIndex < lastPointIndex; pointIndex++) {\n          const pointDataIndex = cellData[pointIndex];\n          points.getPoint(pointDataIndex, x);\n          t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor;\n\n          // If we find a point closer than we currently have, see whether it\n          // lies within the pick tolerance and clipping planes. We keep track\n          // of the point closest to the line (use a fudge factor for points\n          // nearly the same distance away.)\n          if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {\n            let maxDist = 0.0;\n            for (let i = 0; i < 3; i++) {\n              projXYZ[i] = p1[i] + t * ray[i];\n              const dist = Math.abs(x[i] - projXYZ[i]);\n              if (dist > maxDist) {\n                maxDist = dist;\n              }\n            } // end for i\n            if (maxDist <= tolerance && maxDist < minPtDist) {\n              // within tolerance\n              minPtId = ptId;\n              minPtDist = maxDist;\n              tMin = t;\n            }\n          }\n        } // end for pointIndex\n      } // end for cellID\n    } else {\n      // end if model.useCells\n      for (ptId = 0; ptId < numPts; ptId++) {\n        points.getPoint(ptId, x);\n        t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor;\n\n        // If we find a point closer than we currently have, see whether it\n        // lies within the pick tolerance and clipping planes. We keep track\n        // of the point closest to the line (use a fudge factor for points\n        // nearly the same distance away.)\n        if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {\n          let maxDist = 0.0;\n          for (let i = 0; i < 3; i++) {\n            projXYZ[i] = p1[i] + t * ray[i];\n            const dist = Math.abs(x[i] - projXYZ[i]);\n            if (dist > maxDist) {\n              maxDist = dist;\n            }\n          } // end for i\n          if (maxDist <= tolerance && maxDist < minPtDist) {\n            // within tolerance\n            minPtId = ptId;\n            minPtDist = maxDist;\n            tMin = t;\n          }\n        }\n      }\n    }\n    model.pointId = minPtId;\n    return tMin;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  pointId: -1,\n  pointIJK: [],\n  useCells: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPicker.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['pointIJK']);\n  macro.get(publicAPI, model, ['pointId']);\n  macro.setGet(publicAPI, model, ['useCells']);\n  vtkPointPicker(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPointPicker');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPointPicker$1 = {\n  newInstance,\n  extend\n};\nexport { vtkPointPicker$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","d","dot","vtkPicker","vtkErrorMacro","vtkPointPicker","publicAPI","model","classHierarchy","push","intersectWithLine","p1","p2","tolerance","prop","mapper","tMin","Number","MAX_VALUE","isA","pickData","intersectWithLineForPointPicking","t","pointIJK","ijk","intersectActorWithLine","input","getInputData","ptId","numPts","getPoints","getNumberOfPoints","ray","i","rayFactor","minPtId","minPtDist","projXYZ","x","points","useCells","cellData","getPolys","getData","nbPointsPerCell","nbCells","getNumberOfCells","cellID","firstPointIndex","lastPointIndex","pointIndex","pointDataIndex","getPoint","maxDist","dist","Math","abs","pointId","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","getArray","get","setGet","newInstance","vtkPointPicker$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/Core/PointPicker.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { d as dot } from '../../Common/Core/Math/index.js';\nimport vtkPicker from './Picker.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPointPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPointPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPointPicker');\n  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {\n    let tMin = Number.MAX_VALUE;\n    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {\n      const pickData = mapper.intersectWithLineForPointPicking(p1, p2);\n      if (pickData) {\n        tMin = pickData.t;\n        model.pointIJK = pickData.ijk;\n      }\n    } else if (mapper.isA('vtkMapper')) {\n      tMin = model.intersectActorWithLine(p1, p2, tolerance, mapper);\n    }\n    return tMin;\n  };\n  model.intersectActorWithLine = (p1, p2, tolerance, mapper) => {\n    // Get dataset\n    const input = mapper.getInputData();\n\n    // Determine appropriate info\n    let ptId = 0;\n    const numPts = input.getPoints().getNumberOfPoints();\n    if (numPts <= ptId) {\n      return 2.0;\n    }\n    const ray = [];\n    for (let i = 0; i < 3; i++) {\n      ray[i] = p2[i] - p1[i];\n    }\n    const rayFactor = dot(ray, ray);\n    if (rayFactor === 0.0) {\n      vtkErrorMacro('Cannot process points');\n      return 2.0;\n    }\n    let t;\n    let minPtId = -1;\n    let tMin = Number.MAX_VALUE;\n    let minPtDist = Number.MAX_VALUE;\n    const projXYZ = [];\n    const x = [];\n    const points = input.getPoints();\n    if (model.useCells) {\n      const cellData = input.getPolys().getData();\n      const nbPointsPerCell = cellData[0];\n      const nbCells = input.getPolys().getNumberOfCells();\n      for (let cellID = 0; cellID < nbCells; cellID++) {\n        const firstPointIndex = cellID * nbPointsPerCell + 1;\n        const lastPointIndex = firstPointIndex + nbPointsPerCell;\n        for (let pointIndex = firstPointIndex; pointIndex < lastPointIndex; pointIndex++) {\n          const pointDataIndex = cellData[pointIndex];\n          points.getPoint(pointDataIndex, x);\n          t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor;\n\n          // If we find a point closer than we currently have, see whether it\n          // lies within the pick tolerance and clipping planes. We keep track\n          // of the point closest to the line (use a fudge factor for points\n          // nearly the same distance away.)\n          if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {\n            let maxDist = 0.0;\n            for (let i = 0; i < 3; i++) {\n              projXYZ[i] = p1[i] + t * ray[i];\n              const dist = Math.abs(x[i] - projXYZ[i]);\n              if (dist > maxDist) {\n                maxDist = dist;\n              }\n            } // end for i\n            if (maxDist <= tolerance && maxDist < minPtDist) {\n              // within tolerance\n              minPtId = ptId;\n              minPtDist = maxDist;\n              tMin = t;\n            }\n          }\n        } // end for pointIndex\n      } // end for cellID\n    } else {\n      // end if model.useCells\n      for (ptId = 0; ptId < numPts; ptId++) {\n        points.getPoint(ptId, x);\n        t = (ray[0] * (x[0] - p1[0]) + ray[1] * (x[1] - p1[1]) + ray[2] * (x[2] - p1[2])) / rayFactor;\n\n        // If we find a point closer than we currently have, see whether it\n        // lies within the pick tolerance and clipping planes. We keep track\n        // of the point closest to the line (use a fudge factor for points\n        // nearly the same distance away.)\n        if (t >= 0.0 && t <= 1.0 && t <= tMin + model.tolerance) {\n          let maxDist = 0.0;\n          for (let i = 0; i < 3; i++) {\n            projXYZ[i] = p1[i] + t * ray[i];\n            const dist = Math.abs(x[i] - projXYZ[i]);\n            if (dist > maxDist) {\n              maxDist = dist;\n            }\n          } // end for i\n          if (maxDist <= tolerance && maxDist < minPtDist) {\n            // within tolerance\n            minPtId = ptId;\n            minPtDist = maxDist;\n            tMin = t;\n          }\n        }\n      }\n    }\n    model.pointId = minPtId;\n    return tMin;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  pointId: -1,\n  pointIJK: [],\n  useCells: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPicker.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['pointIJK']);\n  macro.get(publicAPI, model, ['pointId']);\n  macro.setGet(publicAPI, model, ['useCells']);\n  vtkPointPicker(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPointPicker');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPointPicker$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPointPicker$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}