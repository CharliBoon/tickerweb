{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { vec3, mat4 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\nimport { r as radiansFromDegrees, j as cross } from '../../Common/Core/Math/index.js';\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraAxisRotateManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraAxisRotateManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraAxisRotateManipulator');\n  const negCameraDir = new Float64Array(3);\n  const newCamPos = new Float64Array(3);\n  const newFp = new Float64Array(3);\n  const newViewUp = new Float64Array(3);\n  const trans = new Float64Array(16);\n  const rotation = new Float64Array(16);\n  const v2 = new Float64Array(3);\n  const centerNeg = new Float64Array(3);\n  const negRotationAxis = new Float64Array(3);\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.previousPosition = position;\n  };\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!position) {\n      return;\n    }\n    const camera = renderer.getActiveCamera();\n    const cameraPos = camera.getPosition();\n    const cameraFp = camera.getFocalPoint();\n    const cameraViewUp = camera.getViewUp();\n    const cameraDirection = camera.getDirectionOfProjection();\n    vec3.negate(negCameraDir, cameraDirection);\n    mat4.identity(trans);\n    mat4.identity(rotation);\n    const {\n      center,\n      rotationFactor,\n      rotationAxis\n    } = model;\n    vec3.negate(negRotationAxis, rotationAxis);\n    const dx = model.previousPosition.x - position.x;\n    const dy = model.previousPosition.y - position.y;\n    const size = interactor.getView().getViewportSize(renderer);\n\n    // Azimuth\n    const azimuthDelta = radiansFromDegrees(360.0 * dx / size[0] * rotationFactor);\n    mat4.rotate(rotation, rotation, azimuthDelta, rotationAxis);\n\n    // Elevation\n    cross(cameraDirection, cameraViewUp, v2);\n    let elevationDelta = radiansFromDegrees(-360.0 * dy / size[1] * rotationFactor);\n    // angle of camera to rotation axis on the positive or negative half,\n    // relative to the origin.\n    const angleToPosHalf = Math.acos(vec3.dot(negCameraDir, rotationAxis));\n    const angleToNegHalf = Math.acos(vec3.dot(negCameraDir, negRotationAxis));\n\n    // whether camera is in positive half of the rotation axis or neg half\n    const inPosHalf = angleToPosHalf <= angleToNegHalf;\n    const elevationToAxis = Math.min(angleToPosHalf, angleToNegHalf);\n    if (model.useHalfAxis && !inPosHalf) {\n      elevationDelta = Math.PI / 2 - angleToPosHalf;\n    } else if (inPosHalf && elevationToAxis + elevationDelta < 0) {\n      elevationDelta = -elevationToAxis;\n      // } else if (!inPosHalf && elevationToAxis - elevationDelta < 0) {\n    } else if (!inPosHalf && angleToPosHalf + elevationDelta > Math.PI) {\n      elevationDelta = elevationToAxis;\n    }\n    mat4.rotate(rotation, rotation, elevationDelta, v2);\n\n    // Translate from origin\n    mat4.translate(trans, trans, center);\n\n    // apply rotation\n    mat4.multiply(trans, trans, rotation);\n\n    // Translate to origin\n    vec3.negate(centerNeg, center);\n    mat4.translate(trans, trans, centerNeg);\n\n    // Apply transformation to camera position, focal point, and view up\n    vec3.transformMat4(newCamPos, cameraPos, trans);\n    vec3.transformMat4(newFp, cameraFp, trans);\n    vec3.transformMat4(newViewUp, cameraViewUp, rotation);\n    camera.setPosition(newCamPos[0], newCamPos[1], newCamPos[2]);\n    camera.setFocalPoint(newFp[0], newFp[1], newFp[2]);\n    camera.setViewUp(newViewUp);\n    renderer.resetCameraClippingRange();\n    if (interactor.getLightFollowCamera()) {\n      renderer.updateLightsGeometryToFollowCamera();\n    }\n    model.previousPosition = position;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  rotationAxis: [0, 0, 1],\n  useHalfAxis: true\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['rotationAxis', 'useHalfAxis']);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n\n  // Object specific methods\n  vtkMouseCameraAxisRotateManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraAxisRotateManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraAxisRotateManipulator$1 = {\n  newInstance,\n  extend\n};\nexport { vtkMouseCameraAxisRotateManipulator$1 as default, extend, newInstance };","map":{"version":3,"names":["vec3","mat4","m","macro","vtkCompositeCameraManipulator","vtkCompositeMouseManipulator","r","radiansFromDegrees","j","cross","vtkMouseCameraAxisRotateManipulator","publicAPI","model","classHierarchy","push","negCameraDir","Float64Array","newCamPos","newFp","newViewUp","trans","rotation","v2","centerNeg","negRotationAxis","onButtonDown","interactor","renderer","position","previousPosition","onMouseMove","camera","getActiveCamera","cameraPos","getPosition","cameraFp","getFocalPoint","cameraViewUp","getViewUp","cameraDirection","getDirectionOfProjection","negate","identity","center","rotationFactor","rotationAxis","dx","x","dy","y","size","getView","getViewportSize","azimuthDelta","rotate","elevationDelta","angleToPosHalf","Math","acos","dot","angleToNegHalf","inPosHalf","elevationToAxis","min","useHalfAxis","PI","translate","multiply","transformMat4","setPosition","setFocalPoint","setViewUp","resetCameraClippingRange","getLightFollowCamera","updateLightsGeometryToFollowCamera","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","obj","setGet","newInstance","vtkMouseCameraAxisRotateManipulator$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraAxisRotateManipulator.js"],"sourcesContent":["import { vec3, mat4 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\nimport { r as radiansFromDegrees, j as cross } from '../../Common/Core/Math/index.js';\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraAxisRotateManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraAxisRotateManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraAxisRotateManipulator');\n  const negCameraDir = new Float64Array(3);\n  const newCamPos = new Float64Array(3);\n  const newFp = new Float64Array(3);\n  const newViewUp = new Float64Array(3);\n  const trans = new Float64Array(16);\n  const rotation = new Float64Array(16);\n  const v2 = new Float64Array(3);\n  const centerNeg = new Float64Array(3);\n  const negRotationAxis = new Float64Array(3);\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.previousPosition = position;\n  };\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!position) {\n      return;\n    }\n    const camera = renderer.getActiveCamera();\n    const cameraPos = camera.getPosition();\n    const cameraFp = camera.getFocalPoint();\n    const cameraViewUp = camera.getViewUp();\n    const cameraDirection = camera.getDirectionOfProjection();\n    vec3.negate(negCameraDir, cameraDirection);\n    mat4.identity(trans);\n    mat4.identity(rotation);\n    const {\n      center,\n      rotationFactor,\n      rotationAxis\n    } = model;\n    vec3.negate(negRotationAxis, rotationAxis);\n    const dx = model.previousPosition.x - position.x;\n    const dy = model.previousPosition.y - position.y;\n    const size = interactor.getView().getViewportSize(renderer);\n\n    // Azimuth\n    const azimuthDelta = radiansFromDegrees(360.0 * dx / size[0] * rotationFactor);\n    mat4.rotate(rotation, rotation, azimuthDelta, rotationAxis);\n\n    // Elevation\n    cross(cameraDirection, cameraViewUp, v2);\n    let elevationDelta = radiansFromDegrees(-360.0 * dy / size[1] * rotationFactor);\n    // angle of camera to rotation axis on the positive or negative half,\n    // relative to the origin.\n    const angleToPosHalf = Math.acos(vec3.dot(negCameraDir, rotationAxis));\n    const angleToNegHalf = Math.acos(vec3.dot(negCameraDir, negRotationAxis));\n\n    // whether camera is in positive half of the rotation axis or neg half\n    const inPosHalf = angleToPosHalf <= angleToNegHalf;\n    const elevationToAxis = Math.min(angleToPosHalf, angleToNegHalf);\n    if (model.useHalfAxis && !inPosHalf) {\n      elevationDelta = Math.PI / 2 - angleToPosHalf;\n    } else if (inPosHalf && elevationToAxis + elevationDelta < 0) {\n      elevationDelta = -elevationToAxis;\n      // } else if (!inPosHalf && elevationToAxis - elevationDelta < 0) {\n    } else if (!inPosHalf && angleToPosHalf + elevationDelta > Math.PI) {\n      elevationDelta = elevationToAxis;\n    }\n    mat4.rotate(rotation, rotation, elevationDelta, v2);\n\n    // Translate from origin\n    mat4.translate(trans, trans, center);\n\n    // apply rotation\n    mat4.multiply(trans, trans, rotation);\n\n    // Translate to origin\n    vec3.negate(centerNeg, center);\n    mat4.translate(trans, trans, centerNeg);\n\n    // Apply transformation to camera position, focal point, and view up\n    vec3.transformMat4(newCamPos, cameraPos, trans);\n    vec3.transformMat4(newFp, cameraFp, trans);\n    vec3.transformMat4(newViewUp, cameraViewUp, rotation);\n    camera.setPosition(newCamPos[0], newCamPos[1], newCamPos[2]);\n    camera.setFocalPoint(newFp[0], newFp[1], newFp[2]);\n    camera.setViewUp(newViewUp);\n    renderer.resetCameraClippingRange();\n    if (interactor.getLightFollowCamera()) {\n      renderer.updateLightsGeometryToFollowCamera();\n    }\n    model.previousPosition = position;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  rotationAxis: [0, 0, 1],\n  useHalfAxis: true\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['rotationAxis', 'useHalfAxis']);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n\n  // Object specific methods\n  vtkMouseCameraAxisRotateManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraAxisRotateManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraAxisRotateManipulator$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkMouseCameraAxisRotateManipulator$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}