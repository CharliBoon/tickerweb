{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, e as setGet, o as obj, c as macro } from '../../macros2.js';\nimport vtkHelper from './Helper.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport { l as normalize, u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nimport { PassTypes } from './HardwareSelector/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport '../Core/Mapper/CoincidentTopologyHelper.js';\nimport { Resolve } from '../Core/Mapper/Static.js';\nconst {\n  FieldAssociations\n} = vtkDataSet;\n\n/* eslint-disable no-lonely-if */\n\nconst {\n  primTypes\n} = vtkHelper;\nconst {\n  Representation,\n  Shading\n} = vtkProperty;\nconst {\n  ScalarMode\n} = vtkMapper;\nconst {\n  Filter,\n  Wrap\n} = vtkOpenGLTexture;\nconst {\n  vtkErrorMacro\n} = macro;\nconst StartEvent = {\n  type: 'StartEvent'\n};\nconst EndEvent = {\n  type: 'EndEvent'\n};\nconst {\n  CoordinateSystem\n} = vtkProp;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLPolyDataMapper methods\n// ----------------------------------------------------------------------------\n\nfunction getPickState(renderer) {\n  const selector = renderer.getSelector();\n  if (selector) {\n    return selector.getCurrentPass();\n  }\n  return PassTypes.MIN_KNOWN_PASS - 1;\n}\nfunction vtkOpenGLPolyDataMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLPolyDataMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');\n      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.render = () => {\n    const ctx = model._openGLRenderWindow.getContext();\n    if (model.context !== ctx) {\n      model.context = ctx;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n    }\n    const actor = model.openGLActor.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderColor = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n    // create the material/color property declarations, and VS implementation\n    // these are always defined\n    let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;'];\n    // add more for specular\n    if (lastLightComplexity) {\n      colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);\n    }\n\n    // now handle the more complex fragment shader implementation\n    // the following are always defined variables.  We start\n    // by assigning a default value from the uniform\n    let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);\n    }\n    colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);\n    }\n\n    // add scalar vertex coloring\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n    }\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;\n    } else {\n      if ((model.renderable.getAreScalarsMappedFromCells() || model.renderable.getInterpolateScalarsBeforeMapping()) && model.renderable.getColorCoordinates() && !model.drawingEdges) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;\n      } else {\n        if (actor.getBackfaceProperty() && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);\n          if (lastLightComplexity) {\n            colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);\n          } else {\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);\n          }\n        }\n        if (model.haveCellScalars && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderLight = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    // check for shadow maps\n    const shadowFactor = '';\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    let sstring = [];\n    switch (lastLightComplexity) {\n      case 0:\n        // no lighting or RENDER_VALUES\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 1:\n        // headlight\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 2:\n        // light kit\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, '    {', `    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      case 3:\n        // positional\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat(['  attenuation = 1.0;', `  if (lightPositional${lc} == 0)`, '    {', `      vertLightDirectionVC = lightDirectionVC${lc};`, '    }', '  else', '    {', `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, '    // per OpenGL standard cone angle is 90 or less for a spot light', `    if (lightConeAngle${lc} <= 90.0)`, '      {', `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, '      // if inside the cone', `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, '        {', `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', `      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${lc},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      default:\n        vtkErrorMacro('bad light complexity');\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.lastBoundBO.getCABO().getNormalOffset()) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);',\n        //  if (!gl_FrontFacing) does not work in intel hd4000 mac\n        //  if (int(gl_FrontFacing) == 0) does not work on mesa\n        '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n      } else {\n        if (model.haveCellNormals) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n        } else {\n          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {\n            // generate a normal for lines, it will be perpendicular to the line\n            // and maximally aligned with the camera view direction\n            // no clue if this is the best way to do this.\n            // the code below has been optimized a bit so what follows is\n            // an explanation of the basic approach. Compute the gradient of the line\n            // with respect to x and y, the the larger of the two\n            // cross that with the camera view direction. That gives a vector\n            // orthogonal to the camera view and the line. Note that the line and the camera\n            // view are probably not orthogonal. Which is why when we cross result that with\n            // the line gradient again we get a reasonable normal. It will be othogonal to\n            // the line (which is a plane but maximally aligned with the camera view.\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;\n          } else {\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', [\n            // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',\n            // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',\n            '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',\n            // the code below is faster, but does not work on some devices\n            // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',\n            '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;\n          }\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    // replace common shader code\n    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n\n    // do we need the vertex in the shader in View Coordinates\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;\n    } else {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {\n    if (model.lastBoundBO.getCABO().getTCoordOffset()) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.drawingEdges) {\n        return;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n\n      // we only handle the first texture by default\n      // additional textures are activated and we set the uniform\n      // for the texture unit they are assigned to, but you have to\n      // add in the shader code to do something with them\n      const tus = model.openGLActor.getActiveTextures();\n      let tNumComp = 2;\n      let tcdim = 2;\n      if (tus && tus.length > 0) {\n        tNumComp = tus[0].getComponents();\n        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {\n          tcdim = 3;\n        }\n      }\n      if (model.renderable.getColorTextureMap()) {\n        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();\n        tcdim = 2;\n      }\n      if (tcdim === 2) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;\n        if (tus && tus.length >= 1) {\n          switch (tNumComp) {\n            case 1:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n              break;\n            case 2:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n              break;\n            default:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n          }\n        }\n      } else {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;\n        switch (tNumComp) {\n          case 1:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n            break;\n          case 2:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n            break;\n          default:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    // 1. ResolveCoincidentTopology is On and non zero for this primitive\n    // type\n    let cp = {\n      factor: 0.0,\n      offset: 0.0\n    };\n    const prop = actor.getProperty();\n    if (\n    // backwards compat with code that (errorneously) set this to boolean\n    // eslint-disable-next-line eqeqeq\n    model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset || prop.getEdgeVisibility() && prop.getRepresentation() === Representation.SURFACE) {\n      const primType = model.lastBoundBO.getPrimitiveType();\n      if (primType === primTypes.Points || prop.getRepresentation() === Representation.POINTS) {\n        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();\n      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation.WIREFRAME) {\n        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();\n      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n      }\n      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n        cp.factor /= 2.0;\n        cp.offset /= 2.0;\n      }\n    }\n\n    // hardware picking always offset due to saved zbuffer\n    // This gets you above the saved surface depth buffer.\n    const selector = model._openGLRenderer.getSelector();\n    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      cp.offset -= 2.0;\n    }\n    return cp;\n  };\n  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n    let VSSource = shaders.Vertex;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;\n    if (!model._openGLRenderer.getSelector()) {\n      return;\n    }\n    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\\n', 'uniform int VertexIDOffset;\\n']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;\n    }\n    switch (model.lastSelectionState) {\n      case PassTypes.ID_LOW24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;\n        break;\n      case PassTypes.ID_HIGH24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);').result;\n        break;\n      default:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;\n    }\n    shaders.Fragment = FSSource;\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    publicAPI.replaceShaderColor(shaders, ren, actor);\n    publicAPI.replaceShaderNormal(shaders, ren, actor);\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPicking(shaders, ren, actor);\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n    if (model.haveSeenDepthRequest) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    let lightComplexity = 0;\n    let numberOfLights = 0;\n    const primType = cellBO.getPrimitiveType();\n    const poly = model.currentInput;\n\n    // different algo from C++ as of 5/2019\n    let needLighting = false;\n    const pointNormals = poly.getPointData().getNormals();\n    const cellNormals = poly.getCellData().getNormals();\n    const flat = actor.getProperty().getInterpolation() === Shading.FLAT;\n    const representation = actor.getProperty().getRepresentation();\n    const mode = cellBO.getOpenGLMode(representation, primType);\n    // 1) all surfaces need lighting\n    if (mode === model.context.TRIANGLES) {\n      needLighting = true;\n      // 2) all cell normals without point normals need lighting\n    } else if (cellNormals && !pointNormals) {\n      needLighting = true;\n      // 3) Phong + pointNormals need lighting\n    } else if (!flat && pointNormals) {\n      needLighting = true;\n      // 4) Phong Lines need lighting\n    } else if (!flat && mode === model.context.LINES) {\n      needLighting = true;\n    }\n    // 5) everything else is unlit\n\n    // do we need lighting?\n    if (actor.getProperty().getLighting() && needLighting) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      const lights = ren.getLightsByReference();\n      for (let index = 0; index < lights.length; ++index) {\n        const light = lights[index];\n        const status = light.getSwitch();\n        if (status > 0) {\n          numberOfLights++;\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      }\n    }\n    let needRebuild = false;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {\n      model.lastBoundBO.set({\n        lastLightComplexity: lightComplexity\n      }, true);\n      model.lastBoundBO.set({\n        lastLightCount: numberOfLights\n      }, true);\n      needRebuild = true;\n    }\n\n    // has the render pass shader replacement changed? Two options\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {\n    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;\n    if (listCallbacks) {\n      listCallbacks.forEach(object => {\n        object.callback(object.userData, cellBO, ren, actor);\n      });\n    }\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {\n      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);\n    }\n    if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {\n      cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);\n    }\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting normalMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('normalMC');\n      }\n      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {\n        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {\n          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {\n            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);\n          }\n        }\n      });\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('tcoordMC');\n      }\n      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {\n          vtkErrorMacro('Error setting scalarColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('scalarColor');\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      const planeEquations = [];\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {\n      cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());\n    }\n    const tus = model.openGLActor.getActiveTextures();\n    if (tus) {\n      for (let index = 0; index < tus.length; ++index) {\n        const tex = tus[index];\n        const texUnit = tex.getTextureUnit();\n        const tname = `texture${texUnit + 1}`;\n        if (cellBO.getProgram().isUniformUsed(tname)) {\n          cellBO.getProgram().setUniformi(tname, texUnit);\n        }\n      }\n    }\n\n    // handle depth requests\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n\n    // handle wide lines\n    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());\n    const selector = model._openGLRenderer.getSelector();\n    cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);\n    cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);\n  };\n  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {\n    // for unlit and headlight there are no lighting parameters\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 2) {\n      return;\n    }\n    const program = cellBO.getProgram();\n\n    // bind some light settings\n    let numberOfLights = 0;\n    const lights = ren.getLightsByReference();\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const dColor = light.getColorByReference();\n        const intensity = light.getIntensity();\n        model.lightColor[0] = dColor[0] * intensity;\n        model.lightColor[1] = dColor[1] * intensity;\n        model.lightColor[2] = dColor[2] * intensity;\n        // get required info from light\n        const ld = light.getDirection();\n        const transform = ren.getActiveCamera().getViewMatrix();\n        const newLightDirection = [...ld];\n        if (light.lightTypeIsSceneLight()) {\n          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];\n          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];\n          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];\n          normalize(newLightDirection);\n        }\n        model.lightDirection[0] = newLightDirection[0];\n        model.lightDirection[1] = newLightDirection[1];\n        model.lightDirection[2] = newLightDirection[2];\n        normalize(model.lightDirection);\n        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);\n        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);\n        numberOfLights++;\n      }\n    }\n\n    // we are done unless we have positional lights\n    if (lastLightComplexity < 3) {\n      return;\n    }\n\n    // for lightkit case there are some parameters to set\n    const cam = ren.getActiveCamera();\n    const viewTF = cam.getViewMatrix();\n    mat4.transpose(viewTF, viewTF);\n    numberOfLights = 0;\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const lp = light.getTransformedPosition();\n        const np = new Float64Array(3);\n        vec3.transformMat4(np, lp, viewTF);\n        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());\n        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());\n        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());\n        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());\n        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);\n        numberOfLights++;\n      }\n    }\n  };\n  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n    matrixType.identity(tmpMat);\n    return matrixArray.reduce((res, matrix, index) => {\n      if (index === 0) {\n        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n      }\n      return matrix ? matrixType.multiply(res, res, matrix) : res;\n    }, tmpMat);\n  }\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const cam = ren.getActiveCamera();\n    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();\n    const progm = program.getLastCameraMTime();\n    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    const actorIsIdentity = actor.getIsIdentity();\n    const actMats = actorIsIdentity ? {\n      mcwc: null,\n      normalMatrix: null\n    } : model.openGLActor.getKeyMatrices();\n    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {\n      const size = model._openGLRenderer.getTiledSizeAndOrigin();\n      mat4.identity(model.tmpMat4);\n      model.tmpMat4[0] = 2.0 / size.usize;\n      model.tmpMat4[12] = -1.0;\n      model.tmpMat4[5] = 2.0 / size.vsize;\n      model.tmpMat4[13] = -1.0;\n      mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n      program.setUniformMatrix('MCPCMatrix', model.tmpMat4);\n    } else {\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('normalMatrix')) {\n      program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3, model.tmpMat3));\n    }\n    if (progm !== camm) {\n      if (program.isUniformUsed('cameraParallel')) {\n        program.setUniformi('cameraParallel', cam.getParallelProjection());\n      }\n      program.setLastCameraMTime(camm);\n    }\n    if (!actorIsIdentity) {\n      // reset the cam mtime as actor modified the shader values\n      program.setLastCameraMTime(0);\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    let ppty = actor.getProperty();\n    let opacity = ppty.getOpacity();\n    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();\n    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();\n    let aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();\n    let dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();\n    let sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();\n    const specularPower = ppty.getSpecularPower();\n    program.setUniformf('opacityUniform', opacity);\n    program.setUniform3fArray('ambientColorUniform', aColor);\n    program.setUniform3fArray('diffuseColorUniform', dColor);\n    program.setUniformf('ambient', aIntensity);\n    program.setUniformf('diffuse', dIntensity);\n\n    // we are done unless we have lighting\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 1) {\n      return;\n    }\n    let sColor = ppty.getSpecularColorByReference();\n    program.setUniform3fArray('specularColorUniform', sColor);\n    program.setUniformf('specularPowerUniform', specularPower);\n    program.setUniformf('specular', sIntensity);\n\n    // now set the backface properties if we have them\n    if (program.isUniformUsed('ambientIntensityBF')) {\n      ppty = actor.getBackfaceProperty();\n      opacity = ppty.getOpacity();\n      aColor = ppty.getAmbientColor();\n      aIntensity = ppty.getAmbient();\n      dColor = ppty.getDiffuseColor();\n      dIntensity = ppty.getDiffuse();\n      sColor = ppty.getSpecularColor();\n      sIntensity = ppty.getSpecular();\n      program.setUniformf('ambientIntensityBF', aIntensity);\n      program.setUniformf('diffuseIntensityBF', dIntensity);\n      program.setUniformf('opacityUniformBF', opacity);\n      program.setUniform3fArray('ambientColorUniformBF', aColor);\n      program.setUniform3fArray('diffuseColorUniformBF', dColor);\n\n      // we are done unless we have lighting\n      if (lastLightComplexity < 1) {\n        return;\n      }\n      program.setUniformf('specularIntensityBF', sIntensity);\n      program.setUniform3fArray('specularColorUniformBF', sColor);\n      program.setUniformf('specularPowerUniformBF', specularPower);\n    }\n  };\n  publicAPI.updateMaximumPointCellIds = (ren, actor) => {\n    const selector = model._openGLRenderer.getSelector();\n    if (!selector) {\n      return;\n    }\n    if (model.selectionWebGLIdsToVTKIds?.points?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.points.length;\n      selector.setMaximumPointId(length - 1);\n    }\n    if (model.selectionWebGLIdsToVTKIds?.cells?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.cells.length;\n      selector.setMaximumCellId(length - 1);\n    }\n    const fieldAssociation = selector.getFieldAssociation();\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      model.pointPicking = true;\n    }\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    model.primitiveIDOffset = 0;\n    model.vertexIDOffset = 0;\n    const picking = getPickState(model._openGLRenderer);\n    if (model.lastSelectionState !== picking) {\n      model.selectionStateChanged.modified();\n      model.lastSelectionState = picking;\n    }\n    if (model._openGLRenderer.getSelector()) {\n      switch (picking) {\n        default:\n          model._openGLRenderer.getSelector().renderProp(actor);\n      }\n    }\n\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // If we are coloring by texture, then load the texture map.\n    // Use Map as indicator, because texture hangs around.\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.activate();\n    }\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const representation = actor.getProperty().getRepresentation();\n    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n    const selector = model._openGLRenderer.getSelector();\n    // If we are picking points, we need to tell it to the helper\n    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24);\n\n    // for every primitive type\n    for (let i = primTypes.Start; i < primTypes.End; i++) {\n      model.primitives[i].setPointPicking(pointPicking);\n      const cabo = model.primitives[i].getCABO();\n      if (cabo.getElementCount()) {\n        // are we drawing edges\n        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);\n        // don't draw edges when rendering depth or rendering for picking\n        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {\n          model.lastBoundBO = model.primitives[i];\n          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);\n          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();\n        }\n      }\n    }\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    if (model.LastBoundBO) {\n      model.LastBoundBO.getVAO().release();\n    }\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.deactivate();\n    }\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n\n    publicAPI.invokeEvent(StartEvent);\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent(EndEvent);\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    // if there are no points then we are done\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    }\n\n    // apply faceCulling\n    const gl = model.context;\n    const backfaceCulling = actor.getProperty().getBackfaceCulling();\n    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();\n    if (!backfaceCulling && !frontfaceCulling) {\n      model._openGLRenderWindow.disableCullFace();\n    } else if (frontfaceCulling) {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.FRONT);\n    } else {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.BACK);\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n    // Always call this function as the selector can change\n    publicAPI.updateMaximumPointCellIds();\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    const c = model.renderable.getColorMapColors();\n    model.haveCellScalars = false;\n    const scalarMode = model.renderable.getScalarMode();\n    if (model.renderable.getScalarVisibility()) {\n      // We must figure out how the scalars should be mapped to the polydata.\n      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n        model.haveCellScalars = true;\n      }\n    }\n\n    // Do we have normals?\n    let n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;\n    if (n === null && poly.getCellData().getNormals()) {\n      model.haveCellNormals = true;\n      n = poly.getCellData().getNormals();\n    }\n\n    // rebuild the VBO if the data has changed we create a string for the VBO what\n    // can change the VBO? points normals tcoords colors so what can change those?\n    // the input data is clearly one as it can change all four items tcoords may\n    // haveTextures or not colors may change based on quite a few mapping\n    // parameters in the mapper\n\n    const representation = actor.getProperty().getRepresentation();\n    let tcoords = poly.getPointData().getTCoords();\n    if (!model.openGLActor.getActiveTextures()) {\n      tcoords = null;\n    }\n\n    // Flag to check if tcoords are per cell instead of per point\n    let useTCoordsPerCell = false;\n    // handle color mapping via texture\n    if (model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();\n      if (!model.internalColorTexture) {\n        model.internalColorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n      }\n      const tex = model.internalColorTexture;\n      // the following 4 lines allow for NPOT textures\n      tex.setMinificationFilter(Filter.NEAREST);\n      tex.setMagnificationFilter(Filter.NEAREST);\n      tex.setWrapS(Wrap.CLAMP_TO_EDGE);\n      tex.setWrapT(Wrap.CLAMP_TO_EDGE);\n      tex.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const input = model.renderable.getColorTextureMap();\n      const ext = input.getExtent();\n      const inScalars = input.getPointData().getScalars();\n      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n      tex.activate();\n      tex.sendParameters();\n      tex.deactivate();\n    }\n    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}` + `E${actor.getProperty().getEdgeVisibility()}` + `F${tcoords ? tcoords.getMTime() : 1}`;\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      const points = poly.getPoints();\n      const options = {\n        points,\n        normals: n,\n        tcoords,\n        colors: c,\n        cellOffset: 0,\n        vertexOffset: 0,\n        // Used to keep track of vertex ids across primitives for selection\n        useTCoordsPerCell,\n        haveCellScalars: model.haveCellScalars,\n        haveCellNormals: model.haveCellNormals,\n        customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))\n      };\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.selectionWebGLIdsToVTKIds = {\n          points: null,\n          cells: null\n        };\n      }\n      const primitives = [{\n        inRep: 'verts',\n        cells: poly.getVerts()\n      }, {\n        inRep: 'lines',\n        cells: poly.getLines()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }];\n      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {\n          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);\n          options.vertexOffset += model.primitives[i].getCABO().getElementCount();\n        } else {\n          // if we have edge visibility build the edge VBOs\n          if (drawSurfaceWithEdges) {\n            // VBOs for edges in \"surface with edges\" are the last to be built,\n            // they are not used when picking with a hardware selector so they\n            // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset\n            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation.WIREFRAME, {\n              ...options,\n              tcoords: null,\n              colors: null,\n              haveCellScalars: false,\n              haveCellNormals: false\n            });\n          } else {\n            // otherwise free them\n            model.primitives[i].releaseGraphicsResources();\n          }\n        }\n      }\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);\n      }\n      model.VBOBuildString = toString;\n    }\n    model.VBOBuildTime.modified();\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => {\n    let memUsed = 0;\n    model.primitives.forEach(prim => {\n      memUsed += prim.getAllocatedGPUMemoryInBytes();\n    });\n    // Return in MB\n    return memUsed;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  primitives: null,\n  primTypes: null,\n  shaderRebuildString: null,\n  tmpMat4: null,\n  ambientColor: [],\n  // used internally\n  diffuseColor: [],\n  // used internally\n  specularColor: [],\n  // used internally\n  lightColor: [],\n  // used internally\n  lightDirection: [],\n  // used internally\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,\n  selectionStateChanged: null,\n  selectionWebGLIdsToVTKIds: null,\n  pointPicking: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.primitives = [];\n  model.primTypes = primTypes;\n  model.tmpMat3 = mat3.identity(new Float64Array(9));\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  for (let i = primTypes.Start; i < primTypes.End; i++) {\n    model.primitives[i] = vtkHelper.newInstance();\n    model.primitives[i].setPrimitiveType(i);\n    model.primitives[i].set({\n      lastLightComplexity: 0,\n      lastLightCount: 0,\n      lastSelectionPass: false\n    }, true);\n  }\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.selectionStateChanged = {};\n  obj(model.selectionStateChanged, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLPolyDataMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLPolyDataMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLPolyDataMapper$1 = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkMapper', newInstance);\nexport { vtkOpenGLPolyDataMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["mat3","mat4","vec3","n","newInstance$1","e","setGet","o","obj","c","macro","vtkHelper","vtkMapper","l","normalize","u","uninitializeBounds","vtkOpenGLTexture","vtkProp","vtkProperty","vtkShaderProgram","vtkViewNode","v","vtkPolyDataVS","vtkPolyDataFS","vtkReplacementShaderMapper","registerOverride","PassTypes","vtkDataSet","Resolve","FieldAssociations","primTypes","Representation","Shading","ScalarMode","Filter","Wrap","vtkErrorMacro","StartEvent","type","EndEvent","CoordinateSystem","getPickState","renderer","selector","getSelector","getCurrentPass","MIN_KNOWN_PASS","vtkOpenGLPolyDataMapper","publicAPI","model","classHierarchy","push","buildPass","prepass","currentRenderPass","openGLActor","getFirstAncestorOfType","_openGLRenderer","_openGLRenderWindow","getLastAncestorOfType","openGLCamera","getViewNodeFor","getRenderable","getActiveCamera","translucentPass","renderPass","render","zBufferPass","haveSeenDepthRequest","renderDepth","opaqueZBufferPass","opaquePass","ctx","getContext","context","i","Start","End","primitives","setOpenGLRenderWindow","actor","ren","renderPiece","getShaderTemplate","shaders","Vertex","Fragment","Geometry","replaceShaderColor","VSSource","GSSource","FSSource","lastLightComplexity","lastBoundBO","getReferenceByName","colorDec","concat","colorImpl","getCABO","getColorComponents","drawingEdges","substitute","result","renderable","getAreScalarsMappedFromCells","getInterpolateScalarsBeforeMapping","getColorCoordinates","getBackfaceProperty","haveCellScalars","replaceShaderLight","shadowFactor","lastLightCount","sstring","lc","replaceShaderNormal","getNormalOffset","haveCellNormals","getOpenGLMode","getProperty","getRepresentation","LINES","replaceShaderPositionVC","replaceShaderTCoord","getTCoordOffset","tus","getActiveTextures","tNumComp","tcdim","length","getComponents","getTarget","TEXTURE_CUBE_MAP","getColorTextureMap","getPointData","getScalars","getNumberOfComponents","replaceShaderClip","getNumberOfClippingPlanes","numClipPlanes","getCoincidentParameters","cp","factor","offset","prop","getResolveCoincidentTopology","PolygonOffset","getEdgeVisibility","SURFACE","primType","getPrimitiveType","Points","POINTS","getCoincidentTopologyPointOffsetParameter","Lines","WIREFRAME","getCoincidentTopologyLineOffsetParameters","Tris","TriStrips","getCoincidentTopologyPolygonOffsetParameters","TrisEdges","TriStripsEdges","getFieldAssociation","FIELD_ASSOCIATION_POINTS","replaceShaderPicking","lastSelectionState","ID_LOW24","ID_HIGH24","replaceShaderValues","replaceShaderCoincidentOffset","getNeedToRebuildShaders","cellBO","lightComplexity","numberOfLights","poly","currentInput","needLighting","pointNormals","getNormals","cellNormals","getCellData","flat","getInterpolation","FLAT","representation","mode","TRIANGLES","getLighting","lights","getLightsByReference","index","light","status","getSwitch","getIntensity","lightTypeIsHeadLight","getPositional","needRebuild","set","lastRenderPassShaderReplacement","getShaderReplacement","lastHaveSeenDepthRequest","getShaderSourceTime","getMTime","selectionStateChanged","invokeShaderCallbacks","listCallbacks","getViewSpecificProperties","ShadersCallbacks","forEach","object","callback","userData","setMapperShaderParameters","getProgram","isUniformUsed","setUniformi","primitiveIDOffset","vertexIDOffset","getElementCount","VBOBuildTime","getAttributeUpdateTime","isAttributeUsed","getVAO","addAttributeArray","getVertexOffset","getStride","FLOAT","removeAttributeArray","getCustomShaderAttributes","attrName","idx","getCustomData","components","getTCoordComponents","getColorBO","getColorOffset","getColorBOStride","UNSIGNED_BYTE","modified","planeEquations","shiftScaleEnabled","getCoordShiftAndScaleEnabled","inverseShiftScaleMatrix","getInverseShiftAndScaleMatrix","mat","copy","tmpMat4","getMatrix","transpose","multiply","planeEquation","getClippingPlaneInDataCoords","j","setUniform4fv","internalColorTexture","getTextureUnit","tex","texUnit","tname","setUniformf","getTiledSizeAndOrigin","setUniform3fArray","getPropColorValue","setLightingShaderParameters","program","dColor","getColorByReference","intensity","lightColor","ld","getDirection","transform","getViewMatrix","newLightDirection","lightTypeIsSceneLight","lightDirection","cam","viewTF","lp","getTransformedPosition","np","Float64Array","transformMat4","getAttenuationValuesByReference","getExponent","getConeAngle","safeMatrixMultiply","matrixArray","matrixType","tmpMat","identity","reduce","res","matrix","setCameraShaderParameters","keyMats","getKeyMatrices","camm","getKeyMatrixTime","progm","getLastCameraMTime","actorIsIdentity","getIsIdentity","actMats","mcwc","normalMatrix","getCoordinateSystem","DISPLAY","size","usize","vsize","setUniformMatrix","wcpc","wcvc","setUniformMatrix3x3","tmpMat3","getParallelProjection","setLastCameraMTime","setPropertyShaderParameters","ppty","opacity","getOpacity","aColor","getEdgeColorByReference","getAmbientColorByReference","getDiffuseColorByReference","aIntensity","getAmbient","dIntensity","getDiffuse","sIntensity","getSpecular","specularPower","getSpecularPower","sColor","getSpecularColorByReference","getAmbientColor","getDiffuseColor","getSpecularColor","updateMaximumPointCellIds","selectionWebGLIdsToVTKIds","points","setMaximumPointId","cells","setMaximumCellId","fieldAssociation","pointPicking","renderPieceStart","picking","renderProp","updateBufferObjects","activate","renderPieceDraw","drawSurfaceWithEdges","setPointPicking","cabo","drawArrays","renderPieceFinish","LastBoundBO","release","deactivate","invokeEvent","getStatic","update","getInputData","getPoints","getNumberOfValues","gl","backfaceCulling","getBackfaceCulling","frontfaceCulling","getFrontfaceCulling","disableCullFace","enableCullFace","cullFace","FRONT","BACK","computeBounds","getInput","bounds","getBounds","getNeedToRebuildBufferObjects","buildBufferObjects","vmtime","mapScalars","getColorMapColors","scalarMode","getScalarMode","getScalarVisibility","USE_CELL_DATA","USE_CELL_FIELD_DATA","USE_FIELD_DATA","USE_POINT_FIELD_DATA","tcoords","getTCoords","useTCoordsPerCell","newInstance","resizable","setMinificationFilter","NEAREST","setMagnificationFilter","setWrapS","CLAMP_TO_EDGE","setWrapT","input","ext","getExtent","inScalars","create2DFromRaw","getDataType","getData","sendParameters","toString","VBOBuildString","options","normals","colors","cellOffset","vertexOffset","customAttributes","map","arrayName","getArrayByName","getPopulateSelectionSettings","inRep","getVerts","getLines","getPolys","getStrips","createVBO","releaseGraphicsResources","setSelectionWebGLIdsToVTKIds","getAllocatedGPUMemoryInBytes","memUsed","prim","DEFAULT_VALUES","shaderRebuildString","ambientColor","diffuseColor","specularColor","extend","initialValues","arguments","undefined","Object","assign","implementReplaceShaderCoincidentOffset","implementBuildShadersWithReplacements","setPrimitiveType","lastSelectionPass","mtime","vtkOpenGLPolyDataMapper$1","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js"],"sourcesContent":["import { mat3, mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, e as setGet, o as obj, c as macro } from '../../macros2.js';\nimport vtkHelper from './Helper.js';\nimport vtkMapper from '../Core/Mapper.js';\nimport { l as normalize, u as uninitializeBounds } from '../../Common/Core/Math/index.js';\nimport vtkOpenGLTexture from './Texture.js';\nimport vtkProp from '../Core/Prop.js';\nimport vtkProperty from '../Core/Property.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { v as vtkPolyDataVS } from './glsl/vtkPolyDataVS.glsl.js';\nimport { v as vtkPolyDataFS } from './glsl/vtkPolyDataFS.glsl.js';\nimport vtkReplacementShaderMapper from './ReplacementShaderMapper.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nimport { PassTypes } from './HardwareSelector/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport '../Core/Mapper/CoincidentTopologyHelper.js';\nimport { Resolve } from '../Core/Mapper/Static.js';\n\nconst {\n  FieldAssociations\n} = vtkDataSet;\n\n/* eslint-disable no-lonely-if */\n\nconst {\n  primTypes\n} = vtkHelper;\nconst {\n  Representation,\n  Shading\n} = vtkProperty;\nconst {\n  ScalarMode\n} = vtkMapper;\nconst {\n  Filter,\n  Wrap\n} = vtkOpenGLTexture;\nconst {\n  vtkErrorMacro\n} = macro;\nconst StartEvent = {\n  type: 'StartEvent'\n};\nconst EndEvent = {\n  type: 'EndEvent'\n};\nconst {\n  CoordinateSystem\n} = vtkProp;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLPolyDataMapper methods\n// ----------------------------------------------------------------------------\n\nfunction getPickState(renderer) {\n  const selector = renderer.getSelector();\n  if (selector) {\n    return selector.getCurrentPass();\n  }\n  return PassTypes.MIN_KNOWN_PASS - 1;\n}\nfunction vtkOpenGLPolyDataMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLPolyDataMapper');\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      model.currentRenderPass = null;\n      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');\n      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');\n      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.currentRenderPass = renderPass;\n      publicAPI.render();\n    }\n  };\n  publicAPI.zBufferPass = prepass => {\n    if (prepass) {\n      model.haveSeenDepthRequest = true;\n      model.renderDepth = true;\n      publicAPI.render();\n      model.renderDepth = false;\n    }\n  };\n  publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);\n  publicAPI.opaquePass = prepass => {\n    if (prepass) {\n      publicAPI.render();\n    }\n  };\n  publicAPI.render = () => {\n    const ctx = model._openGLRenderWindow.getContext();\n    if (model.context !== ctx) {\n      model.context = ctx;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);\n      }\n    }\n    const actor = model.openGLActor.getRenderable();\n    const ren = model._openGLRenderer.getRenderable();\n    publicAPI.renderPiece(ren, actor);\n  };\n  publicAPI.getShaderTemplate = (shaders, ren, actor) => {\n    shaders.Vertex = vtkPolyDataVS;\n    shaders.Fragment = vtkPolyDataFS;\n    shaders.Geometry = '';\n  };\n  publicAPI.replaceShaderColor = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n\n    // create the material/color property declarations, and VS implementation\n    // these are always defined\n    let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;'];\n    // add more for specular\n    if (lastLightComplexity) {\n      colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);\n    }\n\n    // now handle the more complex fragment shader implementation\n    // the following are always defined variables.  We start\n    // by assigning a default value from the uniform\n    let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);\n    }\n    colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);\n    if (lastLightComplexity) {\n      colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);\n    }\n\n    // add scalar vertex coloring\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;\n    }\n    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;\n    } else {\n      if ((model.renderable.getAreScalarsMappedFromCells() || model.renderable.getInterpolateScalarsBeforeMapping()) && model.renderable.getColorCoordinates() && !model.drawingEdges) {\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;\n      } else {\n        if (actor.getBackfaceProperty() && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);\n          if (lastLightComplexity) {\n            colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);\n          } else {\n            colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);\n          }\n        }\n        if (model.haveCellScalars && !model.drawingEdges) {\n          colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;\n      }\n    }\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderLight = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n\n    // check for shadow maps\n    const shadowFactor = '';\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    let sstring = [];\n    switch (lastLightComplexity) {\n      case 0:\n        // no lighting or RENDER_VALUES\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 1:\n        // headlight\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;\n        break;\n      case 2:\n        // light kit\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, '    {', `    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      case 3:\n        // positional\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);\n        }\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Dec', sstring).result;\n        sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];\n        for (let lc = 0; lc < lastLightCount; ++lc) {\n          sstring = sstring.concat(['  attenuation = 1.0;', `  if (lightPositional${lc} == 0)`, '    {', `      vertLightDirectionVC = lightDirectionVC${lc};`, '    }', '  else', '    {', `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, '    // per OpenGL standard cone angle is 90 or less for a spot light', `    if (lightConeAngle${lc} <= 90.0)`, '      {', `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, '      // if inside the cone', `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, '        {', `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', `      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${lc},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, '    }']);\n        }\n        sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;\n        break;\n      default:\n        vtkErrorMacro('bad light complexity');\n    }\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.lastBoundBO.getCABO().getNormalOffset()) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);',\n        //  if (!gl_FrontFacing) does not work in intel hd4000 mac\n        //  if (int(gl_FrontFacing) == 0) does not work on mesa\n        '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n      } else {\n        if (model.haveCellNormals) {\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;\n          FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;\n        } else {\n          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {\n            // generate a normal for lines, it will be perpendicular to the line\n            // and maximally aligned with the camera view direction\n            // no clue if this is the best way to do this.\n            // the code below has been optimized a bit so what follows is\n            // an explanation of the basic approach. Compute the gradient of the line\n            // with respect to x and y, the the larger of the two\n            // cross that with the camera view direction. That gives a vector\n            // orthogonal to the camera view and the line. Note that the line and the camera\n            // view are probably not orthogonal. Which is why when we cross result that with\n            // the line gradient again we get a reasonable normal. It will be othogonal to\n            // the line (which is a plane but maximally aligned with the camera view.\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;\n          } else {\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::UniformFlow::Impl', [\n            // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',\n            // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',\n            '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements\n            ).result;\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',\n            // the code below is faster, but does not work on some devices\n            // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',\n            '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;\n          }\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    // replace common shader code\n    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);\n    let VSSource = shaders.Vertex;\n    let GSSource = shaders.Geometry;\n    let FSSource = shaders.Fragment;\n\n    // do we need the vertex in the shader in View Coordinates\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity > 0) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;\n      GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;\n    } else {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Geometry = GSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {\n    if (model.lastBoundBO.getCABO().getTCoordOffset()) {\n      let VSSource = shaders.Vertex;\n      let GSSource = shaders.Geometry;\n      let FSSource = shaders.Fragment;\n      if (model.drawingEdges) {\n        return;\n      }\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;\n\n      // we only handle the first texture by default\n      // additional textures are activated and we set the uniform\n      // for the texture unit they are assigned to, but you have to\n      // add in the shader code to do something with them\n      const tus = model.openGLActor.getActiveTextures();\n      let tNumComp = 2;\n      let tcdim = 2;\n      if (tus && tus.length > 0) {\n        tNumComp = tus[0].getComponents();\n        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {\n          tcdim = 3;\n        }\n      }\n      if (model.renderable.getColorTextureMap()) {\n        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();\n        tcdim = 2;\n      }\n      if (tcdim === 2) {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;\n        if (tus && tus.length >= 1) {\n          switch (tNumComp) {\n            case 1:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n              break;\n            case 2:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n              break;\n            default:\n              FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n          }\n        }\n      } else {\n        VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;\n        GSSource = vtkShaderProgram.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;\n        switch (tNumComp) {\n          case 1:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;\n            break;\n          case 2:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;\n            break;\n          default:\n            FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;\n        }\n      }\n      shaders.Vertex = VSSource;\n      shaders.Geometry = GSSource;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.replaceShaderClip = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n    let FSSource = shaders.Fragment;\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;\n    }\n    shaders.Vertex = VSSource;\n    shaders.Fragment = FSSource;\n  };\n  publicAPI.getCoincidentParameters = (ren, actor) => {\n    // 1. ResolveCoincidentTopology is On and non zero for this primitive\n    // type\n    let cp = {\n      factor: 0.0,\n      offset: 0.0\n    };\n    const prop = actor.getProperty();\n    if (\n    // backwards compat with code that (errorneously) set this to boolean\n    // eslint-disable-next-line eqeqeq\n    model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset || prop.getEdgeVisibility() && prop.getRepresentation() === Representation.SURFACE) {\n      const primType = model.lastBoundBO.getPrimitiveType();\n      if (primType === primTypes.Points || prop.getRepresentation() === Representation.POINTS) {\n        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();\n      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation.WIREFRAME) {\n        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();\n      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n      }\n      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {\n        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();\n        cp.factor /= 2.0;\n        cp.offset /= 2.0;\n      }\n    }\n\n    // hardware picking always offset due to saved zbuffer\n    // This gets you above the saved surface depth buffer.\n    const selector = model._openGLRenderer.getSelector();\n    if (selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      cp.offset -= 2.0;\n    }\n    return cp;\n  };\n  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {\n    let FSSource = shaders.Fragment;\n    let VSSource = shaders.Vertex;\n    FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;\n    if (!model._openGLRenderer.getSelector()) {\n      return;\n    }\n    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\\n', 'uniform int VertexIDOffset;\\n']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\\n').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;\n    }\n    switch (model.lastSelectionState) {\n      case PassTypes.ID_LOW24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;\n        break;\n      case PassTypes.ID_HIGH24:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);').result;\n        break;\n      default:\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;\n        FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;\n    }\n    shaders.Fragment = FSSource;\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.replaceShaderValues = (shaders, ren, actor) => {\n    publicAPI.replaceShaderColor(shaders, ren, actor);\n    publicAPI.replaceShaderNormal(shaders, ren, actor);\n    publicAPI.replaceShaderLight(shaders, ren, actor);\n    publicAPI.replaceShaderTCoord(shaders, ren, actor);\n    publicAPI.replaceShaderPicking(shaders, ren, actor);\n    publicAPI.replaceShaderClip(shaders, ren, actor);\n    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);\n    publicAPI.replaceShaderPositionVC(shaders, ren, actor);\n    if (model.haveSeenDepthRequest) {\n      let FSSource = shaders.Fragment;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;\n      FSSource = vtkShaderProgram.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;\n      shaders.Fragment = FSSource;\n    }\n  };\n  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {\n    let lightComplexity = 0;\n    let numberOfLights = 0;\n    const primType = cellBO.getPrimitiveType();\n    const poly = model.currentInput;\n\n    // different algo from C++ as of 5/2019\n    let needLighting = false;\n    const pointNormals = poly.getPointData().getNormals();\n    const cellNormals = poly.getCellData().getNormals();\n    const flat = actor.getProperty().getInterpolation() === Shading.FLAT;\n    const representation = actor.getProperty().getRepresentation();\n    const mode = cellBO.getOpenGLMode(representation, primType);\n    // 1) all surfaces need lighting\n    if (mode === model.context.TRIANGLES) {\n      needLighting = true;\n      // 2) all cell normals without point normals need lighting\n    } else if (cellNormals && !pointNormals) {\n      needLighting = true;\n      // 3) Phong + pointNormals need lighting\n    } else if (!flat && pointNormals) {\n      needLighting = true;\n      // 4) Phong Lines need lighting\n    } else if (!flat && mode === model.context.LINES) {\n      needLighting = true;\n    }\n    // 5) everything else is unlit\n\n    // do we need lighting?\n    if (actor.getProperty().getLighting() && needLighting) {\n      // consider the lighting complexity to determine which case applies\n      // simple headlight, Light Kit, the whole feature set of VTK\n      lightComplexity = 0;\n      const lights = ren.getLightsByReference();\n      for (let index = 0; index < lights.length; ++index) {\n        const light = lights[index];\n        const status = light.getSwitch();\n        if (status > 0) {\n          numberOfLights++;\n          if (lightComplexity === 0) {\n            lightComplexity = 1;\n          }\n        }\n        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {\n          lightComplexity = 2;\n        }\n        if (lightComplexity < 3 && light.getPositional()) {\n          lightComplexity = 3;\n        }\n      }\n    }\n    let needRebuild = false;\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');\n    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {\n      model.lastBoundBO.set({\n        lastLightComplexity: lightComplexity\n      }, true);\n      model.lastBoundBO.set({\n        lastLightCount: numberOfLights\n      }, true);\n      needRebuild = true;\n    }\n\n    // has the render pass shader replacement changed? Two options\n    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {\n      needRebuild = true;\n    }\n\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // light complexity changed\n    // render pass shader replacement changed\n    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {\n      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;\n      return true;\n    }\n    return false;\n  };\n  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {\n    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;\n    if (listCallbacks) {\n      listCallbacks.forEach(object => {\n        object.callback(object.userData, cellBO, ren, actor);\n      });\n    }\n  };\n  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {\n    // Now to update the VAO too, if necessary.\n    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {\n      cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);\n    }\n    if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {\n      cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);\n    }\n    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {\n      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting vertexMC in shader VAO.');\n        }\n      }\n      if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {\n          vtkErrorMacro('Error setting normalMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('normalMC');\n      }\n      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {\n        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {\n          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {\n            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);\n          }\n        }\n      });\n      if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {\n          vtkErrorMacro('Error setting tcoordMC in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('tcoordMC');\n      }\n      if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {\n        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {\n          vtkErrorMacro('Error setting scalarColor in shader VAO.');\n        }\n      } else {\n        cellBO.getVAO().removeAttributeArray('scalarColor');\n      }\n      cellBO.getAttributeUpdateTime().modified();\n    }\n    if (model.renderable.getNumberOfClippingPlanes()) {\n      // add all the clipping planes\n      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();\n      const planeEquations = [];\n      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n      const mat = inverseShiftScaleMatrix ? mat4.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();\n      if (inverseShiftScaleMatrix) {\n        mat4.transpose(mat, mat);\n        mat4.multiply(mat, mat, inverseShiftScaleMatrix);\n        mat4.transpose(mat, mat);\n      }\n      for (let i = 0; i < numClipPlanes; i++) {\n        const planeEquation = [];\n        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);\n        for (let j = 0; j < 4; j++) {\n          planeEquations.push(planeEquation[j]);\n        }\n      }\n      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);\n      cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);\n    }\n    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {\n      cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());\n    }\n    const tus = model.openGLActor.getActiveTextures();\n    if (tus) {\n      for (let index = 0; index < tus.length; ++index) {\n        const tex = tus[index];\n        const texUnit = tex.getTextureUnit();\n        const tname = `texture${texUnit + 1}`;\n        if (cellBO.getProgram().isUniformUsed(tname)) {\n          cellBO.getProgram().setUniformi(tname, texUnit);\n        }\n      }\n    }\n\n    // handle depth requests\n    if (model.haveSeenDepthRequest) {\n      cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);\n    }\n\n    // handle coincident\n    if (cellBO.getProgram().isUniformUsed('coffset')) {\n      const cp = publicAPI.getCoincidentParameters(ren, actor);\n      cellBO.getProgram().setUniformf('coffset', cp.offset);\n      // cfactor isn't always used when coffset is.\n      if (cellBO.getProgram().isUniformUsed('cfactor')) {\n        cellBO.getProgram().setUniformf('cfactor', cp.factor);\n      }\n    }\n\n    // handle wide lines\n    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());\n    const selector = model._openGLRenderer.getSelector();\n    cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);\n    cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);\n  };\n  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {\n    // for unlit and headlight there are no lighting parameters\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 2) {\n      return;\n    }\n    const program = cellBO.getProgram();\n\n    // bind some light settings\n    let numberOfLights = 0;\n    const lights = ren.getLightsByReference();\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const dColor = light.getColorByReference();\n        const intensity = light.getIntensity();\n        model.lightColor[0] = dColor[0] * intensity;\n        model.lightColor[1] = dColor[1] * intensity;\n        model.lightColor[2] = dColor[2] * intensity;\n        // get required info from light\n        const ld = light.getDirection();\n        const transform = ren.getActiveCamera().getViewMatrix();\n        const newLightDirection = [...ld];\n        if (light.lightTypeIsSceneLight()) {\n          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];\n          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];\n          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];\n          normalize(newLightDirection);\n        }\n        model.lightDirection[0] = newLightDirection[0];\n        model.lightDirection[1] = newLightDirection[1];\n        model.lightDirection[2] = newLightDirection[2];\n        normalize(model.lightDirection);\n        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);\n        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);\n        numberOfLights++;\n      }\n    }\n\n    // we are done unless we have positional lights\n    if (lastLightComplexity < 3) {\n      return;\n    }\n\n    // for lightkit case there are some parameters to set\n    const cam = ren.getActiveCamera();\n    const viewTF = cam.getViewMatrix();\n    mat4.transpose(viewTF, viewTF);\n    numberOfLights = 0;\n    for (let index = 0; index < lights.length; ++index) {\n      const light = lights[index];\n      const status = light.getSwitch();\n      if (status > 0.0) {\n        const lp = light.getTransformedPosition();\n        const np = new Float64Array(3);\n        vec3.transformMat4(np, lp, viewTF);\n        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());\n        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());\n        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());\n        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());\n        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);\n        numberOfLights++;\n      }\n    }\n  };\n  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {\n    matrixType.identity(tmpMat);\n    return matrixArray.reduce((res, matrix, index) => {\n      if (index === 0) {\n        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);\n      }\n      return matrix ? matrixType.multiply(res, res, matrix) : res;\n    }, tmpMat);\n  }\n  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n\n    // [WMVP]C == {world, model, view, projection} coordinates\n    // E.g., WCPC == world to projection coordinate transformation\n    const keyMats = model.openGLCamera.getKeyMatrices(ren);\n    const cam = ren.getActiveCamera();\n    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();\n    const progm = program.getLastCameraMTime();\n    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();\n    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;\n    const actorIsIdentity = actor.getIsIdentity();\n    const actMats = actorIsIdentity ? {\n      mcwc: null,\n      normalMatrix: null\n    } : model.openGLActor.getKeyMatrices();\n    if (actor.getCoordinateSystem() === CoordinateSystem.DISPLAY) {\n      const size = model._openGLRenderer.getTiledSizeAndOrigin();\n      mat4.identity(model.tmpMat4);\n      model.tmpMat4[0] = 2.0 / size.usize;\n      model.tmpMat4[12] = -1.0;\n      model.tmpMat4[5] = 2.0 / size.vsize;\n      model.tmpMat4[13] = -1.0;\n      mat4.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);\n      program.setUniformMatrix('MCPCMatrix', model.tmpMat4);\n    } else {\n      program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('MCVCMatrix')) {\n      program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));\n    }\n    if (program.isUniformUsed('normalMatrix')) {\n      program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3, model.tmpMat3));\n    }\n    if (progm !== camm) {\n      if (program.isUniformUsed('cameraParallel')) {\n        program.setUniformi('cameraParallel', cam.getParallelProjection());\n      }\n      program.setLastCameraMTime(camm);\n    }\n    if (!actorIsIdentity) {\n      // reset the cam mtime as actor modified the shader values\n      program.setLastCameraMTime(0);\n    }\n  };\n  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {\n    const program = cellBO.getProgram();\n    let ppty = actor.getProperty();\n    let opacity = ppty.getOpacity();\n    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();\n    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();\n    let aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();\n    let dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();\n    let sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();\n    const specularPower = ppty.getSpecularPower();\n    program.setUniformf('opacityUniform', opacity);\n    program.setUniform3fArray('ambientColorUniform', aColor);\n    program.setUniform3fArray('diffuseColorUniform', dColor);\n    program.setUniformf('ambient', aIntensity);\n    program.setUniformf('diffuse', dIntensity);\n\n    // we are done unless we have lighting\n    const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');\n    if (lastLightComplexity < 1) {\n      return;\n    }\n    let sColor = ppty.getSpecularColorByReference();\n    program.setUniform3fArray('specularColorUniform', sColor);\n    program.setUniformf('specularPowerUniform', specularPower);\n    program.setUniformf('specular', sIntensity);\n\n    // now set the backface properties if we have them\n    if (program.isUniformUsed('ambientIntensityBF')) {\n      ppty = actor.getBackfaceProperty();\n      opacity = ppty.getOpacity();\n      aColor = ppty.getAmbientColor();\n      aIntensity = ppty.getAmbient();\n      dColor = ppty.getDiffuseColor();\n      dIntensity = ppty.getDiffuse();\n      sColor = ppty.getSpecularColor();\n      sIntensity = ppty.getSpecular();\n      program.setUniformf('ambientIntensityBF', aIntensity);\n      program.setUniformf('diffuseIntensityBF', dIntensity);\n      program.setUniformf('opacityUniformBF', opacity);\n      program.setUniform3fArray('ambientColorUniformBF', aColor);\n      program.setUniform3fArray('diffuseColorUniformBF', dColor);\n\n      // we are done unless we have lighting\n      if (lastLightComplexity < 1) {\n        return;\n      }\n      program.setUniformf('specularIntensityBF', sIntensity);\n      program.setUniform3fArray('specularColorUniformBF', sColor);\n      program.setUniformf('specularPowerUniformBF', specularPower);\n    }\n  };\n  publicAPI.updateMaximumPointCellIds = (ren, actor) => {\n    const selector = model._openGLRenderer.getSelector();\n    if (!selector) {\n      return;\n    }\n    if (model.selectionWebGLIdsToVTKIds?.points?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.points.length;\n      selector.setMaximumPointId(length - 1);\n    }\n    if (model.selectionWebGLIdsToVTKIds?.cells?.length) {\n      const length = model.selectionWebGLIdsToVTKIds.cells.length;\n      selector.setMaximumCellId(length - 1);\n    }\n    const fieldAssociation = selector.getFieldAssociation();\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      model.pointPicking = true;\n    }\n  };\n  publicAPI.renderPieceStart = (ren, actor) => {\n    model.primitiveIDOffset = 0;\n    model.vertexIDOffset = 0;\n    const picking = getPickState(model._openGLRenderer);\n    if (model.lastSelectionState !== picking) {\n      model.selectionStateChanged.modified();\n      model.lastSelectionState = picking;\n    }\n    if (model._openGLRenderer.getSelector()) {\n      switch (picking) {\n        default:\n          model._openGLRenderer.getSelector().renderProp(actor);\n      }\n    }\n\n    // make sure the BOs are up to date\n    publicAPI.updateBufferObjects(ren, actor);\n\n    // If we are coloring by texture, then load the texture map.\n    // Use Map as indicator, because texture hangs around.\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.activate();\n    }\n\n    // Bind the OpenGL, this is shared between the different primitive/cell types.\n    model.lastBoundBO = null;\n  };\n  publicAPI.renderPieceDraw = (ren, actor) => {\n    const representation = actor.getProperty().getRepresentation();\n    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n    const selector = model._openGLRenderer.getSelector();\n    // If we are picking points, we need to tell it to the helper\n    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24);\n\n    // for every primitive type\n    for (let i = primTypes.Start; i < primTypes.End; i++) {\n      model.primitives[i].setPointPicking(pointPicking);\n      const cabo = model.primitives[i].getCABO();\n      if (cabo.getElementCount()) {\n        // are we drawing edges\n        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);\n        // don't draw edges when rendering depth or rendering for picking\n        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {\n          model.lastBoundBO = model.primitives[i];\n          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);\n          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();\n        }\n      }\n    }\n  };\n  publicAPI.renderPieceFinish = (ren, actor) => {\n    if (model.LastBoundBO) {\n      model.LastBoundBO.getVAO().release();\n    }\n    if (model.renderable.getColorTextureMap()) {\n      model.internalColorTexture.deactivate();\n    }\n  };\n  publicAPI.renderPiece = (ren, actor) => {\n    // Make sure that we have been properly initialized.\n    // if (ren.getRenderWindow().checkAbortStatus()) {\n    //   return;\n    // }\n\n    publicAPI.invokeEvent(StartEvent);\n    if (!model.renderable.getStatic()) {\n      model.renderable.update();\n    }\n    model.currentInput = model.renderable.getInputData();\n    publicAPI.invokeEvent(EndEvent);\n    if (!model.currentInput) {\n      vtkErrorMacro('No input!');\n      return;\n    }\n\n    // if there are no points then we are done\n    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {\n      return;\n    }\n\n    // apply faceCulling\n    const gl = model.context;\n    const backfaceCulling = actor.getProperty().getBackfaceCulling();\n    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();\n    if (!backfaceCulling && !frontfaceCulling) {\n      model._openGLRenderWindow.disableCullFace();\n    } else if (frontfaceCulling) {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.FRONT);\n    } else {\n      model._openGLRenderWindow.enableCullFace();\n      gl.cullFace(gl.BACK);\n    }\n    publicAPI.renderPieceStart(ren, actor);\n    publicAPI.renderPieceDraw(ren, actor);\n    publicAPI.renderPieceFinish(ren, actor);\n  };\n  publicAPI.computeBounds = (ren, actor) => {\n    if (!publicAPI.getInput()) {\n      uninitializeBounds(model.bounds);\n      return;\n    }\n    model.bounds = publicAPI.getInput().getBounds();\n  };\n  publicAPI.updateBufferObjects = (ren, actor) => {\n    // Rebuild buffers if needed\n    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {\n      publicAPI.buildBufferObjects(ren, actor);\n    }\n    // Always call this function as the selector can change\n    publicAPI.updateMaximumPointCellIds();\n  };\n  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {\n    // first do a coarse check\n    // Note that the actor's mtime includes it's properties mtime\n    const vmtime = model.VBOBuildTime.getMTime();\n    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.buildBufferObjects = (ren, actor) => {\n    const poly = model.currentInput;\n    if (poly === null) {\n      return;\n    }\n    model.renderable.mapScalars(poly, 1.0);\n    const c = model.renderable.getColorMapColors();\n    model.haveCellScalars = false;\n    const scalarMode = model.renderable.getScalarMode();\n    if (model.renderable.getScalarVisibility()) {\n      // We must figure out how the scalars should be mapped to the polydata.\n      if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {\n        model.haveCellScalars = true;\n      }\n    }\n\n    // Do we have normals?\n    let n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;\n    if (n === null && poly.getCellData().getNormals()) {\n      model.haveCellNormals = true;\n      n = poly.getCellData().getNormals();\n    }\n\n    // rebuild the VBO if the data has changed we create a string for the VBO what\n    // can change the VBO? points normals tcoords colors so what can change those?\n    // the input data is clearly one as it can change all four items tcoords may\n    // haveTextures or not colors may change based on quite a few mapping\n    // parameters in the mapper\n\n    const representation = actor.getProperty().getRepresentation();\n    let tcoords = poly.getPointData().getTCoords();\n    if (!model.openGLActor.getActiveTextures()) {\n      tcoords = null;\n    }\n\n    // Flag to check if tcoords are per cell instead of per point\n    let useTCoordsPerCell = false;\n    // handle color mapping via texture\n    if (model.renderable.getColorCoordinates()) {\n      tcoords = model.renderable.getColorCoordinates();\n      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();\n      if (!model.internalColorTexture) {\n        model.internalColorTexture = vtkOpenGLTexture.newInstance({\n          resizable: true\n        });\n      }\n      const tex = model.internalColorTexture;\n      // the following 4 lines allow for NPOT textures\n      tex.setMinificationFilter(Filter.NEAREST);\n      tex.setMagnificationFilter(Filter.NEAREST);\n      tex.setWrapS(Wrap.CLAMP_TO_EDGE);\n      tex.setWrapT(Wrap.CLAMP_TO_EDGE);\n      tex.setOpenGLRenderWindow(model._openGLRenderWindow);\n      const input = model.renderable.getColorTextureMap();\n      const ext = input.getExtent();\n      const inScalars = input.getPointData().getScalars();\n      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n      tex.activate();\n      tex.sendParameters();\n      tex.deactivate();\n    }\n    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}` + `E${actor.getProperty().getEdgeVisibility()}` + `F${tcoords ? tcoords.getMTime() : 1}`;\n    if (model.VBOBuildString !== toString) {\n      // Build the VBOs\n      const points = poly.getPoints();\n      const options = {\n        points,\n        normals: n,\n        tcoords,\n        colors: c,\n        cellOffset: 0,\n        vertexOffset: 0,\n        // Used to keep track of vertex ids across primitives for selection\n        useTCoordsPerCell,\n        haveCellScalars: model.haveCellScalars,\n        haveCellNormals: model.haveCellNormals,\n        customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))\n      };\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.selectionWebGLIdsToVTKIds = {\n          points: null,\n          cells: null\n        };\n      }\n      const primitives = [{\n        inRep: 'verts',\n        cells: poly.getVerts()\n      }, {\n        inRep: 'lines',\n        cells: poly.getLines()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }, {\n        inRep: 'polys',\n        cells: poly.getPolys()\n      }, {\n        inRep: 'strips',\n        cells: poly.getStrips()\n      }];\n      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation.SURFACE;\n      for (let i = primTypes.Start; i < primTypes.End; i++) {\n        if (i !== primTypes.TrisEdges && i !== primTypes.TriStripsEdges) {\n          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);\n          options.vertexOffset += model.primitives[i].getCABO().getElementCount();\n        } else {\n          // if we have edge visibility build the edge VBOs\n          if (drawSurfaceWithEdges) {\n            // VBOs for edges in \"surface with edges\" are the last to be built,\n            // they are not used when picking with a hardware selector so they\n            // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset\n            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation.WIREFRAME, {\n              ...options,\n              tcoords: null,\n              colors: null,\n              haveCellScalars: false,\n              haveCellNormals: false\n            });\n          } else {\n            // otherwise free them\n            model.primitives[i].releaseGraphicsResources();\n          }\n        }\n      }\n      if (model.renderable.getPopulateSelectionSettings()) {\n        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);\n      }\n      model.VBOBuildString = toString;\n    }\n    model.VBOBuildTime.modified();\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => {\n    let memUsed = 0;\n    model.primitives.forEach(prim => {\n      memUsed += prim.getAllocatedGPUMemoryInBytes();\n    });\n    // Return in MB\n    return memUsed;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  VBOBuildTime: 0,\n  VBOBuildString: null,\n  primitives: null,\n  primTypes: null,\n  shaderRebuildString: null,\n  tmpMat4: null,\n  ambientColor: [],\n  // used internally\n  diffuseColor: [],\n  // used internally\n  specularColor: [],\n  // used internally\n  lightColor: [],\n  // used internally\n  lightDirection: [],\n  // used internally\n  lastHaveSeenDepthRequest: false,\n  haveSeenDepthRequest: false,\n  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,\n  selectionStateChanged: null,\n  selectionWebGLIdsToVTKIds: null,\n  pointPicking: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);\n  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);\n  model.primitives = [];\n  model.primTypes = primTypes;\n  model.tmpMat3 = mat3.identity(new Float64Array(9));\n  model.tmpMat4 = mat4.identity(new Float64Array(16));\n  for (let i = primTypes.Start; i < primTypes.End; i++) {\n    model.primitives[i] = vtkHelper.newInstance();\n    model.primitives[i].setPrimitiveType(i);\n    model.primitives[i].set({\n      lastLightComplexity: 0,\n      lastLightCount: 0,\n      lastSelectionPass: false\n    }, true);\n  }\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  model.VBOBuildTime = {};\n  obj(model.VBOBuildTime, {\n    mtime: 0\n  });\n  model.selectionStateChanged = {};\n  obj(model.selectionStateChanged, {\n    mtime: 0\n  });\n\n  // Object methods\n  vtkOpenGLPolyDataMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLPolyDataMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLPolyDataMapper$1 = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkMapper', newInstance);\n\nexport { vtkOpenGLPolyDataMapper$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}