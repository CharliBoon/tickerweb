{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { n as newInstance$1, o as obj, g as get, e as setGet } from '../../macros2.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\n\n// methods we forward to the handle\nconst forwarded = ['setBindGroup', 'setIndexBuffer', 'setVertexBuffer', 'draw', 'drawIndexed'];\n\n// ----------------------------------------------------------------------------\n// vtkWebGPURenderEncoder methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPURenderEncoder(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPURenderEncoder');\n  publicAPI.begin = encoder => {\n    model.drawCallbacks = [];\n    model.handle = encoder.beginRenderPass(model.description);\n    if (model.label) {\n      model.handle.pushDebugGroup(model.label);\n    }\n  };\n  publicAPI.end = () => {\n    // loop over registered pipelines and their callbacks\n    for (let i = 0; i < model.drawCallbacks.length; i++) {\n      const pStruct = model.drawCallbacks[i];\n      const pl = pStruct.pipeline;\n      publicAPI.setPipeline(pl);\n      for (let cb = 0; cb < pStruct.callbacks.length; cb++) {\n        pStruct.callbacks[cb](publicAPI);\n      }\n    }\n    if (model.label) {\n      model.handle.popDebugGroup();\n    }\n    model.handle.end();\n    model.boundPipeline = null;\n  };\n  publicAPI.setPipeline = pl => {\n    if (model.boundPipeline === pl) {\n      return;\n    }\n    model.handle.setPipeline(pl.getHandle());\n    const pd = pl.getPipelineDescription();\n\n    // check attachment state\n    if (model.colorTextureViews.length !== pd.fragment.targets.length) {\n      console.log(`mismatched attachment counts on pipeline ${pd.fragment.targets.length} while encoder has ${model.colorTextureViews.length}`);\n      console.trace();\n    } else {\n      for (let i = 0; i < model.colorTextureViews.length; i++) {\n        const fmt = model.colorTextureViews[i].getTexture()?.getFormat();\n        if (fmt && fmt !== pd.fragment.targets[i].format) {\n          console.log(`mismatched attachments for attachment ${i} on pipeline ${pd.fragment.targets[i].format} while encoder has ${fmt}`);\n          console.trace();\n        }\n      }\n    }\n\n    // check depth buffer\n    if (!model.depthTextureView !== !('depthStencil' in pd)) {\n      console.log('mismatched depth attachments');\n      console.trace();\n    } else if (model.depthTextureView) {\n      const dfmt = model.depthTextureView.getTexture()?.getFormat();\n      if (dfmt && dfmt !== pd.depthStencil.format) {\n        console.log(`mismatched depth attachments on pipeline ${pd.depthStencil.format} while encoder has ${dfmt}`);\n        console.trace();\n      }\n    }\n    model.boundPipeline = pl;\n  };\n  publicAPI.replaceShaderCode = pipeline => {\n    model.replaceShaderCodeFunction(pipeline);\n  };\n  publicAPI.setColorTextureView = (idx, view) => {\n    if (model.colorTextureViews[idx] === view) {\n      return;\n    }\n    model.colorTextureViews[idx] = view;\n  };\n  publicAPI.activateBindGroup = bg => {\n    const device = model.boundPipeline.getDevice();\n    const midx = model.boundPipeline.getBindGroupLayoutCount(bg.getLabel());\n    model.handle.setBindGroup(midx, bg.getBindGroup(device));\n    // verify bind group layout matches\n    const bgl1 = device.getBindGroupLayoutDescription(bg.getBindGroupLayout(device));\n    const bgl2 = device.getBindGroupLayoutDescription(model.boundPipeline.getBindGroupLayout(midx));\n    if (bgl1 !== bgl2) {\n      console.log(`renderEncoder ${model.pipelineHash} mismatched bind group layouts bind group has\\n${bgl1}\\n versus pipeline\\n${bgl2}\\n`);\n      console.trace();\n    }\n  };\n  publicAPI.attachTextureViews = () => {\n    // for each texture create a view if we do not already have one\n    for (let i = 0; i < model.colorTextureViews.length; i++) {\n      if (!model.description.colorAttachments[i]) {\n        model.description.colorAttachments[i] = {\n          view: model.colorTextureViews[i].getHandle()\n        };\n      } else {\n        model.description.colorAttachments[i].view = model.colorTextureViews[i].getHandle();\n      }\n    }\n    if (model.depthTextureView) {\n      model.description.depthStencilAttachment.view = model.depthTextureView.getHandle();\n    }\n  };\n\n  // register pipeline callbacks from a mapper\n  publicAPI.registerDrawCallback = (pipeline, cb) => {\n    // if there is a matching pipeline just add the cb\n    for (let i = 0; i < model.drawCallbacks.length; i++) {\n      if (model.drawCallbacks[i].pipeline === pipeline) {\n        model.drawCallbacks[i].callbacks.push(cb);\n        return;\n      }\n    }\n    model.drawCallbacks.push({\n      pipeline,\n      callbacks: [cb]\n    });\n  };\n\n  // simple forwarders\n  for (let i = 0; i < forwarded.length; i++) {\n    publicAPI[forwarded[i]] = function () {\n      return model.handle[forwarded[i]](...arguments);\n    };\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  description: null,\n  handle: null,\n  boundPipeline: null,\n  pipelineHash: null,\n  pipelineSettings: null,\n  replaceShaderCodeFunction: null,\n  depthTextureView: null,\n  label: null\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  obj(publicAPI, model);\n  model.description = {\n    colorAttachments: [{\n      view: undefined,\n      loadOp: 'load',\n      storeOp: 'store'\n    }],\n    depthStencilAttachment: {\n      view: undefined,\n      depthLoadOp: 'clear',\n      depthClearValue: 0.0,\n      depthStoreOp: 'store'\n    }\n  };\n\n  // default shader code just writes out the computedColor\n  model.replaceShaderCodeFunction = pipeline => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addOutput('vec4<f32>', 'outColor');\n    let code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::RenderEncoder::Impl', ['output.outColor = computedColor;']).result;\n    fDesc.setCode(code);\n  };\n\n  // default pipeline settings\n  model.pipelineSettings = {\n    primitive: {\n      cullMode: 'none'\n    },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'greater-equal',\n      format: 'depth32float'\n    },\n    fragment: {\n      targets: [{\n        format: 'rgba16float',\n        blend: {\n          color: {\n            srcFactor: 'src-alpha',\n            dstFactor: 'one-minus-src-alpha'\n          },\n          alpha: {\n            srcfactor: 'one',\n            dstFactor: 'one-minus-src-alpha'\n          }\n        }\n      }]\n    }\n  };\n  model.colorTextureViews = [];\n  get(publicAPI, model, ['boundPipeline', 'colorTextureViews']);\n  setGet(publicAPI, model, ['depthTextureView', 'description', 'handle', 'label', 'pipelineHash', 'pipelineSettings', 'replaceShaderCodeFunction']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPURenderEncoder(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nconst newInstance = newInstance$1(extend, 'vtkWebGPURenderEncoder');\n\n// ----------------------------------------------------------------------------\nvar vtkWebGPURenderEncoder$1 = {\n  newInstance,\n  extend\n};\nexport { vtkWebGPURenderEncoder$1 as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","o","obj","g","get","e","setGet","vtkWebGPUShaderCache","forwarded","vtkWebGPURenderEncoder","publicAPI","model","classHierarchy","push","begin","encoder","drawCallbacks","handle","beginRenderPass","description","label","pushDebugGroup","end","i","length","pStruct","pl","pipeline","setPipeline","cb","callbacks","popDebugGroup","boundPipeline","getHandle","pd","getPipelineDescription","colorTextureViews","fragment","targets","console","log","trace","fmt","getTexture","getFormat","format","depthTextureView","dfmt","depthStencil","replaceShaderCode","replaceShaderCodeFunction","setColorTextureView","idx","view","activateBindGroup","bg","device","getDevice","midx","getBindGroupLayoutCount","getLabel","setBindGroup","getBindGroup","bgl1","getBindGroupLayoutDescription","getBindGroupLayout","bgl2","pipelineHash","attachTextureViews","colorAttachments","depthStencilAttachment","registerDrawCallback","arguments","DEFAULT_VALUES","pipelineSettings","extend","initialValues","undefined","Object","assign","loadOp","storeOp","depthLoadOp","depthClearValue","depthStoreOp","fDesc","getShaderDescription","addOutput","code","getCode","substitute","result","setCode","primitive","cullMode","depthWriteEnabled","depthCompare","blend","color","srcFactor","dstFactor","alpha","srcfactor","newInstance","vtkWebGPURenderEncoder$1","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderEncoder.js"],"sourcesContent":["import { n as newInstance$1, o as obj, g as get, e as setGet } from '../../macros2.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\n\n// methods we forward to the handle\nconst forwarded = ['setBindGroup', 'setIndexBuffer', 'setVertexBuffer', 'draw', 'drawIndexed'];\n\n// ----------------------------------------------------------------------------\n// vtkWebGPURenderEncoder methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPURenderEncoder(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPURenderEncoder');\n  publicAPI.begin = encoder => {\n    model.drawCallbacks = [];\n    model.handle = encoder.beginRenderPass(model.description);\n    if (model.label) {\n      model.handle.pushDebugGroup(model.label);\n    }\n  };\n  publicAPI.end = () => {\n    // loop over registered pipelines and their callbacks\n    for (let i = 0; i < model.drawCallbacks.length; i++) {\n      const pStruct = model.drawCallbacks[i];\n      const pl = pStruct.pipeline;\n      publicAPI.setPipeline(pl);\n      for (let cb = 0; cb < pStruct.callbacks.length; cb++) {\n        pStruct.callbacks[cb](publicAPI);\n      }\n    }\n    if (model.label) {\n      model.handle.popDebugGroup();\n    }\n    model.handle.end();\n    model.boundPipeline = null;\n  };\n  publicAPI.setPipeline = pl => {\n    if (model.boundPipeline === pl) {\n      return;\n    }\n    model.handle.setPipeline(pl.getHandle());\n    const pd = pl.getPipelineDescription();\n\n    // check attachment state\n    if (model.colorTextureViews.length !== pd.fragment.targets.length) {\n      console.log(`mismatched attachment counts on pipeline ${pd.fragment.targets.length} while encoder has ${model.colorTextureViews.length}`);\n      console.trace();\n    } else {\n      for (let i = 0; i < model.colorTextureViews.length; i++) {\n        const fmt = model.colorTextureViews[i].getTexture()?.getFormat();\n        if (fmt && fmt !== pd.fragment.targets[i].format) {\n          console.log(`mismatched attachments for attachment ${i} on pipeline ${pd.fragment.targets[i].format} while encoder has ${fmt}`);\n          console.trace();\n        }\n      }\n    }\n\n    // check depth buffer\n    if (!model.depthTextureView !== !('depthStencil' in pd)) {\n      console.log('mismatched depth attachments');\n      console.trace();\n    } else if (model.depthTextureView) {\n      const dfmt = model.depthTextureView.getTexture()?.getFormat();\n      if (dfmt && dfmt !== pd.depthStencil.format) {\n        console.log(`mismatched depth attachments on pipeline ${pd.depthStencil.format} while encoder has ${dfmt}`);\n        console.trace();\n      }\n    }\n    model.boundPipeline = pl;\n  };\n  publicAPI.replaceShaderCode = pipeline => {\n    model.replaceShaderCodeFunction(pipeline);\n  };\n  publicAPI.setColorTextureView = (idx, view) => {\n    if (model.colorTextureViews[idx] === view) {\n      return;\n    }\n    model.colorTextureViews[idx] = view;\n  };\n  publicAPI.activateBindGroup = bg => {\n    const device = model.boundPipeline.getDevice();\n    const midx = model.boundPipeline.getBindGroupLayoutCount(bg.getLabel());\n    model.handle.setBindGroup(midx, bg.getBindGroup(device));\n    // verify bind group layout matches\n    const bgl1 = device.getBindGroupLayoutDescription(bg.getBindGroupLayout(device));\n    const bgl2 = device.getBindGroupLayoutDescription(model.boundPipeline.getBindGroupLayout(midx));\n    if (bgl1 !== bgl2) {\n      console.log(`renderEncoder ${model.pipelineHash} mismatched bind group layouts bind group has\\n${bgl1}\\n versus pipeline\\n${bgl2}\\n`);\n      console.trace();\n    }\n  };\n  publicAPI.attachTextureViews = () => {\n    // for each texture create a view if we do not already have one\n    for (let i = 0; i < model.colorTextureViews.length; i++) {\n      if (!model.description.colorAttachments[i]) {\n        model.description.colorAttachments[i] = {\n          view: model.colorTextureViews[i].getHandle()\n        };\n      } else {\n        model.description.colorAttachments[i].view = model.colorTextureViews[i].getHandle();\n      }\n    }\n    if (model.depthTextureView) {\n      model.description.depthStencilAttachment.view = model.depthTextureView.getHandle();\n    }\n  };\n\n  // register pipeline callbacks from a mapper\n  publicAPI.registerDrawCallback = (pipeline, cb) => {\n    // if there is a matching pipeline just add the cb\n    for (let i = 0; i < model.drawCallbacks.length; i++) {\n      if (model.drawCallbacks[i].pipeline === pipeline) {\n        model.drawCallbacks[i].callbacks.push(cb);\n        return;\n      }\n    }\n    model.drawCallbacks.push({\n      pipeline,\n      callbacks: [cb]\n    });\n  };\n\n  // simple forwarders\n  for (let i = 0; i < forwarded.length; i++) {\n    publicAPI[forwarded[i]] = function () {\n      return model.handle[forwarded[i]](...arguments);\n    };\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  description: null,\n  handle: null,\n  boundPipeline: null,\n  pipelineHash: null,\n  pipelineSettings: null,\n  replaceShaderCodeFunction: null,\n  depthTextureView: null,\n  label: null\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  obj(publicAPI, model);\n  model.description = {\n    colorAttachments: [{\n      view: undefined,\n      loadOp: 'load',\n      storeOp: 'store'\n    }],\n    depthStencilAttachment: {\n      view: undefined,\n      depthLoadOp: 'clear',\n      depthClearValue: 0.0,\n      depthStoreOp: 'store'\n    }\n  };\n\n  // default shader code just writes out the computedColor\n  model.replaceShaderCodeFunction = pipeline => {\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addOutput('vec4<f32>', 'outColor');\n    let code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::RenderEncoder::Impl', ['output.outColor = computedColor;']).result;\n    fDesc.setCode(code);\n  };\n\n  // default pipeline settings\n  model.pipelineSettings = {\n    primitive: {\n      cullMode: 'none'\n    },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'greater-equal',\n      format: 'depth32float'\n    },\n    fragment: {\n      targets: [{\n        format: 'rgba16float',\n        blend: {\n          color: {\n            srcFactor: 'src-alpha',\n            dstFactor: 'one-minus-src-alpha'\n          },\n          alpha: {\n            srcfactor: 'one',\n            dstFactor: 'one-minus-src-alpha'\n          }\n        }\n      }]\n    }\n  };\n  model.colorTextureViews = [];\n  get(publicAPI, model, ['boundPipeline', 'colorTextureViews']);\n  setGet(publicAPI, model, ['depthTextureView', 'description', 'handle', 'label', 'pipelineHash', 'pipelineSettings', 'replaceShaderCodeFunction']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPURenderEncoder(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nconst newInstance = newInstance$1(extend, 'vtkWebGPURenderEncoder');\n\n// ----------------------------------------------------------------------------\nvar vtkWebGPURenderEncoder$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPURenderEncoder$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}