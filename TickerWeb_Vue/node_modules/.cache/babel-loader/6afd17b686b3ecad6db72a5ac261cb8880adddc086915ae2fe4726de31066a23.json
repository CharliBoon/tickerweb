{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkCellTypes from '../../Common/DataModel/CellTypes.js';\nimport vtkLine from '../../Common/DataModel/Line.js';\nimport vtkPicker from './Picker.js';\nimport vtkPolyLine from '../../Common/DataModel/PolyLine.js';\nimport vtkTriangle from '../../Common/DataModel/Triangle.js';\nimport vtkQuad from '../../Common/DataModel/Quad.js';\nimport { l as normalize, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport { CellType } from '../../Common/DataModel/CellTypes/Constants.js';\nimport { vec3, vec4 } from 'gl-matrix';\nimport vtkBox from '../../Common/DataModel/Box.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction createCellMap() {\n  return {\n    [CellType.VTK_LINE]: vtkLine.newInstance(),\n    [CellType.VTK_POLY_LINE]: vtkPolyLine.newInstance(),\n    [CellType.VTK_TRIANGLE]: vtkTriangle.newInstance(),\n    [CellType.VTK_QUAD]: vtkQuad.newInstance()\n  };\n}\nfunction clipLineWithPlane(mapper, matrix, p1, p2) {\n  const outObj = {\n    planeId: -1,\n    t1: 0.0,\n    t2: 1.0,\n    intersect: 0\n  };\n  const nbClippingPlanes = mapper.getNumberOfClippingPlanes();\n  const plane = [];\n  for (let i = 0; i < nbClippingPlanes; i++) {\n    mapper.getClippingPlaneInDataCoords(matrix, i, plane);\n    const d1 = plane[0] * p1[0] + plane[1] * p1[1] + plane[2] * p1[2] + plane[3];\n    const d2 = plane[0] * p2[0] + plane[1] * p2[1] + plane[2] * p2[2] + plane[3];\n\n    // If both distances are negative, both points are outside\n    if (d1 < 0 && d2 < 0) {\n      return 0;\n    }\n    if (d1 < 0 || d2 < 0) {\n      // If only one of the distances is negative, the line crosses the plane\n      // Compute fractional distance \"t\" of the crossing between p1 & p2\n      let t = 0.0;\n\n      // The \"if\" here just avoids an expensive division when possible\n      if (d1 !== 0) {\n        // We will never have d1==d2 since they have different signs\n        t = d1 / (d1 - d2);\n      }\n\n      // If point p1 was clipped, adjust t1\n      if (d1 < 0) {\n        if (t >= outObj.t1) {\n          outObj.t1 = t;\n          outObj.planeId = i;\n        }\n      } else if (t <= outObj.t2) {\n        // else point p2 was clipped, so adjust t2\n        outObj.t2 = t;\n      }\n      // If this happens, there's no line left\n      if (outObj.t1 > outObj.t2) {\n        outObj.intersect = 0;\n        return outObj;\n      }\n    }\n  }\n  outObj.intersect = 1;\n  return outObj;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  clipLineWithPlane\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellPicker');\n  const superClass = {\n    ...publicAPI\n  };\n  function resetCellPickerInfo() {\n    model.cellId = -1;\n    model.pCoords[0] = 0.0;\n    model.pCoords[1] = 0.0;\n    model.pCoords[2] = 0.0;\n    model.cellIJK[0] = 0.0;\n    model.cellIJK[1] = 0.0;\n    model.cellIJK[2] = 0.0;\n    model.mapperNormal[0] = 0.0;\n    model.mapperNormal[1] = 0.0;\n    model.mapperNormal[2] = 1.0;\n    model.pickNormal[0] = 0.0;\n    model.pickNormal[1] = 0.0;\n    model.pickNormal[2] = 1.0;\n  }\n  function resetPickInfo() {\n    model.dataSet = null;\n    model.mapper = null;\n    resetCellPickerInfo();\n  }\n  publicAPI.initialize = () => {\n    resetPickInfo();\n    superClass.initialize();\n  };\n  publicAPI.computeSurfaceNormal = (data, cell, weights, normal) => {\n    const normals = data.getPointData().getNormals();\n    if (normals) {\n      normal[0] = 0.0;\n      normal[1] = 0.0;\n      normal[2] = 0.0;\n      const pointNormal = [];\n      for (let i = 0; i < 3; i++) {\n        normals.getTuple(cell.getPointsIds()[i], pointNormal);\n        normal[0] += pointNormal[0] * weights[i];\n        normal[1] += pointNormal[1] * weights[i];\n        normal[2] += pointNormal[2] * weights[i];\n      }\n      normalize(normal);\n    } else {\n      return 0;\n    }\n    return 1;\n  };\n  publicAPI.pick = (selection, renderer) => {\n    publicAPI.initialize();\n    const pickResult = superClass.pick(selection, renderer);\n    if (pickResult) {\n      const camera = renderer.getActiveCamera();\n      const cameraPos = [];\n      camera.getPosition(cameraPos);\n      if (camera.getParallelProjection()) {\n        // For parallel projection, use -ve direction of projection\n        const cameraFocus = [];\n        camera.getFocalPoint(cameraFocus);\n        model.pickNormal[0] = cameraPos[0] - cameraFocus[0];\n        model.pickNormal[1] = cameraPos[1] - cameraFocus[1];\n        model.pickNormal[2] = cameraPos[2] - cameraFocus[2];\n      } else {\n        // Get the vector from pick position to the camera\n        model.pickNormal[0] = cameraPos[0] - model.pickPosition[0];\n        model.pickNormal[1] = cameraPos[1] - model.pickPosition[1];\n        model.pickNormal[2] = cameraPos[2] - model.pickPosition[2];\n      }\n      normalize(model.pickNormal);\n    }\n    return pickResult;\n  };\n  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {\n    let tMin = Number.MAX_VALUE;\n    let t1 = 0.0;\n    let t2 = 1.0;\n    const vtkCellPickerPlaneTol = 1e-14;\n    const clipLine = clipLineWithPlane(mapper, model.transformMatrix, p1, p2);\n    if (mapper && !clipLine.intersect) {\n      return Number.MAX_VALUE;\n    }\n    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {\n      const pickData = mapper.intersectWithLineForCellPicking(p1, p2);\n      if (pickData) {\n        tMin = pickData.t;\n        model.cellIJK = pickData.ijk;\n        model.pCoords = pickData.pCoords;\n      }\n    } else if (mapper.isA('vtkVolumeMapper')) {\n      // we calculate here the parametric intercept points between the ray and the bounding box, so\n      // if the application defines for some reason a too large ray length (1e6), it restrict the calculation\n      // to the vtkVolume prop bounding box\n      const interceptionObject = vtkBox.intersectWithLine(mapper.getBounds(), p1, p2);\n      t1 = interceptionObject?.t1 > clipLine.t1 ? interceptionObject.t1 : clipLine.t1;\n      t2 = interceptionObject?.t2 < clipLine.t2 ? interceptionObject.t2 : clipLine.t2;\n      tMin = model.intersectVolumeWithLine(p1, p2, t1, t2, tolerance, prop);\n    } else if (mapper.isA('vtkMapper')) {\n      tMin = model.intersectActorWithLine(p1, p2, t1, t2, tolerance, mapper);\n    }\n    if (tMin < model.globalTMin) {\n      model.globalTMin = tMin;\n      if (Math.abs(tMin - t1) < vtkCellPickerPlaneTol && clipLine.clippingPlaneId >= 0) {\n        model.mapperPosition[0] = p1[0] * (1 - t1) + p2[0] * t1;\n        model.mapperPosition[1] = p1[1] * (1 - t1) + p2[1] * t1;\n        model.mapperPosition[2] = p1[2] * (1 - t1) + p2[2] * t1;\n        const plane = [];\n        mapper.getClippingPlaneInDataCoords(model.transformMatrix, clipLine.clippingPlaneId, plane);\n        normalize(plane);\n        // Want normal outward from the planes, not inward\n        model.mapperNormal[0] = -plane[0];\n        model.mapperNormal[1] = -plane[1];\n        model.mapperNormal[2] = -plane[2];\n      }\n      vec3.transformMat4(model.pickPosition, model.mapperPosition, model.transformMatrix);\n      // Transform vector\n      const mat = model.transformMatrix;\n      model.mapperNormal[0] = mat[0] * model.pickNormal[0] + mat[4] * model.pickNormal[1] + mat[8] * model.pickNormal[2];\n      model.mapperNormal[1] = mat[1] * model.pickNormal[0] + mat[5] * model.pickNormal[1] + mat[9] * model.pickNormal[2];\n      model.mapperNormal[2] = mat[2] * model.pickNormal[0] + mat[6] * model.pickNormal[1] + mat[10] * model.pickNormal[2];\n    }\n    return tMin;\n  };\n  model.intersectVolumeWithLine = (p1, p2, t1, t2, tolerance, volume) => {\n    let tMin = Number.MAX_VALUE;\n    const mapper = volume.getMapper();\n    const imageData = mapper.getInputData();\n    const dims = imageData.getDimensions();\n    const scalars = imageData.getPointData().getScalars().getData();\n    const extent = imageData.getExtent();\n    // get the world to index transform to correctly transform from world to volume index\n    const imageTransform = imageData.getWorldToIndex();\n\n    // calculate opacity table\n    const numIComps = 1;\n    const oWidth = 1024;\n    const tmpTable = new Float32Array(oWidth);\n    const opacityArray = new Float32Array(oWidth);\n    let ofun;\n    let oRange;\n    const sampleDist = volume.getMapper().getSampleDistance();\n    for (let c = 0; c < numIComps; ++c) {\n      ofun = volume.getProperty().getScalarOpacity(c);\n      oRange = ofun.getRange();\n      ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);\n      const opacityFactor = sampleDist / volume.getProperty().getScalarOpacityUnitDistance(c);\n\n      // adjust for sample distance etc\n      for (let i = 0; i < oWidth; ++i) {\n        opacityArray[i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n      }\n    }\n    const scale = oWidth / (oRange[1] - oRange[0] + 1);\n\n    // Make a new p1 and p2 using the clipped t1 and t2\n    const q1 = [0, 0, 0, 1];\n    const q2 = [0, 0, 0, 1];\n    q1[0] = p1[0];\n    q1[1] = p1[1];\n    q1[2] = p1[2];\n    q2[0] = p2[0];\n    q2[1] = p2[1];\n    q2[2] = p2[2];\n    if (t1 !== 0.0 || t2 !== 1.0) {\n      for (let j = 0; j < 3; j++) {\n        q1[j] = p1[j] * (1.0 - t1) + p2[j] * t1;\n        q2[j] = p1[j] * (1.0 - t2) + p2[j] * t2;\n      }\n    }\n\n    // convert q1, q2 world coordinates to x1, x2 volume index coordinates\n    const x1 = [0, 0, 0, 0];\n    const x2 = [0, 0, 0, 0];\n    vec4.transformMat4(x1, q1, imageTransform);\n    vec4.transformMat4(x2, q2, imageTransform);\n    const x = [0, 0, 0];\n    const xi = [0, 0, 0];\n    const sliceSize = dims[1] * dims[0];\n    const rowSize = dims[0];\n    // here the step is the 1 over the distance between volume index location x1 and x2\n    const step = 1 / Math.sqrt(distance2BetweenPoints(x1, x2));\n    let insideVolume;\n    // here we reinterpret the t value as the distance between x1 and x2\n    // When calculating the tMin, we weight t between t1 and t2 values\n    for (let t = 0; t < 1; t += step) {\n      // calculate the location of the point\n      insideVolume = true;\n      for (let j = 0; j < 3; j++) {\n        // \"t\" is the fractional distance between endpoints x1 and x2\n        x[j] = x1[j] * (1.0 - t) + x2[j] * t;\n      }\n      for (let j = 0; j < 3; j++) {\n        // Bounds check\n        if (x[j] < extent[2 * j]) {\n          x[j] = extent[2 * j];\n          insideVolume = false;\n        } else if (x[j] > extent[2 * j + 1]) {\n          x[j] = extent[2 * j + 1];\n          insideVolume = false;\n        }\n        xi[j] = Math.round(x[j]);\n      }\n      if (insideVolume) {\n        const index = xi[2] * sliceSize + xi[1] * rowSize + xi[0];\n        let value = scalars[index];\n        if (value < oRange[0]) {\n          value = oRange[0];\n        } else if (value > oRange[1]) {\n          value = oRange[1];\n        }\n        value = Math.floor((value - oRange[0]) * scale);\n        const opacity = tmpTable[value];\n        if (opacity > model.opacityThreshold) {\n          // returning the tMin to the original scale, if t1 > 0 or t2 < 1\n          tMin = t1 * (1.0 - t) + t2 * t;\n          break;\n        }\n      }\n    }\n    return tMin;\n  };\n  model.intersectActorWithLine = (p1, p2, t1, t2, tolerance, mapper) => {\n    let tMin = Number.MAX_VALUE;\n    const minXYZ = [0, 0, 0];\n    let pDistMin = Number.MAX_VALUE;\n    const minPCoords = [0, 0, 0];\n    let minCellId = null;\n    let minCell = null;\n    let minCellType = null;\n    let subId = null;\n    const x = [];\n    const data = mapper.getInputData();\n\n    // Make a new p1 and p2 using the clipped t1 and t2\n    const q1 = [0, 0, 0];\n    const q2 = [0, 0, 0];\n    q1[0] = p1[0];\n    q1[1] = p1[1];\n    q1[2] = p1[2];\n    q2[0] = p2[0];\n    q2[1] = p2[1];\n    q2[2] = p2[2];\n    if (t1 !== 0.0 || t2 !== 1.0) {\n      for (let j = 0; j < 3; j++) {\n        q1[j] = p1[j] * (1.0 - t1) + p2[j] * t1;\n        q2[j] = p1[j] * (1.0 - t2) + p2[j] * t2;\n      }\n    }\n    if (data.getCells) {\n      if (!data.getCells()) {\n        data.buildLinks();\n      }\n      const tempCellMap = createCellMap();\n      const minCellMap = createCellMap();\n      const numberOfCells = data.getNumberOfCells();\n\n      /* eslint-disable no-continue */\n      for (let cellId = 0; cellId < numberOfCells; cellId++) {\n        const pCoords = [0, 0, 0];\n        minCellType = data.getCellType(cellId);\n\n        // Skip cells that are marked as empty\n        if (minCellType === CellType.VTK_EMPTY_CELL) {\n          continue;\n        }\n        const cell = tempCellMap[minCellType];\n        if (cell == null) {\n          continue;\n        }\n        minCell = minCellMap[minCellType];\n        data.getCell(cellId, cell);\n        let cellPicked;\n        {\n          if (vtkCellTypes.hasSubCells(minCellType)) {\n            cellPicked = cell.intersectWithLine(t1, t2, p1, p2, tolerance, x, pCoords);\n          } else {\n            cellPicked = cell.intersectWithLine(p1, p2, tolerance, x, pCoords);\n          }\n        }\n        if (cellPicked.intersect === 1 && cellPicked.t <= tMin + model.tolerance && cellPicked.t >= t1 && cellPicked.t <= t2) {\n          const pDist = cell.getParametricDistance(pCoords);\n          if (pDist < pDistMin || pDist === pDistMin && cellPicked.t < tMin) {\n            tMin = cellPicked.t;\n            pDistMin = pDist;\n            subId = cellPicked.subId;\n            minCellId = cellId;\n            cell.deepCopy(minCell);\n            for (let k = 0; k < 3; k++) {\n              minXYZ[k] = x[k];\n              minPCoords[k] = pCoords[k];\n            }\n          }\n        }\n      }\n      /* eslint-enable no-continue */\n    }\n    if (minCellId >= 0 && tMin < model.globalTMin) {\n      resetPickInfo();\n      const nbPointsInCell = minCell.getNumberOfPoints();\n      const weights = new Array(nbPointsInCell);\n      for (let i = 0; i < nbPointsInCell; i++) {\n        weights[i] = 0.0;\n      }\n      const point = [];\n      if (vtkCellTypes.hasSubCells(minCellType)) {\n        minCell.evaluateLocation(subId, minPCoords, point, weights);\n      } else {\n        minCell.evaluateLocation(minPCoords, point, weights);\n      }\n\n      // Return the polydata to the user\n      model.dataSet = data;\n      model.cellId = minCellId;\n      model.pCoords[0] = minPCoords[0];\n      model.pCoords[1] = minPCoords[1];\n      model.pCoords[2] = minPCoords[2];\n\n      // Find the point with the maximum weight\n      let maxWeight = 0;\n      let iMaxWeight = -1;\n      for (let i = 0; i < nbPointsInCell; i++) {\n        if (weights[i] > maxWeight) {\n          iMaxWeight = i;\n          maxWeight = weights[i];\n        }\n      }\n\n      // If maximum weight is found, use it to get the PointId\n      if (iMaxWeight !== -1) {\n        model.pointId = minCell.getPointsIds()[iMaxWeight];\n      }\n\n      // Set the mapper position\n      model.mapperPosition[0] = minXYZ[0];\n      model.mapperPosition[1] = minXYZ[1];\n      model.mapperPosition[2] = minXYZ[2];\n\n      // Compute the normal\n      if (!publicAPI.computeSurfaceNormal(data, minCell, weights, model.mapperNormal)) {\n        // By default, the normal points back along view ray\n        model.mapperNormal[0] = p1[0] - p2[0];\n        model.mapperNormal[1] = p1[1] - p2[1];\n        model.mapperNormal[2] = p1[2] - p2[2];\n        normalize(model.mapperNormal);\n      }\n    }\n    return tMin;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  cellId: -1,\n  pCoords: [],\n  cellIJK: [],\n  pickNormal: [],\n  mapperNormal: [],\n  opacityThreshold: 0.2\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPicker.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['pickNormal', 'mapperNormal', 'pCoords', 'cellIJK']);\n  macro.setGet(publicAPI, model, ['opacityThreshold']);\n  macro.get(publicAPI, model, ['cellId']);\n\n  // Object methods\n  vtkCellPicker(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellPicker');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellPicker$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\nexport { STATIC, vtkCellPicker$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkCellTypes","vtkLine","vtkPicker","vtkPolyLine","vtkTriangle","vtkQuad","l","normalize","e","distance2BetweenPoints","CellType","vec3","vec4","vtkBox","createCellMap","VTK_LINE","newInstance","VTK_POLY_LINE","VTK_TRIANGLE","VTK_QUAD","clipLineWithPlane","mapper","matrix","p1","p2","outObj","planeId","t1","t2","intersect","nbClippingPlanes","getNumberOfClippingPlanes","plane","i","getClippingPlaneInDataCoords","d1","d2","t","STATIC","vtkCellPicker","publicAPI","model","classHierarchy","push","superClass","resetCellPickerInfo","cellId","pCoords","cellIJK","mapperNormal","pickNormal","resetPickInfo","dataSet","initialize","computeSurfaceNormal","data","cell","weights","normal","normals","getPointData","getNormals","pointNormal","getTuple","getPointsIds","pick","selection","renderer","pickResult","camera","getActiveCamera","cameraPos","getPosition","getParallelProjection","cameraFocus","getFocalPoint","pickPosition","intersectWithLine","tolerance","prop","tMin","Number","MAX_VALUE","vtkCellPickerPlaneTol","clipLine","transformMatrix","isA","pickData","intersectWithLineForCellPicking","ijk","interceptionObject","getBounds","intersectVolumeWithLine","intersectActorWithLine","globalTMin","Math","abs","clippingPlaneId","mapperPosition","transformMat4","mat","volume","getMapper","imageData","getInputData","dims","getDimensions","scalars","getScalars","getData","extent","getExtent","imageTransform","getWorldToIndex","numIComps","oWidth","tmpTable","Float32Array","opacityArray","ofun","oRange","sampleDist","getSampleDistance","c","getProperty","getScalarOpacity","getRange","getTable","opacityFactor","getScalarOpacityUnitDistance","scale","q1","q2","j","x1","x2","x","xi","sliceSize","rowSize","step","sqrt","insideVolume","round","index","value","floor","opacity","opacityThreshold","minXYZ","pDistMin","minPCoords","minCellId","minCell","minCellType","subId","getCells","buildLinks","tempCellMap","minCellMap","numberOfCells","getNumberOfCells","getCellType","VTK_EMPTY_CELL","getCell","cellPicked","hasSubCells","pDist","getParametricDistance","deepCopy","k","nbPointsInCell","getNumberOfPoints","Array","point","evaluateLocation","maxWeight","iMaxWeight","pointId","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","getArray","setGet","get","vtkCellPicker$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/Core/CellPicker.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkCellTypes from '../../Common/DataModel/CellTypes.js';\nimport vtkLine from '../../Common/DataModel/Line.js';\nimport vtkPicker from './Picker.js';\nimport vtkPolyLine from '../../Common/DataModel/PolyLine.js';\nimport vtkTriangle from '../../Common/DataModel/Triangle.js';\nimport vtkQuad from '../../Common/DataModel/Quad.js';\nimport { l as normalize, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport { CellType } from '../../Common/DataModel/CellTypes/Constants.js';\nimport { vec3, vec4 } from 'gl-matrix';\nimport vtkBox from '../../Common/DataModel/Box.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction createCellMap() {\n  return {\n    [CellType.VTK_LINE]: vtkLine.newInstance(),\n    [CellType.VTK_POLY_LINE]: vtkPolyLine.newInstance(),\n    [CellType.VTK_TRIANGLE]: vtkTriangle.newInstance(),\n    [CellType.VTK_QUAD]: vtkQuad.newInstance()\n  };\n}\nfunction clipLineWithPlane(mapper, matrix, p1, p2) {\n  const outObj = {\n    planeId: -1,\n    t1: 0.0,\n    t2: 1.0,\n    intersect: 0\n  };\n  const nbClippingPlanes = mapper.getNumberOfClippingPlanes();\n  const plane = [];\n  for (let i = 0; i < nbClippingPlanes; i++) {\n    mapper.getClippingPlaneInDataCoords(matrix, i, plane);\n    const d1 = plane[0] * p1[0] + plane[1] * p1[1] + plane[2] * p1[2] + plane[3];\n    const d2 = plane[0] * p2[0] + plane[1] * p2[1] + plane[2] * p2[2] + plane[3];\n\n    // If both distances are negative, both points are outside\n    if (d1 < 0 && d2 < 0) {\n      return 0;\n    }\n    if (d1 < 0 || d2 < 0) {\n      // If only one of the distances is negative, the line crosses the plane\n      // Compute fractional distance \"t\" of the crossing between p1 & p2\n      let t = 0.0;\n\n      // The \"if\" here just avoids an expensive division when possible\n      if (d1 !== 0) {\n        // We will never have d1==d2 since they have different signs\n        t = d1 / (d1 - d2);\n      }\n\n      // If point p1 was clipped, adjust t1\n      if (d1 < 0) {\n        if (t >= outObj.t1) {\n          outObj.t1 = t;\n          outObj.planeId = i;\n        }\n      } else if (t <= outObj.t2) {\n        // else point p2 was clipped, so adjust t2\n        outObj.t2 = t;\n      }\n      // If this happens, there's no line left\n      if (outObj.t1 > outObj.t2) {\n        outObj.intersect = 0;\n        return outObj;\n      }\n    }\n  }\n  outObj.intersect = 1;\n  return outObj;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  clipLineWithPlane\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellPicker');\n  const superClass = {\n    ...publicAPI\n  };\n  function resetCellPickerInfo() {\n    model.cellId = -1;\n    model.pCoords[0] = 0.0;\n    model.pCoords[1] = 0.0;\n    model.pCoords[2] = 0.0;\n    model.cellIJK[0] = 0.0;\n    model.cellIJK[1] = 0.0;\n    model.cellIJK[2] = 0.0;\n    model.mapperNormal[0] = 0.0;\n    model.mapperNormal[1] = 0.0;\n    model.mapperNormal[2] = 1.0;\n    model.pickNormal[0] = 0.0;\n    model.pickNormal[1] = 0.0;\n    model.pickNormal[2] = 1.0;\n  }\n  function resetPickInfo() {\n    model.dataSet = null;\n    model.mapper = null;\n    resetCellPickerInfo();\n  }\n  publicAPI.initialize = () => {\n    resetPickInfo();\n    superClass.initialize();\n  };\n  publicAPI.computeSurfaceNormal = (data, cell, weights, normal) => {\n    const normals = data.getPointData().getNormals();\n    if (normals) {\n      normal[0] = 0.0;\n      normal[1] = 0.0;\n      normal[2] = 0.0;\n      const pointNormal = [];\n      for (let i = 0; i < 3; i++) {\n        normals.getTuple(cell.getPointsIds()[i], pointNormal);\n        normal[0] += pointNormal[0] * weights[i];\n        normal[1] += pointNormal[1] * weights[i];\n        normal[2] += pointNormal[2] * weights[i];\n      }\n      normalize(normal);\n    } else {\n      return 0;\n    }\n    return 1;\n  };\n  publicAPI.pick = (selection, renderer) => {\n    publicAPI.initialize();\n    const pickResult = superClass.pick(selection, renderer);\n    if (pickResult) {\n      const camera = renderer.getActiveCamera();\n      const cameraPos = [];\n      camera.getPosition(cameraPos);\n      if (camera.getParallelProjection()) {\n        // For parallel projection, use -ve direction of projection\n        const cameraFocus = [];\n        camera.getFocalPoint(cameraFocus);\n        model.pickNormal[0] = cameraPos[0] - cameraFocus[0];\n        model.pickNormal[1] = cameraPos[1] - cameraFocus[1];\n        model.pickNormal[2] = cameraPos[2] - cameraFocus[2];\n      } else {\n        // Get the vector from pick position to the camera\n        model.pickNormal[0] = cameraPos[0] - model.pickPosition[0];\n        model.pickNormal[1] = cameraPos[1] - model.pickPosition[1];\n        model.pickNormal[2] = cameraPos[2] - model.pickPosition[2];\n      }\n      normalize(model.pickNormal);\n    }\n    return pickResult;\n  };\n  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {\n    let tMin = Number.MAX_VALUE;\n    let t1 = 0.0;\n    let t2 = 1.0;\n    const vtkCellPickerPlaneTol = 1e-14;\n    const clipLine = clipLineWithPlane(mapper, model.transformMatrix, p1, p2);\n    if (mapper && !clipLine.intersect) {\n      return Number.MAX_VALUE;\n    }\n    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {\n      const pickData = mapper.intersectWithLineForCellPicking(p1, p2);\n      if (pickData) {\n        tMin = pickData.t;\n        model.cellIJK = pickData.ijk;\n        model.pCoords = pickData.pCoords;\n      }\n    } else if (mapper.isA('vtkVolumeMapper')) {\n      // we calculate here the parametric intercept points between the ray and the bounding box, so\n      // if the application defines for some reason a too large ray length (1e6), it restrict the calculation\n      // to the vtkVolume prop bounding box\n      const interceptionObject = vtkBox.intersectWithLine(mapper.getBounds(), p1, p2);\n      t1 = interceptionObject?.t1 > clipLine.t1 ? interceptionObject.t1 : clipLine.t1;\n      t2 = interceptionObject?.t2 < clipLine.t2 ? interceptionObject.t2 : clipLine.t2;\n      tMin = model.intersectVolumeWithLine(p1, p2, t1, t2, tolerance, prop);\n    } else if (mapper.isA('vtkMapper')) {\n      tMin = model.intersectActorWithLine(p1, p2, t1, t2, tolerance, mapper);\n    }\n    if (tMin < model.globalTMin) {\n      model.globalTMin = tMin;\n      if (Math.abs(tMin - t1) < vtkCellPickerPlaneTol && clipLine.clippingPlaneId >= 0) {\n        model.mapperPosition[0] = p1[0] * (1 - t1) + p2[0] * t1;\n        model.mapperPosition[1] = p1[1] * (1 - t1) + p2[1] * t1;\n        model.mapperPosition[2] = p1[2] * (1 - t1) + p2[2] * t1;\n        const plane = [];\n        mapper.getClippingPlaneInDataCoords(model.transformMatrix, clipLine.clippingPlaneId, plane);\n        normalize(plane);\n        // Want normal outward from the planes, not inward\n        model.mapperNormal[0] = -plane[0];\n        model.mapperNormal[1] = -plane[1];\n        model.mapperNormal[2] = -plane[2];\n      }\n      vec3.transformMat4(model.pickPosition, model.mapperPosition, model.transformMatrix);\n      // Transform vector\n      const mat = model.transformMatrix;\n      model.mapperNormal[0] = mat[0] * model.pickNormal[0] + mat[4] * model.pickNormal[1] + mat[8] * model.pickNormal[2];\n      model.mapperNormal[1] = mat[1] * model.pickNormal[0] + mat[5] * model.pickNormal[1] + mat[9] * model.pickNormal[2];\n      model.mapperNormal[2] = mat[2] * model.pickNormal[0] + mat[6] * model.pickNormal[1] + mat[10] * model.pickNormal[2];\n    }\n    return tMin;\n  };\n  model.intersectVolumeWithLine = (p1, p2, t1, t2, tolerance, volume) => {\n    let tMin = Number.MAX_VALUE;\n    const mapper = volume.getMapper();\n    const imageData = mapper.getInputData();\n    const dims = imageData.getDimensions();\n    const scalars = imageData.getPointData().getScalars().getData();\n    const extent = imageData.getExtent();\n    // get the world to index transform to correctly transform from world to volume index\n    const imageTransform = imageData.getWorldToIndex();\n\n    // calculate opacity table\n    const numIComps = 1;\n    const oWidth = 1024;\n    const tmpTable = new Float32Array(oWidth);\n    const opacityArray = new Float32Array(oWidth);\n    let ofun;\n    let oRange;\n    const sampleDist = volume.getMapper().getSampleDistance();\n    for (let c = 0; c < numIComps; ++c) {\n      ofun = volume.getProperty().getScalarOpacity(c);\n      oRange = ofun.getRange();\n      ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);\n      const opacityFactor = sampleDist / volume.getProperty().getScalarOpacityUnitDistance(c);\n\n      // adjust for sample distance etc\n      for (let i = 0; i < oWidth; ++i) {\n        opacityArray[i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n      }\n    }\n    const scale = oWidth / (oRange[1] - oRange[0] + 1);\n\n    // Make a new p1 and p2 using the clipped t1 and t2\n    const q1 = [0, 0, 0, 1];\n    const q2 = [0, 0, 0, 1];\n    q1[0] = p1[0];\n    q1[1] = p1[1];\n    q1[2] = p1[2];\n    q2[0] = p2[0];\n    q2[1] = p2[1];\n    q2[2] = p2[2];\n    if (t1 !== 0.0 || t2 !== 1.0) {\n      for (let j = 0; j < 3; j++) {\n        q1[j] = p1[j] * (1.0 - t1) + p2[j] * t1;\n        q2[j] = p1[j] * (1.0 - t2) + p2[j] * t2;\n      }\n    }\n\n    // convert q1, q2 world coordinates to x1, x2 volume index coordinates\n    const x1 = [0, 0, 0, 0];\n    const x2 = [0, 0, 0, 0];\n    vec4.transformMat4(x1, q1, imageTransform);\n    vec4.transformMat4(x2, q2, imageTransform);\n    const x = [0, 0, 0];\n    const xi = [0, 0, 0];\n    const sliceSize = dims[1] * dims[0];\n    const rowSize = dims[0];\n    // here the step is the 1 over the distance between volume index location x1 and x2\n    const step = 1 / Math.sqrt(distance2BetweenPoints(x1, x2));\n    let insideVolume;\n    // here we reinterpret the t value as the distance between x1 and x2\n    // When calculating the tMin, we weight t between t1 and t2 values\n    for (let t = 0; t < 1; t += step) {\n      // calculate the location of the point\n      insideVolume = true;\n      for (let j = 0; j < 3; j++) {\n        // \"t\" is the fractional distance between endpoints x1 and x2\n        x[j] = x1[j] * (1.0 - t) + x2[j] * t;\n      }\n      for (let j = 0; j < 3; j++) {\n        // Bounds check\n        if (x[j] < extent[2 * j]) {\n          x[j] = extent[2 * j];\n          insideVolume = false;\n        } else if (x[j] > extent[2 * j + 1]) {\n          x[j] = extent[2 * j + 1];\n          insideVolume = false;\n        }\n        xi[j] = Math.round(x[j]);\n      }\n      if (insideVolume) {\n        const index = xi[2] * sliceSize + xi[1] * rowSize + xi[0];\n        let value = scalars[index];\n        if (value < oRange[0]) {\n          value = oRange[0];\n        } else if (value > oRange[1]) {\n          value = oRange[1];\n        }\n        value = Math.floor((value - oRange[0]) * scale);\n        const opacity = tmpTable[value];\n        if (opacity > model.opacityThreshold) {\n          // returning the tMin to the original scale, if t1 > 0 or t2 < 1\n          tMin = t1 * (1.0 - t) + t2 * t;\n          break;\n        }\n      }\n    }\n    return tMin;\n  };\n  model.intersectActorWithLine = (p1, p2, t1, t2, tolerance, mapper) => {\n    let tMin = Number.MAX_VALUE;\n    const minXYZ = [0, 0, 0];\n    let pDistMin = Number.MAX_VALUE;\n    const minPCoords = [0, 0, 0];\n    let minCellId = null;\n    let minCell = null;\n    let minCellType = null;\n    let subId = null;\n    const x = [];\n    const data = mapper.getInputData();\n\n    // Make a new p1 and p2 using the clipped t1 and t2\n    const q1 = [0, 0, 0];\n    const q2 = [0, 0, 0];\n    q1[0] = p1[0];\n    q1[1] = p1[1];\n    q1[2] = p1[2];\n    q2[0] = p2[0];\n    q2[1] = p2[1];\n    q2[2] = p2[2];\n    if (t1 !== 0.0 || t2 !== 1.0) {\n      for (let j = 0; j < 3; j++) {\n        q1[j] = p1[j] * (1.0 - t1) + p2[j] * t1;\n        q2[j] = p1[j] * (1.0 - t2) + p2[j] * t2;\n      }\n    }\n    if (data.getCells) {\n      if (!data.getCells()) {\n        data.buildLinks();\n      }\n      const tempCellMap = createCellMap();\n      const minCellMap = createCellMap();\n      const numberOfCells = data.getNumberOfCells();\n\n      /* eslint-disable no-continue */\n      for (let cellId = 0; cellId < numberOfCells; cellId++) {\n        const pCoords = [0, 0, 0];\n        minCellType = data.getCellType(cellId);\n\n        // Skip cells that are marked as empty\n        if (minCellType === CellType.VTK_EMPTY_CELL) {\n          continue;\n        }\n        const cell = tempCellMap[minCellType];\n        if (cell == null) {\n          continue;\n        }\n        minCell = minCellMap[minCellType];\n        data.getCell(cellId, cell);\n        let cellPicked;\n        {\n          if (vtkCellTypes.hasSubCells(minCellType)) {\n            cellPicked = cell.intersectWithLine(t1, t2, p1, p2, tolerance, x, pCoords);\n          } else {\n            cellPicked = cell.intersectWithLine(p1, p2, tolerance, x, pCoords);\n          }\n        }\n        if (cellPicked.intersect === 1 && cellPicked.t <= tMin + model.tolerance && cellPicked.t >= t1 && cellPicked.t <= t2) {\n          const pDist = cell.getParametricDistance(pCoords);\n          if (pDist < pDistMin || pDist === pDistMin && cellPicked.t < tMin) {\n            tMin = cellPicked.t;\n            pDistMin = pDist;\n            subId = cellPicked.subId;\n            minCellId = cellId;\n            cell.deepCopy(minCell);\n            for (let k = 0; k < 3; k++) {\n              minXYZ[k] = x[k];\n              minPCoords[k] = pCoords[k];\n            }\n          }\n        }\n      }\n      /* eslint-enable no-continue */\n    }\n\n    if (minCellId >= 0 && tMin < model.globalTMin) {\n      resetPickInfo();\n      const nbPointsInCell = minCell.getNumberOfPoints();\n      const weights = new Array(nbPointsInCell);\n      for (let i = 0; i < nbPointsInCell; i++) {\n        weights[i] = 0.0;\n      }\n      const point = [];\n      if (vtkCellTypes.hasSubCells(minCellType)) {\n        minCell.evaluateLocation(subId, minPCoords, point, weights);\n      } else {\n        minCell.evaluateLocation(minPCoords, point, weights);\n      }\n\n      // Return the polydata to the user\n      model.dataSet = data;\n      model.cellId = minCellId;\n      model.pCoords[0] = minPCoords[0];\n      model.pCoords[1] = minPCoords[1];\n      model.pCoords[2] = minPCoords[2];\n\n      // Find the point with the maximum weight\n      let maxWeight = 0;\n      let iMaxWeight = -1;\n      for (let i = 0; i < nbPointsInCell; i++) {\n        if (weights[i] > maxWeight) {\n          iMaxWeight = i;\n          maxWeight = weights[i];\n        }\n      }\n\n      // If maximum weight is found, use it to get the PointId\n      if (iMaxWeight !== -1) {\n        model.pointId = minCell.getPointsIds()[iMaxWeight];\n      }\n\n      // Set the mapper position\n      model.mapperPosition[0] = minXYZ[0];\n      model.mapperPosition[1] = minXYZ[1];\n      model.mapperPosition[2] = minXYZ[2];\n\n      // Compute the normal\n      if (!publicAPI.computeSurfaceNormal(data, minCell, weights, model.mapperNormal)) {\n        // By default, the normal points back along view ray\n        model.mapperNormal[0] = p1[0] - p2[0];\n        model.mapperNormal[1] = p1[1] - p2[1];\n        model.mapperNormal[2] = p1[2] - p2[2];\n        normalize(model.mapperNormal);\n      }\n    }\n    return tMin;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  cellId: -1,\n  pCoords: [],\n  cellIJK: [],\n  pickNormal: [],\n  mapperNormal: [],\n  opacityThreshold: 0.2\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPicker.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['pickNormal', 'mapperNormal', 'pCoords', 'cellIJK']);\n  macro.setGet(publicAPI, model, ['opacityThreshold']);\n  macro.get(publicAPI, model, ['cellId']);\n\n  // Object methods\n  vtkCellPicker(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellPicker');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellPicker$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellPicker$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}