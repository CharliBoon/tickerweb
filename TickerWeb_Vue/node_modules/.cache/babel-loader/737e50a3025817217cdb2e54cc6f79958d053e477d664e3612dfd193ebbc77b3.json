{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport { registerViewConstructor } from '../Core/RenderWindow.js';\nimport vtkForwardPass from './ForwardPass.js';\nimport vtkWebGPUBuffer from './Buffer.js';\nimport vtkWebGPUDevice from './Device.js';\nimport vtkWebGPUHardwareSelector from './HardwareSelector.js';\nimport vtkWebGPUViewNodeFactory, { registerOverride } from './ViewNodeFactory.js';\nimport vtkRenderPass from '../SceneGraph/RenderPass.js';\nimport vtkRenderWindowViewNode from '../SceneGraph/RenderWindowViewNode.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\nconst {\n  vtkErrorMacro\n} = macro;\n// const IS_CHROME = navigator.userAgent.indexOf('Chrome') !== -1;\nconst SCREENSHOT_PLACEHOLDER = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: '100%'\n};\n\n// ----------------------------------------------------------------------------\n// vtkWebGPURenderWindow methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPURenderWindow(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPURenderWindow');\n  publicAPI.getViewNodeFactory = () => model.myFactory;\n\n  // Auto update style\n  const previousSize = [0, 0];\n  function updateWindow() {\n    // Canvas size\n    if (model.renderable) {\n      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {\n        previousSize[0] = model.size[0];\n        previousSize[1] = model.size[1];\n        model.canvas.setAttribute('width', model.size[0]);\n        model.canvas.setAttribute('height', model.size[1]);\n        publicAPI.recreateSwapChain();\n      }\n    }\n\n    // ImageStream size\n    if (model.viewStream) {\n      // If same size that's a NoOp\n      model.viewStream.setSize(model.size[0], model.size[1]);\n    }\n\n    // Offscreen ?\n    model.canvas.style.display = model.useOffScreen ? 'none' : 'block';\n\n    // Cursor type\n    if (model.el) {\n      model.el.style.cursor = model.cursorVisibility ? model.cursor : 'none';\n    }\n\n    // Invalidate cached DOM container size\n    model.containerSize = null;\n  }\n  publicAPI.onModified(updateWindow);\n  publicAPI.recreateSwapChain = () => {\n    if (model.context) {\n      model.context.unconfigure();\n      model.presentationFormat = navigator.gpu.getPreferredCanvasFormat(model.adapter);\n\n      /* eslint-disable no-undef */\n      /* eslint-disable no-bitwise */\n      model.context.configure({\n        device: model.device.getHandle(),\n        format: model.presentationFormat,\n        alphaMode: 'premultiplied',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,\n        width: model.size[0],\n        height: model.size[1]\n      });\n      model._configured = true;\n    }\n  };\n  publicAPI.getCurrentTexture = () => model.context.getCurrentTexture();\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());\n      publicAPI.removeUnusedNodes();\n      publicAPI.initialize();\n    } else if (model.initialized) {\n      if (!model._configured) {\n        publicAPI.recreateSwapChain();\n      }\n      model.commandEncoder = model.device.createCommandEncoder();\n    }\n  };\n\n  // publicAPI.traverseRenderers = (renPass) => {\n  //   // iterate over renderers\n  //   const numlayers = publicAPI.getRenderable().getNumberOfLayers();\n  //   const renderers = publicAPI.getChildren();\n  //   for (let i = 0; i < numlayers; i++) {\n  //     for (let index = 0; index < renderers.length; index++) {\n  //       const renNode = renderers[index];\n  //       const ren = publicAPI.getRenderable().getRenderers()[index];\n  //       if (ren.getDraw() && ren.getLayer() === i) {\n  //         renNode.traverse(renPass);\n  //       }\n  //     }\n  //   }\n  // };\n\n  publicAPI.initialize = () => {\n    if (!model.initializing) {\n      model.initializing = true;\n      if (!navigator.gpu) {\n        vtkErrorMacro('WebGPU is not enabled.');\n        return;\n      }\n      publicAPI.create3DContextAsync().then(() => {\n        model.initialized = true;\n        if (model.deleted) {\n          return;\n        }\n        publicAPI.invokeInitialized();\n      });\n    }\n  };\n  publicAPI.setContainer = el => {\n    if (model.el && model.el !== el) {\n      if (model.canvas.parentNode !== model.el) {\n        vtkErrorMacro('Error: canvas parent node does not match container');\n      }\n\n      // Remove canvas from previous container\n      model.el.removeChild(model.canvas);\n\n      // If the renderer has previously added\n      // a background image, remove it from the DOM.\n      if (model.el.contains(model.bgImage)) {\n        model.el.removeChild(model.bgImage);\n      }\n    }\n    if (model.el !== el) {\n      model.el = el;\n      if (model.el) {\n        model.el.appendChild(model.canvas);\n\n        // If the renderer is set to use a background\n        // image, attach it to the DOM.\n        if (model.useBackgroundImage) {\n          model.el.appendChild(model.bgImage);\n        }\n      }\n\n      // Trigger modified()\n      publicAPI.modified();\n    }\n  };\n  publicAPI.getContainer = () => model.el;\n  publicAPI.getContainerSize = () => {\n    if (!model.containerSize && model.el) {\n      const {\n        width,\n        height\n      } = model.el.getBoundingClientRect();\n      model.containerSize = [width, height];\n    }\n    return model.containerSize || model.size;\n  };\n  publicAPI.getFramebufferSize = () => model.size;\n  publicAPI.create3DContextAsync = async () => {\n    // Get a GPU device to render with\n    model.adapter = await navigator.gpu.requestAdapter({\n      powerPreference: 'high-performance'\n    });\n    if (model.deleted) {\n      return;\n    }\n    // console.log([...model.adapter.features]);\n    model.device = vtkWebGPUDevice.newInstance();\n    model.device.initialize(await model.adapter.requestDevice());\n    if (model.deleted) {\n      model.device = null;\n      return;\n    }\n    // model.device.getHandle().lost.then((info) => {\n    //   console.log(`${info.message}`);\n    //   publicAPI.releaseGraphicsResources();\n    // });\n    model.context = model.canvas.getContext('webgpu');\n  };\n  publicAPI.releaseGraphicsResources = () => {\n    const rp = vtkRenderPass.newInstance();\n    rp.setCurrentOperation('Release');\n    rp.traverse(publicAPI, null);\n    model.adapter = null;\n    model.device = null;\n    model.context = null;\n    model.initialized = false;\n    model.initializing = false;\n  };\n  publicAPI.setBackgroundImage = img => {\n    model.bgImage.src = img.src;\n  };\n  publicAPI.setUseBackgroundImage = value => {\n    model.useBackgroundImage = value;\n\n    // Add or remove the background image from the\n    // DOM as specified.\n    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {\n      model.el.appendChild(model.bgImage);\n    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {\n      model.el.removeChild(model.bgImage);\n    }\n  };\n  async function getCanvasDataURL() {\n    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.imageFormat;\n    // Copy current canvas to not modify the original\n    const temporaryCanvas = document.createElement('canvas');\n    const temporaryContext = temporaryCanvas.getContext('2d');\n    temporaryCanvas.width = model.canvas.width;\n    temporaryCanvas.height = model.canvas.height;\n    const result = await publicAPI.getPixelsAsync();\n    const imageData = new ImageData(result.colorValues, result.width, result.height);\n    // temporaryCanvas.putImageData(imageData, 0, 0);\n    temporaryContext.putImageData(imageData, 0, 0);\n\n    // Get current client rect to place canvas\n    const mainBoundingClientRect = model.canvas.getBoundingClientRect();\n    const renderWindow = model.renderable;\n    const renderers = renderWindow.getRenderers();\n    renderers.forEach(renderer => {\n      const viewProps = renderer.getViewProps();\n      viewProps.forEach(viewProp => {\n        // Check if the prop has a container that should have canvas\n        if (viewProp.getContainer) {\n          const container = viewProp.getContainer();\n          const canvasList = container.getElementsByTagName('canvas');\n          // Go throughout all canvas and copy it into temporary main canvas\n          for (let i = 0; i < canvasList.length; i++) {\n            const currentCanvas = canvasList[i];\n            const boundingClientRect = currentCanvas.getBoundingClientRect();\n            const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;\n            const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;\n            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);\n          }\n        }\n      });\n    });\n    const screenshot = temporaryCanvas.toDataURL(format);\n    temporaryCanvas.remove();\n    publicAPI.invokeImageReady(screenshot);\n  }\n  publicAPI.captureNextImage = function () {\n    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';\n    let {\n      resetCamera = false,\n      size = null,\n      scale = 1\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (model.deleted) {\n      return null;\n    }\n    model.imageFormat = format;\n    const previous = model.notifyStartCaptureImage;\n    model.notifyStartCaptureImage = true;\n    model._screenshot = {\n      size: !!size || scale !== 1 ? size || model.size.map(val => val * scale) : null\n    };\n    return new Promise((resolve, reject) => {\n      const subscription = publicAPI.onImageReady(imageURL => {\n        if (model._screenshot.size === null) {\n          model.notifyStartCaptureImage = previous;\n          subscription.unsubscribe();\n          if (model._screenshot.placeHolder) {\n            // resize the main canvas back to its original size and show it\n            model.size = model._screenshot.originalSize;\n\n            // process the resize\n            publicAPI.modified();\n\n            // restore the saved camera parameters, if applicable\n            if (model._screenshot.cameras) {\n              model._screenshot.cameras.forEach(_ref => {\n                let {\n                  restoreParamsFn,\n                  arg\n                } = _ref;\n                return restoreParamsFn(arg);\n              });\n            }\n\n            // Trigger a render at the original size\n            publicAPI.traverseAllPasses();\n\n            // Remove and clean up the placeholder, revealing the original\n            model.el.removeChild(model._screenshot.placeHolder);\n            model._screenshot.placeHolder.remove();\n            model._screenshot = null;\n          }\n          resolve(imageURL);\n        } else {\n          // Create a placeholder image overlay while we resize and render\n          const tmpImg = document.createElement('img');\n          tmpImg.style = SCREENSHOT_PLACEHOLDER;\n          tmpImg.src = imageURL;\n          model._screenshot.placeHolder = model.el.appendChild(tmpImg);\n\n          // hide the main canvas\n          model.canvas.style.display = 'none';\n\n          // remember the main canvas original size, then resize it\n          model._screenshot.originalSize = model.size;\n          model.size = model._screenshot.size;\n          model._screenshot.size = null;\n\n          // process the resize\n          publicAPI.modified();\n          if (resetCamera) {\n            const isUserResetCamera = resetCamera !== true;\n\n            // If resetCamera was requested, we first save camera parameters\n            // from all the renderers, so we can restore them later\n            model._screenshot.cameras = model.renderable.getRenderers().map(renderer => {\n              const camera = renderer.getActiveCamera();\n              const params = camera.get('focalPoint', 'position', 'parallelScale');\n              return {\n                resetCameraArgs: isUserResetCamera ? {\n                  renderer\n                } : undefined,\n                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,\n                restoreParamsFn: camera.set,\n                // \"clone\" the params so we don't keep refs to properties\n                arg: JSON.parse(JSON.stringify(params))\n              };\n            });\n\n            // Perform the resetCamera() on each renderer only after capturing\n            // the params from all active cameras, in case there happen to be\n            // linked cameras among the renderers.\n            model._screenshot.cameras.forEach(_ref2 => {\n              let {\n                resetCameraFn,\n                resetCameraArgs\n              } = _ref2;\n              return resetCameraFn(resetCameraArgs);\n            });\n          }\n\n          // Trigger a render at the custom size\n          publicAPI.traverseAllPasses();\n        }\n      });\n    });\n  };\n  publicAPI.traverseAllPasses = () => {\n    if (model.deleted) {\n      return;\n    }\n    // if we are not initialized then we call initialize\n    // which is async so we will not actually get a render\n    // so we queue up another traverse for when we are initialized\n    if (!model.initialized) {\n      publicAPI.initialize();\n      const subscription = publicAPI.onInitialized(() => {\n        subscription.unsubscribe();\n        publicAPI.traverseAllPasses();\n      });\n    } else {\n      if (model.renderPasses) {\n        for (let index = 0; index < model.renderPasses.length; ++index) {\n          model.renderPasses[index].traverse(publicAPI, null);\n        }\n      }\n      if (model.commandEncoder) {\n        model.device.submitCommandEncoder(model.commandEncoder);\n        model.commandEncoder = null;\n        if (model.notifyStartCaptureImage) {\n          model.device.onSubmittedWorkDone().then(() => {\n            getCanvasDataURL();\n          });\n        }\n      }\n    }\n  };\n  publicAPI.setViewStream = stream => {\n    if (model.viewStream === stream) {\n      return false;\n    }\n    if (model.subscription) {\n      model.subscription.unsubscribe();\n      model.subscription = null;\n    }\n    model.viewStream = stream;\n    if (model.viewStream) {\n      // Force background to be transparent + render\n      const mainRenderer = model.renderable.getRenderers()[0];\n      mainRenderer.getBackgroundByReference()[3] = 0;\n\n      // Enable display of the background image\n      publicAPI.setUseBackgroundImage(true);\n\n      // Bind to remote stream\n      model.subscription = model.viewStream.onImageReady(e => publicAPI.setBackgroundImage(e.image));\n      model.viewStream.setSize(model.size[0], model.size[1]);\n      model.viewStream.invalidateCache();\n      model.viewStream.render();\n      publicAPI.modified();\n    }\n    return true;\n  };\n  publicAPI.getUniquePropID = () => model.nextPropID++;\n  publicAPI.getPropFromID = id => {\n    for (let i = 0; i < model.children.length; i++) {\n      const res = model.children[i].getPropFromID(id);\n      if (res !== null) {\n        return res;\n      }\n    }\n    return null;\n  };\n  publicAPI.getPixelsAsync = async () => {\n    const device = model.device;\n    const texture = model.renderPasses[0].getOpaquePass().getColorTexture();\n\n    // as this is async we really don't want to store things in\n    // the class as multiple calls may start before resolving\n    // so anything specific to this request gets put into the\n    // result object (by value in most cases)\n    const result = {\n      width: texture.getWidth(),\n      height: texture.getHeight()\n    };\n\n    // must be a multiple of 256 bytes, so 32 texels with rgba16\n    result.colorBufferWidth = 32 * Math.floor((result.width + 31) / 32);\n    result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 8;\n    const colorBuffer = vtkWebGPUBuffer.newInstance();\n    colorBuffer.setDevice(device);\n    /* eslint-disable no-bitwise */\n    /* eslint-disable no-undef */\n    colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n    /* eslint-enable no-bitwise */\n    /* eslint-enable no-undef */\n\n    const cmdEnc = model.device.createCommandEncoder();\n    cmdEnc.copyTextureToBuffer({\n      texture: texture.getHandle()\n    }, {\n      buffer: colorBuffer.getHandle(),\n      bytesPerRow: 8 * result.colorBufferWidth,\n      rowsPerImage: result.height\n    }, {\n      width: result.width,\n      height: result.height,\n      depthOrArrayLayers: 1\n    });\n    device.submitCommandEncoder(cmdEnc);\n\n    /* eslint-disable no-undef */\n    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);\n    await cLoad;\n    /* eslint-enable no-undef */\n\n    result.colorValues = new Uint16Array(colorBuffer.getMappedRange().slice());\n    colorBuffer.unmap();\n    // repack the array\n    const tmparray = new Uint8ClampedArray(result.height * result.width * 4);\n    for (let y = 0; y < result.height; y++) {\n      for (let x = 0; x < result.width; x++) {\n        const doffset = (y * result.width + x) * 4;\n        const soffset = (y * result.colorBufferWidth + x) * 4;\n        tmparray[doffset] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset]);\n        tmparray[doffset + 1] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset + 1]);\n        tmparray[doffset + 2] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset + 2]);\n        tmparray[doffset + 3] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset + 3]);\n      }\n    }\n    result.colorValues = tmparray;\n    return result;\n  };\n  publicAPI.createSelector = () => {\n    const ret = vtkWebGPUHardwareSelector.newInstance();\n    ret.setWebGPURenderWindow(publicAPI);\n    return ret;\n  };\n  const superSetSize = publicAPI.setSize;\n  publicAPI.setSize = (width, height) => {\n    const modified = superSetSize(width, height);\n    if (modified) {\n      publicAPI.invokeWindowResizeEvent({\n        width,\n        height\n      });\n    }\n    return modified;\n  };\n  publicAPI.delete = macro.chain(publicAPI.delete, publicAPI.setViewStream);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  initialized: false,\n  context: null,\n  adapter: null,\n  device: null,\n  canvas: null,\n  cursorVisibility: true,\n  cursor: 'pointer',\n  containerSize: null,\n  renderPasses: [],\n  notifyStartCaptureImage: false,\n  imageFormat: 'image/png',\n  useOffScreen: false,\n  useBackgroundImage: false,\n  nextPropID: 1,\n  xrSupported: false,\n  presentationFormat: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Create internal instances\n  model.canvas = document.createElement('canvas');\n  model.canvas.style.width = '100%';\n\n  // Create internal bgImage\n  model.bgImage = new Image();\n  model.bgImage.style.position = 'absolute';\n  model.bgImage.style.left = '0';\n  model.bgImage.style.top = '0';\n  model.bgImage.style.width = '100%';\n  model.bgImage.style.height = '100%';\n  model.bgImage.style.zIndex = '-1';\n\n  // Inheritance\n  vtkRenderWindowViewNode.extend(publicAPI, model, initialValues);\n  model.myFactory = vtkWebGPUViewNodeFactory.newInstance();\n\n  // setup default forward pass rendering\n  model.renderPasses[0] = vtkForwardPass.newInstance();\n  if (!model.selector) {\n    model.selector = vtkWebGPUHardwareSelector.newInstance();\n    model.selector.setWebGPURenderWindow(publicAPI);\n  }\n  macro.event(publicAPI, model, 'imageReady');\n  macro.event(publicAPI, model, 'initialized');\n\n  // Build VTK API\n  macro.get(publicAPI, model, ['commandEncoder', 'device', 'presentationFormat', 'useBackgroundImage', 'xrSupported']);\n  macro.setGet(publicAPI, model, ['initialized', 'context', 'canvas', 'device', 'renderPasses', 'notifyStartCaptureImage', 'cursor', 'useOffScreen']);\n  macro.setGetArray(publicAPI, model, ['size'], 2);\n  macro.event(publicAPI, model, 'windowResizeEvent');\n\n  // Object methods\n  vtkWebGPURenderWindow(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPURenderWindow');\n\n// ----------------------------------------------------------------------------\n// Register API specific RenderWindow implementation\n// ----------------------------------------------------------------------------\n\nregisterViewConstructor('WebGPU', newInstance);\n\n// ----------------------------------------------------------------------------\n\nvar vtkRenderWindow = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkRenderWindow', newInstance);\nexport { vtkRenderWindow as default, extend, newInstance };","map":{"version":3,"names":["m","macro","registerViewConstructor","vtkForwardPass","vtkWebGPUBuffer","vtkWebGPUDevice","vtkWebGPUHardwareSelector","vtkWebGPUViewNodeFactory","registerOverride","vtkRenderPass","vtkRenderWindowViewNode","HalfFloat","vtkErrorMacro","SCREENSHOT_PLACEHOLDER","position","top","left","width","height","vtkWebGPURenderWindow","publicAPI","model","classHierarchy","push","getViewNodeFactory","myFactory","previousSize","updateWindow","renderable","size","canvas","setAttribute","recreateSwapChain","viewStream","setSize","style","display","useOffScreen","el","cursor","cursorVisibility","containerSize","onModified","context","unconfigure","presentationFormat","navigator","gpu","getPreferredCanvasFormat","adapter","configure","device","getHandle","format","alphaMode","usage","GPUTextureUsage","RENDER_ATTACHMENT","COPY_DST","_configured","getCurrentTexture","buildPass","prepass","prepareNodes","addMissingNodes","getRenderersByReference","removeUnusedNodes","initialize","initialized","commandEncoder","createCommandEncoder","initializing","create3DContextAsync","then","deleted","invokeInitialized","setContainer","parentNode","removeChild","contains","bgImage","appendChild","useBackgroundImage","modified","getContainer","getContainerSize","getBoundingClientRect","getFramebufferSize","requestAdapter","powerPreference","newInstance","requestDevice","getContext","releaseGraphicsResources","rp","setCurrentOperation","traverse","setBackgroundImage","img","src","setUseBackgroundImage","value","getCanvasDataURL","arguments","length","undefined","imageFormat","temporaryCanvas","document","createElement","temporaryContext","result","getPixelsAsync","imageData","ImageData","colorValues","putImageData","mainBoundingClientRect","renderWindow","renderers","getRenderers","forEach","renderer","viewProps","getViewProps","viewProp","container","canvasList","getElementsByTagName","i","currentCanvas","boundingClientRect","newXPosition","x","newYPosition","y","drawImage","screenshot","toDataURL","remove","invokeImageReady","captureNextImage","resetCamera","scale","previous","notifyStartCaptureImage","_screenshot","map","val","Promise","resolve","reject","subscription","onImageReady","imageURL","unsubscribe","placeHolder","originalSize","cameras","_ref","restoreParamsFn","arg","traverseAllPasses","tmpImg","isUserResetCamera","camera","getActiveCamera","params","get","resetCameraArgs","resetCameraFn","set","JSON","parse","stringify","_ref2","onInitialized","renderPasses","index","submitCommandEncoder","onSubmittedWorkDone","setViewStream","stream","mainRenderer","getBackgroundByReference","e","image","invalidateCache","render","getUniquePropID","nextPropID","getPropFromID","id","children","res","texture","getOpaquePass","getColorTexture","getWidth","getHeight","colorBufferWidth","Math","floor","colorBufferSizeInBytes","colorBuffer","setDevice","create","GPUBufferUsage","MAP_READ","cmdEnc","copyTextureToBuffer","buffer","bytesPerRow","rowsPerImage","depthOrArrayLayers","cLoad","mapAsync","GPUMapMode","READ","Uint16Array","getMappedRange","slice","unmap","tmparray","Uint8ClampedArray","doffset","soffset","fromHalf","createSelector","ret","setWebGPURenderWindow","superSetSize","invokeWindowResizeEvent","delete","chain","DEFAULT_VALUES","xrSupported","extend","initialValues","Object","assign","Image","zIndex","selector","event","setGet","setGetArray","vtkRenderWindow","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/WebGPU/RenderWindow.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport { registerViewConstructor } from '../Core/RenderWindow.js';\nimport vtkForwardPass from './ForwardPass.js';\nimport vtkWebGPUBuffer from './Buffer.js';\nimport vtkWebGPUDevice from './Device.js';\nimport vtkWebGPUHardwareSelector from './HardwareSelector.js';\nimport vtkWebGPUViewNodeFactory, { registerOverride } from './ViewNodeFactory.js';\nimport vtkRenderPass from '../SceneGraph/RenderPass.js';\nimport vtkRenderWindowViewNode from '../SceneGraph/RenderWindowViewNode.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n// const IS_CHROME = navigator.userAgent.indexOf('Chrome') !== -1;\nconst SCREENSHOT_PLACEHOLDER = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: '100%'\n};\n\n// ----------------------------------------------------------------------------\n// vtkWebGPURenderWindow methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPURenderWindow(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPURenderWindow');\n  publicAPI.getViewNodeFactory = () => model.myFactory;\n\n  // Auto update style\n  const previousSize = [0, 0];\n  function updateWindow() {\n    // Canvas size\n    if (model.renderable) {\n      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {\n        previousSize[0] = model.size[0];\n        previousSize[1] = model.size[1];\n        model.canvas.setAttribute('width', model.size[0]);\n        model.canvas.setAttribute('height', model.size[1]);\n        publicAPI.recreateSwapChain();\n      }\n    }\n\n    // ImageStream size\n    if (model.viewStream) {\n      // If same size that's a NoOp\n      model.viewStream.setSize(model.size[0], model.size[1]);\n    }\n\n    // Offscreen ?\n    model.canvas.style.display = model.useOffScreen ? 'none' : 'block';\n\n    // Cursor type\n    if (model.el) {\n      model.el.style.cursor = model.cursorVisibility ? model.cursor : 'none';\n    }\n\n    // Invalidate cached DOM container size\n    model.containerSize = null;\n  }\n  publicAPI.onModified(updateWindow);\n  publicAPI.recreateSwapChain = () => {\n    if (model.context) {\n      model.context.unconfigure();\n      model.presentationFormat = navigator.gpu.getPreferredCanvasFormat(model.adapter);\n\n      /* eslint-disable no-undef */\n      /* eslint-disable no-bitwise */\n      model.context.configure({\n        device: model.device.getHandle(),\n        format: model.presentationFormat,\n        alphaMode: 'premultiplied',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,\n        width: model.size[0],\n        height: model.size[1]\n      });\n      model._configured = true;\n    }\n  };\n  publicAPI.getCurrentTexture = () => model.context.getCurrentTexture();\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());\n      publicAPI.removeUnusedNodes();\n      publicAPI.initialize();\n    } else if (model.initialized) {\n      if (!model._configured) {\n        publicAPI.recreateSwapChain();\n      }\n      model.commandEncoder = model.device.createCommandEncoder();\n    }\n  };\n\n  // publicAPI.traverseRenderers = (renPass) => {\n  //   // iterate over renderers\n  //   const numlayers = publicAPI.getRenderable().getNumberOfLayers();\n  //   const renderers = publicAPI.getChildren();\n  //   for (let i = 0; i < numlayers; i++) {\n  //     for (let index = 0; index < renderers.length; index++) {\n  //       const renNode = renderers[index];\n  //       const ren = publicAPI.getRenderable().getRenderers()[index];\n  //       if (ren.getDraw() && ren.getLayer() === i) {\n  //         renNode.traverse(renPass);\n  //       }\n  //     }\n  //   }\n  // };\n\n  publicAPI.initialize = () => {\n    if (!model.initializing) {\n      model.initializing = true;\n      if (!navigator.gpu) {\n        vtkErrorMacro('WebGPU is not enabled.');\n        return;\n      }\n      publicAPI.create3DContextAsync().then(() => {\n        model.initialized = true;\n        if (model.deleted) {\n          return;\n        }\n        publicAPI.invokeInitialized();\n      });\n    }\n  };\n  publicAPI.setContainer = el => {\n    if (model.el && model.el !== el) {\n      if (model.canvas.parentNode !== model.el) {\n        vtkErrorMacro('Error: canvas parent node does not match container');\n      }\n\n      // Remove canvas from previous container\n      model.el.removeChild(model.canvas);\n\n      // If the renderer has previously added\n      // a background image, remove it from the DOM.\n      if (model.el.contains(model.bgImage)) {\n        model.el.removeChild(model.bgImage);\n      }\n    }\n    if (model.el !== el) {\n      model.el = el;\n      if (model.el) {\n        model.el.appendChild(model.canvas);\n\n        // If the renderer is set to use a background\n        // image, attach it to the DOM.\n        if (model.useBackgroundImage) {\n          model.el.appendChild(model.bgImage);\n        }\n      }\n\n      // Trigger modified()\n      publicAPI.modified();\n    }\n  };\n  publicAPI.getContainer = () => model.el;\n  publicAPI.getContainerSize = () => {\n    if (!model.containerSize && model.el) {\n      const {\n        width,\n        height\n      } = model.el.getBoundingClientRect();\n      model.containerSize = [width, height];\n    }\n    return model.containerSize || model.size;\n  };\n  publicAPI.getFramebufferSize = () => model.size;\n  publicAPI.create3DContextAsync = async () => {\n    // Get a GPU device to render with\n    model.adapter = await navigator.gpu.requestAdapter({\n      powerPreference: 'high-performance'\n    });\n    if (model.deleted) {\n      return;\n    }\n    // console.log([...model.adapter.features]);\n    model.device = vtkWebGPUDevice.newInstance();\n    model.device.initialize(await model.adapter.requestDevice());\n    if (model.deleted) {\n      model.device = null;\n      return;\n    }\n    // model.device.getHandle().lost.then((info) => {\n    //   console.log(`${info.message}`);\n    //   publicAPI.releaseGraphicsResources();\n    // });\n    model.context = model.canvas.getContext('webgpu');\n  };\n  publicAPI.releaseGraphicsResources = () => {\n    const rp = vtkRenderPass.newInstance();\n    rp.setCurrentOperation('Release');\n    rp.traverse(publicAPI, null);\n    model.adapter = null;\n    model.device = null;\n    model.context = null;\n    model.initialized = false;\n    model.initializing = false;\n  };\n  publicAPI.setBackgroundImage = img => {\n    model.bgImage.src = img.src;\n  };\n  publicAPI.setUseBackgroundImage = value => {\n    model.useBackgroundImage = value;\n\n    // Add or remove the background image from the\n    // DOM as specified.\n    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {\n      model.el.appendChild(model.bgImage);\n    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {\n      model.el.removeChild(model.bgImage);\n    }\n  };\n  async function getCanvasDataURL() {\n    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.imageFormat;\n    // Copy current canvas to not modify the original\n    const temporaryCanvas = document.createElement('canvas');\n    const temporaryContext = temporaryCanvas.getContext('2d');\n    temporaryCanvas.width = model.canvas.width;\n    temporaryCanvas.height = model.canvas.height;\n    const result = await publicAPI.getPixelsAsync();\n    const imageData = new ImageData(result.colorValues, result.width, result.height);\n    // temporaryCanvas.putImageData(imageData, 0, 0);\n    temporaryContext.putImageData(imageData, 0, 0);\n\n    // Get current client rect to place canvas\n    const mainBoundingClientRect = model.canvas.getBoundingClientRect();\n    const renderWindow = model.renderable;\n    const renderers = renderWindow.getRenderers();\n    renderers.forEach(renderer => {\n      const viewProps = renderer.getViewProps();\n      viewProps.forEach(viewProp => {\n        // Check if the prop has a container that should have canvas\n        if (viewProp.getContainer) {\n          const container = viewProp.getContainer();\n          const canvasList = container.getElementsByTagName('canvas');\n          // Go throughout all canvas and copy it into temporary main canvas\n          for (let i = 0; i < canvasList.length; i++) {\n            const currentCanvas = canvasList[i];\n            const boundingClientRect = currentCanvas.getBoundingClientRect();\n            const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;\n            const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;\n            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);\n          }\n        }\n      });\n    });\n    const screenshot = temporaryCanvas.toDataURL(format);\n    temporaryCanvas.remove();\n    publicAPI.invokeImageReady(screenshot);\n  }\n  publicAPI.captureNextImage = function () {\n    let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';\n    let {\n      resetCamera = false,\n      size = null,\n      scale = 1\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (model.deleted) {\n      return null;\n    }\n    model.imageFormat = format;\n    const previous = model.notifyStartCaptureImage;\n    model.notifyStartCaptureImage = true;\n    model._screenshot = {\n      size: !!size || scale !== 1 ? size || model.size.map(val => val * scale) : null\n    };\n    return new Promise((resolve, reject) => {\n      const subscription = publicAPI.onImageReady(imageURL => {\n        if (model._screenshot.size === null) {\n          model.notifyStartCaptureImage = previous;\n          subscription.unsubscribe();\n          if (model._screenshot.placeHolder) {\n            // resize the main canvas back to its original size and show it\n            model.size = model._screenshot.originalSize;\n\n            // process the resize\n            publicAPI.modified();\n\n            // restore the saved camera parameters, if applicable\n            if (model._screenshot.cameras) {\n              model._screenshot.cameras.forEach(_ref => {\n                let {\n                  restoreParamsFn,\n                  arg\n                } = _ref;\n                return restoreParamsFn(arg);\n              });\n            }\n\n            // Trigger a render at the original size\n            publicAPI.traverseAllPasses();\n\n            // Remove and clean up the placeholder, revealing the original\n            model.el.removeChild(model._screenshot.placeHolder);\n            model._screenshot.placeHolder.remove();\n            model._screenshot = null;\n          }\n          resolve(imageURL);\n        } else {\n          // Create a placeholder image overlay while we resize and render\n          const tmpImg = document.createElement('img');\n          tmpImg.style = SCREENSHOT_PLACEHOLDER;\n          tmpImg.src = imageURL;\n          model._screenshot.placeHolder = model.el.appendChild(tmpImg);\n\n          // hide the main canvas\n          model.canvas.style.display = 'none';\n\n          // remember the main canvas original size, then resize it\n          model._screenshot.originalSize = model.size;\n          model.size = model._screenshot.size;\n          model._screenshot.size = null;\n\n          // process the resize\n          publicAPI.modified();\n          if (resetCamera) {\n            const isUserResetCamera = resetCamera !== true;\n\n            // If resetCamera was requested, we first save camera parameters\n            // from all the renderers, so we can restore them later\n            model._screenshot.cameras = model.renderable.getRenderers().map(renderer => {\n              const camera = renderer.getActiveCamera();\n              const params = camera.get('focalPoint', 'position', 'parallelScale');\n              return {\n                resetCameraArgs: isUserResetCamera ? {\n                  renderer\n                } : undefined,\n                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,\n                restoreParamsFn: camera.set,\n                // \"clone\" the params so we don't keep refs to properties\n                arg: JSON.parse(JSON.stringify(params))\n              };\n            });\n\n            // Perform the resetCamera() on each renderer only after capturing\n            // the params from all active cameras, in case there happen to be\n            // linked cameras among the renderers.\n            model._screenshot.cameras.forEach(_ref2 => {\n              let {\n                resetCameraFn,\n                resetCameraArgs\n              } = _ref2;\n              return resetCameraFn(resetCameraArgs);\n            });\n          }\n\n          // Trigger a render at the custom size\n          publicAPI.traverseAllPasses();\n        }\n      });\n    });\n  };\n  publicAPI.traverseAllPasses = () => {\n    if (model.deleted) {\n      return;\n    }\n    // if we are not initialized then we call initialize\n    // which is async so we will not actually get a render\n    // so we queue up another traverse for when we are initialized\n    if (!model.initialized) {\n      publicAPI.initialize();\n      const subscription = publicAPI.onInitialized(() => {\n        subscription.unsubscribe();\n        publicAPI.traverseAllPasses();\n      });\n    } else {\n      if (model.renderPasses) {\n        for (let index = 0; index < model.renderPasses.length; ++index) {\n          model.renderPasses[index].traverse(publicAPI, null);\n        }\n      }\n      if (model.commandEncoder) {\n        model.device.submitCommandEncoder(model.commandEncoder);\n        model.commandEncoder = null;\n        if (model.notifyStartCaptureImage) {\n          model.device.onSubmittedWorkDone().then(() => {\n            getCanvasDataURL();\n          });\n        }\n      }\n    }\n  };\n  publicAPI.setViewStream = stream => {\n    if (model.viewStream === stream) {\n      return false;\n    }\n    if (model.subscription) {\n      model.subscription.unsubscribe();\n      model.subscription = null;\n    }\n    model.viewStream = stream;\n    if (model.viewStream) {\n      // Force background to be transparent + render\n      const mainRenderer = model.renderable.getRenderers()[0];\n      mainRenderer.getBackgroundByReference()[3] = 0;\n\n      // Enable display of the background image\n      publicAPI.setUseBackgroundImage(true);\n\n      // Bind to remote stream\n      model.subscription = model.viewStream.onImageReady(e => publicAPI.setBackgroundImage(e.image));\n      model.viewStream.setSize(model.size[0], model.size[1]);\n      model.viewStream.invalidateCache();\n      model.viewStream.render();\n      publicAPI.modified();\n    }\n    return true;\n  };\n  publicAPI.getUniquePropID = () => model.nextPropID++;\n  publicAPI.getPropFromID = id => {\n    for (let i = 0; i < model.children.length; i++) {\n      const res = model.children[i].getPropFromID(id);\n      if (res !== null) {\n        return res;\n      }\n    }\n    return null;\n  };\n  publicAPI.getPixelsAsync = async () => {\n    const device = model.device;\n    const texture = model.renderPasses[0].getOpaquePass().getColorTexture();\n\n    // as this is async we really don't want to store things in\n    // the class as multiple calls may start before resolving\n    // so anything specific to this request gets put into the\n    // result object (by value in most cases)\n    const result = {\n      width: texture.getWidth(),\n      height: texture.getHeight()\n    };\n\n    // must be a multiple of 256 bytes, so 32 texels with rgba16\n    result.colorBufferWidth = 32 * Math.floor((result.width + 31) / 32);\n    result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 8;\n    const colorBuffer = vtkWebGPUBuffer.newInstance();\n    colorBuffer.setDevice(device);\n    /* eslint-disable no-bitwise */\n    /* eslint-disable no-undef */\n    colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n    /* eslint-enable no-bitwise */\n    /* eslint-enable no-undef */\n\n    const cmdEnc = model.device.createCommandEncoder();\n    cmdEnc.copyTextureToBuffer({\n      texture: texture.getHandle()\n    }, {\n      buffer: colorBuffer.getHandle(),\n      bytesPerRow: 8 * result.colorBufferWidth,\n      rowsPerImage: result.height\n    }, {\n      width: result.width,\n      height: result.height,\n      depthOrArrayLayers: 1\n    });\n    device.submitCommandEncoder(cmdEnc);\n\n    /* eslint-disable no-undef */\n    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);\n    await cLoad;\n    /* eslint-enable no-undef */\n\n    result.colorValues = new Uint16Array(colorBuffer.getMappedRange().slice());\n    colorBuffer.unmap();\n    // repack the array\n    const tmparray = new Uint8ClampedArray(result.height * result.width * 4);\n    for (let y = 0; y < result.height; y++) {\n      for (let x = 0; x < result.width; x++) {\n        const doffset = (y * result.width + x) * 4;\n        const soffset = (y * result.colorBufferWidth + x) * 4;\n        tmparray[doffset] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset]);\n        tmparray[doffset + 1] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset + 1]);\n        tmparray[doffset + 2] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset + 2]);\n        tmparray[doffset + 3] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset + 3]);\n      }\n    }\n    result.colorValues = tmparray;\n    return result;\n  };\n  publicAPI.createSelector = () => {\n    const ret = vtkWebGPUHardwareSelector.newInstance();\n    ret.setWebGPURenderWindow(publicAPI);\n    return ret;\n  };\n  const superSetSize = publicAPI.setSize;\n  publicAPI.setSize = (width, height) => {\n    const modified = superSetSize(width, height);\n    if (modified) {\n      publicAPI.invokeWindowResizeEvent({\n        width,\n        height\n      });\n    }\n    return modified;\n  };\n  publicAPI.delete = macro.chain(publicAPI.delete, publicAPI.setViewStream);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  initialized: false,\n  context: null,\n  adapter: null,\n  device: null,\n  canvas: null,\n  cursorVisibility: true,\n  cursor: 'pointer',\n  containerSize: null,\n  renderPasses: [],\n  notifyStartCaptureImage: false,\n  imageFormat: 'image/png',\n  useOffScreen: false,\n  useBackgroundImage: false,\n  nextPropID: 1,\n  xrSupported: false,\n  presentationFormat: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Create internal instances\n  model.canvas = document.createElement('canvas');\n  model.canvas.style.width = '100%';\n\n  // Create internal bgImage\n  model.bgImage = new Image();\n  model.bgImage.style.position = 'absolute';\n  model.bgImage.style.left = '0';\n  model.bgImage.style.top = '0';\n  model.bgImage.style.width = '100%';\n  model.bgImage.style.height = '100%';\n  model.bgImage.style.zIndex = '-1';\n\n  // Inheritance\n  vtkRenderWindowViewNode.extend(publicAPI, model, initialValues);\n  model.myFactory = vtkWebGPUViewNodeFactory.newInstance();\n\n  // setup default forward pass rendering\n  model.renderPasses[0] = vtkForwardPass.newInstance();\n  if (!model.selector) {\n    model.selector = vtkWebGPUHardwareSelector.newInstance();\n    model.selector.setWebGPURenderWindow(publicAPI);\n  }\n  macro.event(publicAPI, model, 'imageReady');\n  macro.event(publicAPI, model, 'initialized');\n\n  // Build VTK API\n  macro.get(publicAPI, model, ['commandEncoder', 'device', 'presentationFormat', 'useBackgroundImage', 'xrSupported']);\n  macro.setGet(publicAPI, model, ['initialized', 'context', 'canvas', 'device', 'renderPasses', 'notifyStartCaptureImage', 'cursor', 'useOffScreen']);\n  macro.setGetArray(publicAPI, model, ['size'], 2);\n  macro.event(publicAPI, model, 'windowResizeEvent');\n\n  // Object methods\n  vtkWebGPURenderWindow(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPURenderWindow');\n\n// ----------------------------------------------------------------------------\n// Register API specific RenderWindow implementation\n// ----------------------------------------------------------------------------\n\nregisterViewConstructor('WebGPU', newInstance);\n\n// ----------------------------------------------------------------------------\n\nvar vtkRenderWindow = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkRenderWindow', newInstance);\n\nexport { vtkRenderWindow as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}