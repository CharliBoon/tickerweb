{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro, v as vtkWarningMacro } from '../../macros2.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\n\n// ----------------------------------------------------------------------------\n// vtkMouseRangeManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseRangeManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseRangeManipulator');\n\n  // Keep track of delta that is below the value\n  // of one step to progressively increment it\n  const incrementalDelta = new Map();\n\n  // Internal methods\n  //-------------------------------------------------------------------------\n  function scaleDeltaToRange(listener, normalizedDelta) {\n    return normalizedDelta * ((listener.max - listener.min) / (listener.step + 1));\n  }\n\n  //-------------------------------------------------------------------------\n  function processDelta(listener, delta) {\n    const oldValue = listener.getValue();\n\n    // if exponential scroll is enabled, we raise our scale to the\n    //  exponent of the net delta of the interaction. The further away\n    // the user's cursor is from the start of the interaction, the more\n    // their movements will effect the value.\n    let scalingFactor = listener.exponentialScroll ? listener.scale ** Math.log2(Math.abs(model.interactionNetDelta) + 2) : listener.scale;\n\n    // Preserve the sign of scale (which can be used to invert the scrolling direction)\n    // after the power operation above (in case of exponentialScroll).\n    scalingFactor = Math.abs(scalingFactor) * Math.sign(listener.scale);\n    const newDelta = delta * scalingFactor + incrementalDelta.get(listener);\n\n    // Compute new value based on step\n    // In the following line, Math.abs is required so that the floor function\n    // consistently rounds to the lowest absolute integer.\n    const stepsToDifference = Math.floor(Math.abs(newDelta / listener.step));\n    let value = oldValue + listener.step * stepsToDifference * Math.sign(newDelta);\n    value = Math.max(value, listener.min);\n    value = Math.min(value, listener.max);\n    if (value !== oldValue) {\n      // Update value\n      listener.setValue(value);\n      incrementalDelta.set(listener, 0);\n    } else if (value === listener.min && newDelta < 0 || value === listener.max && newDelta > 0) {\n      // Do not allow incremental delta to go past range\n      incrementalDelta.set(listener, 0);\n    } else {\n      // Store delta for the next iteration\n      incrementalDelta.set(listener, newDelta);\n    }\n  }\n\n  // Public API methods\n\n  // min:number = minimum allowable value\n  // max:number = maximum allowable value\n  // step:number = value per step -- smaller = more steps over a given distance, larger = fewer steps over a given distance\n  // getValue:fn = function that returns current value\n  // setValue:fn = function to set value\n  // scale:number = scale value is applied to mouse event to allow users accelerate or decelerate delta without emitting more events\n  //-------------------------------------------------------------------------\n  publicAPI.setHorizontalListener = function (min, max, step, getValue, setValue) {\n    let scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    let exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    const getFn = Number.isFinite(getValue) ? () => getValue : getValue;\n    model.horizontalListener = {\n      min,\n      max,\n      step,\n      getValue: getFn,\n      setValue,\n      scale,\n      exponentialScroll\n    };\n    incrementalDelta.set(model.horizontalListener, 0);\n    publicAPI.modified();\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.setVerticalListener = function (min, max, step, getValue, setValue) {\n    let scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    let exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    const getFn = Number.isFinite(getValue) ? () => getValue : getValue;\n    model.verticalListener = {\n      min,\n      max,\n      step,\n      getValue: getFn,\n      setValue,\n      scale,\n      exponentialScroll\n    };\n    incrementalDelta.set(model.verticalListener, 0);\n    publicAPI.modified();\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.setScrollListener = function (min, max, step, getValue, setValue) {\n    let scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    let exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    if (step < 0) {\n      vtkWarningMacro('Value of step cannot be negative. If you want to invert the scrolling direction, use a negative scale value instead.');\n    }\n    const stepSize = Math.abs(step);\n    const getFn = Number.isFinite(getValue) ? () => getValue : getValue;\n    model.scrollListener = {\n      min,\n      max,\n      step: stepSize,\n      getValue: getFn,\n      setValue,\n      scale,\n      exponentialScroll\n    };\n    incrementalDelta.set(model.scrollListener, 0);\n    publicAPI.modified();\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.removeHorizontalListener = () => {\n    if (model.horizontalListener) {\n      incrementalDelta.delete(model.horizontalListener);\n      delete model.horizontalListener;\n      publicAPI.modified();\n    }\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.removeVerticalListener = () => {\n    if (model.verticalListener) {\n      incrementalDelta.delete(model.verticalListener);\n      delete model.verticalListener;\n      publicAPI.modified();\n    }\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.removeScrollListener = () => {\n    if (model.scrollListener) {\n      incrementalDelta.delete(model.scrollListener);\n      delete model.scrollListener;\n      publicAPI.modified();\n    }\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.removeAllListeners = () => {\n    publicAPI.removeHorizontalListener();\n    publicAPI.removeVerticalListener();\n    publicAPI.removeScrollListener();\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.previousPosition = position;\n    model.interactionNetDelta = 0;\n    const glRenderWindow = interactor.getView();\n    // Ratio is the dom size vs renderwindow size\n    const ratio = glRenderWindow.getContainerSize()[0] / glRenderWindow.getSize()[0];\n    // Get proper pixel range used by viewport in rw size space\n    const size = glRenderWindow.getViewportSize(renderer);\n    // rescale size to match mouse event position\n    model.containerSize = size.map(v => v * ratio);\n  };\n  publicAPI.onButtonUp = interactor => {\n    interactor.exitPointerLock();\n  };\n\n  //--------------------------------------------------------------------------\n\n  // TODO: at some point, this should perhaps be done in\n  // RenderWindowInteractor instead of here.\n  // We need to hook into mousemove directly for two reasons:\n  // 1. We need to keep receiving mouse move events after the mouse button\n  //    is released. This is currently not possible with\n  //    vtkInteractorStyleManipulator.\n  // 2. Since the mouse is stationary in pointer lock mode, we need the\n  //    event.movementX and event.movementY info, which are not currently\n  //    passed via interactor.onMouseMove.\n  publicAPI.startPointerLockEvent = (interactor, renderer) => {\n    const handlePointerLockMove = event => {\n      publicAPI.onPointerLockMove(interactor, renderer, event);\n    };\n    document.addEventListener('mousemove', handlePointerLockMove);\n    let subscription = null;\n    const endInteraction = () => {\n      document.removeEventListener('mousemove', handlePointerLockMove);\n      subscription?.unsubscribe();\n    };\n    subscription = interactor?.onEndPointerLock(endInteraction);\n  };\n  publicAPI.onPointerLockMove = (interactor, renderer, event) => {\n    // There is a slight delay between the `onEndPointerLock` call\n    // and the last `onMouseMove` event, we must make sure the pointer\n    // is still locked before we run this logic otherwise we may\n    // get a `onMouseMove` call after the pointer has been unlocked.\n    if (!interactor.isPointerLocked()) return;\n\n    // previousPosition could be undefined if for some reason the\n    // `startPointerLockEvent` method is called before the `onButtonDown` one.\n    if (model.previousPosition == null) return;\n    model.previousPosition.x += event.movementX;\n    model.previousPosition.y += event.movementY;\n    publicAPI.onMouseMove(interactor, renderer, model.previousPosition);\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!model.verticalListener && !model.horizontalListener) {\n      return;\n    }\n\n    // We only want to initialize the pointer lock listener\n    // after the user starts moving their mouse, this way\n    // we don't interfere with other events such as doubleClick,\n    // for this reason we don't call this from `onButtonDown`\n    if (model.usePointerLock && !interactor.isPointerLocked()) {\n      interactor.requestPointerLock();\n      publicAPI.startPointerLockEvent(interactor, renderer);\n    }\n    if (!position) {\n      return;\n    }\n    if (model.horizontalListener) {\n      const dxNorm = (position.x - model.previousPosition.x) / model.containerSize[0];\n      const dx = scaleDeltaToRange(model.horizontalListener, dxNorm);\n      model.interactionNetDelta += dx;\n      processDelta(model.horizontalListener, dx);\n    }\n    if (model.verticalListener) {\n      const dyNorm = (position.y - model.previousPosition.y) / model.containerSize[1];\n      const dy = scaleDeltaToRange(model.verticalListener, dyNorm);\n      model.interactionNetDelta += dy;\n      processDelta(model.verticalListener, dy);\n    }\n    model.previousPosition = position;\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.onScroll = (interactor, renderer, delta) => {\n    if (!model.scrollListener || !delta) {\n      return;\n    }\n    model.interactionNetDelta += delta * model.scrollListener.step;\n    processDelta(model.scrollListener, delta * model.scrollListener.step);\n  };\n  publicAPI.onStartScroll = () => {\n    model.interactionNetDelta = 0;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  horizontalListener: null,\n  verticalListener: null,\n  scrollListener: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['usePointerLock']);\n\n  // Object specific methods\n  vtkMouseRangeManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseRangeManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseRangeManipulator$1 = {\n  newInstance,\n  extend\n};\nexport { vtkMouseRangeManipulator$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","v","vtkWarningMacro","vtkCompositeMouseManipulator","vtkMouseRangeManipulator","publicAPI","model","classHierarchy","push","incrementalDelta","Map","scaleDeltaToRange","listener","normalizedDelta","max","min","step","processDelta","delta","oldValue","getValue","scalingFactor","exponentialScroll","scale","Math","log2","abs","interactionNetDelta","sign","newDelta","get","stepsToDifference","floor","value","setValue","set","setHorizontalListener","arguments","length","undefined","getFn","Number","isFinite","horizontalListener","modified","setVerticalListener","verticalListener","setScrollListener","stepSize","scrollListener","removeHorizontalListener","delete","removeVerticalListener","removeScrollListener","removeAllListeners","onButtonDown","interactor","renderer","position","previousPosition","glRenderWindow","getView","ratio","getContainerSize","getSize","size","getViewportSize","containerSize","map","onButtonUp","exitPointerLock","startPointerLockEvent","handlePointerLockMove","event","onPointerLockMove","document","addEventListener","subscription","endInteraction","removeEventListener","unsubscribe","onEndPointerLock","isPointerLocked","x","movementX","y","movementY","onMouseMove","usePointerLock","requestPointerLock","dxNorm","dx","dyNorm","dy","onScroll","onStartScroll","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","newInstance","vtkMouseRangeManipulator$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseRangeManipulator.js"],"sourcesContent":["import { m as macro, v as vtkWarningMacro } from '../../macros2.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\n\n// ----------------------------------------------------------------------------\n// vtkMouseRangeManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseRangeManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseRangeManipulator');\n\n  // Keep track of delta that is below the value\n  // of one step to progressively increment it\n  const incrementalDelta = new Map();\n\n  // Internal methods\n  //-------------------------------------------------------------------------\n  function scaleDeltaToRange(listener, normalizedDelta) {\n    return normalizedDelta * ((listener.max - listener.min) / (listener.step + 1));\n  }\n\n  //-------------------------------------------------------------------------\n  function processDelta(listener, delta) {\n    const oldValue = listener.getValue();\n\n    // if exponential scroll is enabled, we raise our scale to the\n    //  exponent of the net delta of the interaction. The further away\n    // the user's cursor is from the start of the interaction, the more\n    // their movements will effect the value.\n    let scalingFactor = listener.exponentialScroll ? listener.scale ** Math.log2(Math.abs(model.interactionNetDelta) + 2) : listener.scale;\n\n    // Preserve the sign of scale (which can be used to invert the scrolling direction)\n    // after the power operation above (in case of exponentialScroll).\n    scalingFactor = Math.abs(scalingFactor) * Math.sign(listener.scale);\n    const newDelta = delta * scalingFactor + incrementalDelta.get(listener);\n\n    // Compute new value based on step\n    // In the following line, Math.abs is required so that the floor function\n    // consistently rounds to the lowest absolute integer.\n    const stepsToDifference = Math.floor(Math.abs(newDelta / listener.step));\n    let value = oldValue + listener.step * stepsToDifference * Math.sign(newDelta);\n    value = Math.max(value, listener.min);\n    value = Math.min(value, listener.max);\n    if (value !== oldValue) {\n      // Update value\n      listener.setValue(value);\n      incrementalDelta.set(listener, 0);\n    } else if (value === listener.min && newDelta < 0 || value === listener.max && newDelta > 0) {\n      // Do not allow incremental delta to go past range\n      incrementalDelta.set(listener, 0);\n    } else {\n      // Store delta for the next iteration\n      incrementalDelta.set(listener, newDelta);\n    }\n  }\n\n  // Public API methods\n\n  // min:number = minimum allowable value\n  // max:number = maximum allowable value\n  // step:number = value per step -- smaller = more steps over a given distance, larger = fewer steps over a given distance\n  // getValue:fn = function that returns current value\n  // setValue:fn = function to set value\n  // scale:number = scale value is applied to mouse event to allow users accelerate or decelerate delta without emitting more events\n  //-------------------------------------------------------------------------\n  publicAPI.setHorizontalListener = function (min, max, step, getValue, setValue) {\n    let scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    let exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    const getFn = Number.isFinite(getValue) ? () => getValue : getValue;\n    model.horizontalListener = {\n      min,\n      max,\n      step,\n      getValue: getFn,\n      setValue,\n      scale,\n      exponentialScroll\n    };\n    incrementalDelta.set(model.horizontalListener, 0);\n    publicAPI.modified();\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.setVerticalListener = function (min, max, step, getValue, setValue) {\n    let scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    let exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    const getFn = Number.isFinite(getValue) ? () => getValue : getValue;\n    model.verticalListener = {\n      min,\n      max,\n      step,\n      getValue: getFn,\n      setValue,\n      scale,\n      exponentialScroll\n    };\n    incrementalDelta.set(model.verticalListener, 0);\n    publicAPI.modified();\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.setScrollListener = function (min, max, step, getValue, setValue) {\n    let scale = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n    let exponentialScroll = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    if (step < 0) {\n      vtkWarningMacro('Value of step cannot be negative. If you want to invert the scrolling direction, use a negative scale value instead.');\n    }\n    const stepSize = Math.abs(step);\n    const getFn = Number.isFinite(getValue) ? () => getValue : getValue;\n    model.scrollListener = {\n      min,\n      max,\n      step: stepSize,\n      getValue: getFn,\n      setValue,\n      scale,\n      exponentialScroll\n    };\n    incrementalDelta.set(model.scrollListener, 0);\n    publicAPI.modified();\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.removeHorizontalListener = () => {\n    if (model.horizontalListener) {\n      incrementalDelta.delete(model.horizontalListener);\n      delete model.horizontalListener;\n      publicAPI.modified();\n    }\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.removeVerticalListener = () => {\n    if (model.verticalListener) {\n      incrementalDelta.delete(model.verticalListener);\n      delete model.verticalListener;\n      publicAPI.modified();\n    }\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.removeScrollListener = () => {\n    if (model.scrollListener) {\n      incrementalDelta.delete(model.scrollListener);\n      delete model.scrollListener;\n      publicAPI.modified();\n    }\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.removeAllListeners = () => {\n    publicAPI.removeHorizontalListener();\n    publicAPI.removeVerticalListener();\n    publicAPI.removeScrollListener();\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.previousPosition = position;\n    model.interactionNetDelta = 0;\n    const glRenderWindow = interactor.getView();\n    // Ratio is the dom size vs renderwindow size\n    const ratio = glRenderWindow.getContainerSize()[0] / glRenderWindow.getSize()[0];\n    // Get proper pixel range used by viewport in rw size space\n    const size = glRenderWindow.getViewportSize(renderer);\n    // rescale size to match mouse event position\n    model.containerSize = size.map(v => v * ratio);\n  };\n  publicAPI.onButtonUp = interactor => {\n    interactor.exitPointerLock();\n  };\n\n  //--------------------------------------------------------------------------\n\n  // TODO: at some point, this should perhaps be done in\n  // RenderWindowInteractor instead of here.\n  // We need to hook into mousemove directly for two reasons:\n  // 1. We need to keep receiving mouse move events after the mouse button\n  //    is released. This is currently not possible with\n  //    vtkInteractorStyleManipulator.\n  // 2. Since the mouse is stationary in pointer lock mode, we need the\n  //    event.movementX and event.movementY info, which are not currently\n  //    passed via interactor.onMouseMove.\n  publicAPI.startPointerLockEvent = (interactor, renderer) => {\n    const handlePointerLockMove = event => {\n      publicAPI.onPointerLockMove(interactor, renderer, event);\n    };\n    document.addEventListener('mousemove', handlePointerLockMove);\n    let subscription = null;\n    const endInteraction = () => {\n      document.removeEventListener('mousemove', handlePointerLockMove);\n      subscription?.unsubscribe();\n    };\n    subscription = interactor?.onEndPointerLock(endInteraction);\n  };\n  publicAPI.onPointerLockMove = (interactor, renderer, event) => {\n    // There is a slight delay between the `onEndPointerLock` call\n    // and the last `onMouseMove` event, we must make sure the pointer\n    // is still locked before we run this logic otherwise we may\n    // get a `onMouseMove` call after the pointer has been unlocked.\n    if (!interactor.isPointerLocked()) return;\n\n    // previousPosition could be undefined if for some reason the\n    // `startPointerLockEvent` method is called before the `onButtonDown` one.\n    if (model.previousPosition == null) return;\n    model.previousPosition.x += event.movementX;\n    model.previousPosition.y += event.movementY;\n    publicAPI.onMouseMove(interactor, renderer, model.previousPosition);\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!model.verticalListener && !model.horizontalListener) {\n      return;\n    }\n\n    // We only want to initialize the pointer lock listener\n    // after the user starts moving their mouse, this way\n    // we don't interfere with other events such as doubleClick,\n    // for this reason we don't call this from `onButtonDown`\n    if (model.usePointerLock && !interactor.isPointerLocked()) {\n      interactor.requestPointerLock();\n      publicAPI.startPointerLockEvent(interactor, renderer);\n    }\n    if (!position) {\n      return;\n    }\n    if (model.horizontalListener) {\n      const dxNorm = (position.x - model.previousPosition.x) / model.containerSize[0];\n      const dx = scaleDeltaToRange(model.horizontalListener, dxNorm);\n      model.interactionNetDelta += dx;\n      processDelta(model.horizontalListener, dx);\n    }\n    if (model.verticalListener) {\n      const dyNorm = (position.y - model.previousPosition.y) / model.containerSize[1];\n      const dy = scaleDeltaToRange(model.verticalListener, dyNorm);\n      model.interactionNetDelta += dy;\n      processDelta(model.verticalListener, dy);\n    }\n    model.previousPosition = position;\n  };\n\n  //-------------------------------------------------------------------------\n  publicAPI.onScroll = (interactor, renderer, delta) => {\n    if (!model.scrollListener || !delta) {\n      return;\n    }\n    model.interactionNetDelta += delta * model.scrollListener.step;\n    processDelta(model.scrollListener, delta * model.scrollListener.step);\n  };\n  publicAPI.onStartScroll = () => {\n    model.interactionNetDelta = 0;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  horizontalListener: null,\n  verticalListener: null,\n  scrollListener: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['usePointerLock']);\n\n  // Object specific methods\n  vtkMouseRangeManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseRangeManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseRangeManipulator$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkMouseRangeManipulator$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}