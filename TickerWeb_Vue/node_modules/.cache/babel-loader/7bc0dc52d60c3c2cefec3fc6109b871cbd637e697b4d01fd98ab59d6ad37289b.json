{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\nimport vtkInteractorStyleConstants from '../../Rendering/Core/InteractorStyle/Constants.js';\nimport vtkMouseCameraUnicamRotateManipulator from './MouseCameraUnicamRotateManipulator.js';\nimport { m as macro } from '../../macros2.js';\nimport { s as subtract, w as multiplyScalar, l as normalize, d as dot, r as radiansFromDegrees, j as cross } from '../../Common/Core/Math/index.js';\nconst {\n  States\n} = vtkInteractorStyleConstants;\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraUnicamManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraUnicamManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraUnicamManipulator');\n  model.state = States.IS_NONE;\n  model.rotateManipulator = vtkMouseCameraUnicamRotateManipulator.newInstance({\n    button: model.button,\n    shift: model.shift,\n    control: model.control,\n    alt: model.alt,\n    dragEnabled: model.dragEnabled,\n    scrollEnabled: model.scrollEnabled,\n    displayFocusSphereOnButtonDown: false\n  });\n\n  //----------------------------------------------------------------------------\n  const normalize$1 = (position, interactor) => {\n    const renderer = interactor.findPokedRenderer();\n    const [width, height] = interactor.getView().getViewportSize(renderer);\n    const nx = -1.0 + 2.0 * position.x / width;\n    const ny = -1.0 + 2.0 * position.y / height;\n    return {\n      x: nx,\n      y: ny\n    };\n  };\n\n  // Given a 3D point & a vtkCamera, compute the vectors that extend\n  // from the projection of the center of projection to the center of\n  // the right-edge and the center of the top-edge onto the plane\n  // containing the 3D point & with normal parallel to the camera's\n  // projection plane.\n  const getRightVAndUpV = (downPoint, interactor) => {\n    // Compute the horizontal & vertical scaling ('scalex' and 'scaley')\n    // factors as function of the down point & camera params.\n    const camera = interactor.findPokedRenderer().getActiveCamera();\n    const cameraPosition = camera.getPosition();\n    const cameraToPointVec = [0, 0, 0];\n\n    // Construct a vector from the viewing position to the picked point\n    subtract(downPoint, cameraPosition, cameraToPointVec);\n    if (camera.getParallelProjection()) {\n      multiplyScalar(cameraToPointVec, camera.getParallelScale());\n    }\n\n    // Get shortest distance 'l' between the viewing position and\n    // plane parallel to the projection plane that contains the 'downPoint'.\n    const atV = camera.getViewPlaneNormal();\n    normalize(atV);\n    const l = dot(cameraToPointVec, atV);\n    const viewAngle = radiansFromDegrees(camera.getViewAngle());\n    const renderer = interactor.findPokedRenderer();\n    const [width, height] = interactor.getView().getViewportSize(renderer);\n    const scaleX = width / height * (2 * l * Math.tan(viewAngle / 2) / 2);\n    const scaleY = 2 * l * Math.tan(viewAngle / 2) / 2;\n\n    // Construct the camera offset vector as function of delta mouse X & Y.\n    const upV = camera.getViewUp();\n    const rightV = [];\n    cross(upV, atV, rightV);\n    // (Make sure 'upV' is orthogonal to 'atV' & 'rightV')\n    cross(atV, rightV, upV);\n    normalize(rightV);\n    normalize(upV);\n    multiplyScalar(rightV, scaleX);\n    multiplyScalar(upV, scaleY);\n    return {\n      rightV,\n      upV\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  const choose = (interactor, position) => {\n    const normalizedPosition = normalize$1(position, interactor);\n    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);\n    const delta = {\n      x: normalizedPosition.x - normalizedPreviousPosition.x,\n      y: normalizedPosition.y - normalizedPreviousPosition.y\n    };\n    model.previousPosition = position;\n    const deltaT = Date.now() / 1000 - model.time;\n    model.dist += Math.sqrt(delta.x ** 2 + delta.y ** 2);\n    const sDelta = {\n      x: position.x - model.startPosition.x,\n      y: position.y - model.startPosition.y\n    };\n    const len = Math.sqrt(sDelta.x ** 2 + sDelta.y ** 2);\n    if (Math.abs(sDelta.y) / len > 0.9 && deltaT > 0.05) {\n      model.state = States.IS_DOLLY;\n    } else if (deltaT >= 0.1 || model.dist >= 0.03) {\n      if (Math.abs(sDelta.x) / len > 0.6) {\n        model.state = States.IS_PAN;\n      } else {\n        model.state = States.IS_DOLLY;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Transform mouse horizontal & vertical movements to a world\n  // space offset for the camera that maintains pick correlation.\n  const pan = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    const normalizedPosition = normalize$1(position, interactor);\n    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);\n    const delta = {\n      x: normalizedPosition.x - normalizedPreviousPosition.x,\n      y: normalizedPosition.y - normalizedPreviousPosition.y\n    };\n    const camera = renderer.getActiveCamera();\n    model.previousPosition = position;\n    const {\n      rightV,\n      upV\n    } = getRightVAndUpV(model.downPoint, interactor);\n    const offset = [];\n    for (let index = 0; index < 3; index++) {\n      offset[index] = delta.x * rightV[index] + delta.y * upV[index];\n    }\n    camera.translate(...offset);\n    renderer.resetCameraClippingRange();\n    interactor.render();\n  };\n\n  //----------------------------------------------------------------------------\n  const dolly = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    const normalizedPosition = normalize$1(position, interactor);\n    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);\n    const delta = {\n      x: normalizedPosition.x - normalizedPreviousPosition.x,\n      y: normalizedPosition.y - normalizedPreviousPosition.y\n    };\n    const camera = renderer.getActiveCamera();\n    const cameraPosition = camera.getPosition();\n\n    // 1. Handle dollying\n    if (camera.getParallelProjection()) {\n      camera.zoom(1 - delta.y);\n    } else {\n      const offset1 = [];\n      subtract(model.downPoint, cameraPosition, offset1);\n      multiplyScalar(offset1, delta.y * -4);\n      camera.translate(...offset1);\n    }\n\n    // 2. Now handle side-to-side panning\n    const {\n      rightV: offset2\n    } = getRightVAndUpV(model.downPoint, interactor);\n    multiplyScalar(offset2, delta.x);\n    camera.translate(...offset2);\n    renderer.resetCameraClippingRange();\n    interactor.render();\n  };\n\n  //----------------------------------------------------------------------------\n  // Public API methods\n  //----------------------------------------------------------------------------\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.buttonPressed = true;\n    model.startPosition = position;\n    model.previousPosition = position;\n    model.time = Date.now() / 1000.0;\n    model.dist = 0;\n\n    // Picking is delegated to the rotate manipulator\n    model.rotateManipulator.onButtonDown(interactor, renderer, position);\n    model.downPoint = model.rotateManipulator.getDownPoint();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!model.buttonPressed) {\n      return;\n    }\n    if (model.rotateManipulator.getState() === States.IS_ROTATE) {\n      model.rotateManipulator.onMouseMove(interactor, renderer, position);\n    } else {\n      switch (model.state) {\n        case States.IS_NONE:\n          choose(interactor, position);\n          break;\n        case States.IS_PAN:\n          pan(interactor, position);\n          break;\n        case States.IS_DOLLY:\n          dolly(interactor, position);\n          break;\n      }\n    }\n    model.previousPosition = position;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.onButtonUp = interactor => {\n    model.buttonPressed = false;\n    if (model.state === States.IS_NONE) {\n      model.rotateManipulator.onButtonUp(interactor);\n    }\n    model.state = States.IS_NONE;\n  };\n  publicAPI.getUseWorldUpVec = () => model.rotateManipulator.getUseWorldUpVec();\n  publicAPI.setUseWorldUpVec = useWorldUpVec => {\n    model.rotateManipulator.setUseWorldUpVec(useWorldUpVec);\n  };\n  publicAPI.getWorldUpVec = () => model.rotateManipulator.getWorldUpVec();\n  publicAPI.setWorldUpVec = (x, y, z) => {\n    model.rotateManipulator.setWorldUpVec(x, y, z);\n  };\n  publicAPI.getUseHardwareSelector = () => model.rotateManipulator.getUseHardwareSelector();\n  publicAPI.setUseHardwareSelector = useHardwareSelector => {\n    model.rotateManipulator.setUseHardwareSelector(useHardwareSelector);\n  };\n  publicAPI.getFocusSphereColor = () => {\n    model.rotateManipulator.getFocusSphereColor();\n  };\n  publicAPI.setFocusSphereColor = (r, g, b) => {\n    model.rotateManipulator.setFocusSphereColor(r, g, b);\n  };\n  publicAPI.getFocusSphereRadiusFactor = () => model.rotateManipulator.getFocusSphereRadiusFactor();\n  publicAPI.setFocusSphereRadiusFactor = focusSphereRadiusFactor => {\n    model.rotateManipulator.setFocusSphereRadiusFactor(focusSphereRadiusFactor);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Object specific methods\n  vtkMouseCameraUnicamManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraUnicamManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraUnicamManipulator$1 = {\n  newInstance,\n  extend\n};\nexport { vtkMouseCameraUnicamManipulator$1 as default, extend, newInstance };","map":{"version":3,"names":["vtkCompositeCameraManipulator","vtkCompositeMouseManipulator","vtkInteractorStyleConstants","vtkMouseCameraUnicamRotateManipulator","m","macro","s","subtract","w","multiplyScalar","l","normalize","d","dot","r","radiansFromDegrees","j","cross","States","vtkMouseCameraUnicamManipulator","publicAPI","model","classHierarchy","push","state","IS_NONE","rotateManipulator","newInstance","button","shift","control","alt","dragEnabled","scrollEnabled","displayFocusSphereOnButtonDown","normalize$1","position","interactor","renderer","findPokedRenderer","width","height","getView","getViewportSize","nx","x","ny","y","getRightVAndUpV","downPoint","camera","getActiveCamera","cameraPosition","getPosition","cameraToPointVec","getParallelProjection","getParallelScale","atV","getViewPlaneNormal","viewAngle","getViewAngle","scaleX","Math","tan","scaleY","upV","getViewUp","rightV","choose","normalizedPosition","normalizedPreviousPosition","previousPosition","delta","deltaT","Date","now","time","dist","sqrt","sDelta","startPosition","len","abs","IS_DOLLY","IS_PAN","pan","offset","index","translate","resetCameraClippingRange","render","dolly","zoom","offset1","offset2","onButtonDown","buttonPressed","getDownPoint","onMouseMove","getState","IS_ROTATE","onButtonUp","getUseWorldUpVec","setUseWorldUpVec","useWorldUpVec","getWorldUpVec","setWorldUpVec","z","getUseHardwareSelector","setUseHardwareSelector","useHardwareSelector","getFocusSphereColor","setFocusSphereColor","g","b","getFocusSphereRadiusFactor","setFocusSphereRadiusFactor","focusSphereRadiusFactor","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","obj","vtkMouseCameraUnicamManipulator$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraUnicamManipulator.js"],"sourcesContent":["import vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\nimport vtkInteractorStyleConstants from '../../Rendering/Core/InteractorStyle/Constants.js';\nimport vtkMouseCameraUnicamRotateManipulator from './MouseCameraUnicamRotateManipulator.js';\nimport { m as macro } from '../../macros2.js';\nimport { s as subtract, w as multiplyScalar, l as normalize, d as dot, r as radiansFromDegrees, j as cross } from '../../Common/Core/Math/index.js';\n\nconst {\n  States\n} = vtkInteractorStyleConstants;\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraUnicamManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraUnicamManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraUnicamManipulator');\n  model.state = States.IS_NONE;\n  model.rotateManipulator = vtkMouseCameraUnicamRotateManipulator.newInstance({\n    button: model.button,\n    shift: model.shift,\n    control: model.control,\n    alt: model.alt,\n    dragEnabled: model.dragEnabled,\n    scrollEnabled: model.scrollEnabled,\n    displayFocusSphereOnButtonDown: false\n  });\n\n  //----------------------------------------------------------------------------\n  const normalize$1 = (position, interactor) => {\n    const renderer = interactor.findPokedRenderer();\n    const [width, height] = interactor.getView().getViewportSize(renderer);\n    const nx = -1.0 + 2.0 * position.x / width;\n    const ny = -1.0 + 2.0 * position.y / height;\n    return {\n      x: nx,\n      y: ny\n    };\n  };\n\n  // Given a 3D point & a vtkCamera, compute the vectors that extend\n  // from the projection of the center of projection to the center of\n  // the right-edge and the center of the top-edge onto the plane\n  // containing the 3D point & with normal parallel to the camera's\n  // projection plane.\n  const getRightVAndUpV = (downPoint, interactor) => {\n    // Compute the horizontal & vertical scaling ('scalex' and 'scaley')\n    // factors as function of the down point & camera params.\n    const camera = interactor.findPokedRenderer().getActiveCamera();\n    const cameraPosition = camera.getPosition();\n    const cameraToPointVec = [0, 0, 0];\n\n    // Construct a vector from the viewing position to the picked point\n    subtract(downPoint, cameraPosition, cameraToPointVec);\n    if (camera.getParallelProjection()) {\n      multiplyScalar(cameraToPointVec, camera.getParallelScale());\n    }\n\n    // Get shortest distance 'l' between the viewing position and\n    // plane parallel to the projection plane that contains the 'downPoint'.\n    const atV = camera.getViewPlaneNormal();\n    normalize(atV);\n    const l = dot(cameraToPointVec, atV);\n    const viewAngle = radiansFromDegrees(camera.getViewAngle());\n    const renderer = interactor.findPokedRenderer();\n    const [width, height] = interactor.getView().getViewportSize(renderer);\n    const scaleX = width / height * (2 * l * Math.tan(viewAngle / 2) / 2);\n    const scaleY = 2 * l * Math.tan(viewAngle / 2) / 2;\n\n    // Construct the camera offset vector as function of delta mouse X & Y.\n    const upV = camera.getViewUp();\n    const rightV = [];\n    cross(upV, atV, rightV);\n    // (Make sure 'upV' is orthogonal to 'atV' & 'rightV')\n    cross(atV, rightV, upV);\n    normalize(rightV);\n    normalize(upV);\n    multiplyScalar(rightV, scaleX);\n    multiplyScalar(upV, scaleY);\n    return {\n      rightV,\n      upV\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  const choose = (interactor, position) => {\n    const normalizedPosition = normalize$1(position, interactor);\n    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);\n    const delta = {\n      x: normalizedPosition.x - normalizedPreviousPosition.x,\n      y: normalizedPosition.y - normalizedPreviousPosition.y\n    };\n    model.previousPosition = position;\n    const deltaT = Date.now() / 1000 - model.time;\n    model.dist += Math.sqrt(delta.x ** 2 + delta.y ** 2);\n    const sDelta = {\n      x: position.x - model.startPosition.x,\n      y: position.y - model.startPosition.y\n    };\n    const len = Math.sqrt(sDelta.x ** 2 + sDelta.y ** 2);\n    if (Math.abs(sDelta.y) / len > 0.9 && deltaT > 0.05) {\n      model.state = States.IS_DOLLY;\n    } else if (deltaT >= 0.1 || model.dist >= 0.03) {\n      if (Math.abs(sDelta.x) / len > 0.6) {\n        model.state = States.IS_PAN;\n      } else {\n        model.state = States.IS_DOLLY;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Transform mouse horizontal & vertical movements to a world\n  // space offset for the camera that maintains pick correlation.\n  const pan = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    const normalizedPosition = normalize$1(position, interactor);\n    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);\n    const delta = {\n      x: normalizedPosition.x - normalizedPreviousPosition.x,\n      y: normalizedPosition.y - normalizedPreviousPosition.y\n    };\n    const camera = renderer.getActiveCamera();\n    model.previousPosition = position;\n    const {\n      rightV,\n      upV\n    } = getRightVAndUpV(model.downPoint, interactor);\n    const offset = [];\n    for (let index = 0; index < 3; index++) {\n      offset[index] = delta.x * rightV[index] + delta.y * upV[index];\n    }\n    camera.translate(...offset);\n    renderer.resetCameraClippingRange();\n    interactor.render();\n  };\n\n  //----------------------------------------------------------------------------\n  const dolly = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    const normalizedPosition = normalize$1(position, interactor);\n    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);\n    const delta = {\n      x: normalizedPosition.x - normalizedPreviousPosition.x,\n      y: normalizedPosition.y - normalizedPreviousPosition.y\n    };\n    const camera = renderer.getActiveCamera();\n    const cameraPosition = camera.getPosition();\n\n    // 1. Handle dollying\n    if (camera.getParallelProjection()) {\n      camera.zoom(1 - delta.y);\n    } else {\n      const offset1 = [];\n      subtract(model.downPoint, cameraPosition, offset1);\n      multiplyScalar(offset1, delta.y * -4);\n      camera.translate(...offset1);\n    }\n\n    // 2. Now handle side-to-side panning\n    const {\n      rightV: offset2\n    } = getRightVAndUpV(model.downPoint, interactor);\n    multiplyScalar(offset2, delta.x);\n    camera.translate(...offset2);\n    renderer.resetCameraClippingRange();\n    interactor.render();\n  };\n\n  //----------------------------------------------------------------------------\n  // Public API methods\n  //----------------------------------------------------------------------------\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.buttonPressed = true;\n    model.startPosition = position;\n    model.previousPosition = position;\n    model.time = Date.now() / 1000.0;\n    model.dist = 0;\n\n    // Picking is delegated to the rotate manipulator\n    model.rotateManipulator.onButtonDown(interactor, renderer, position);\n    model.downPoint = model.rotateManipulator.getDownPoint();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!model.buttonPressed) {\n      return;\n    }\n    if (model.rotateManipulator.getState() === States.IS_ROTATE) {\n      model.rotateManipulator.onMouseMove(interactor, renderer, position);\n    } else {\n      switch (model.state) {\n        case States.IS_NONE:\n          choose(interactor, position);\n          break;\n        case States.IS_PAN:\n          pan(interactor, position);\n          break;\n        case States.IS_DOLLY:\n          dolly(interactor, position);\n          break;\n      }\n    }\n    model.previousPosition = position;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.onButtonUp = interactor => {\n    model.buttonPressed = false;\n    if (model.state === States.IS_NONE) {\n      model.rotateManipulator.onButtonUp(interactor);\n    }\n    model.state = States.IS_NONE;\n  };\n  publicAPI.getUseWorldUpVec = () => model.rotateManipulator.getUseWorldUpVec();\n  publicAPI.setUseWorldUpVec = useWorldUpVec => {\n    model.rotateManipulator.setUseWorldUpVec(useWorldUpVec);\n  };\n  publicAPI.getWorldUpVec = () => model.rotateManipulator.getWorldUpVec();\n  publicAPI.setWorldUpVec = (x, y, z) => {\n    model.rotateManipulator.setWorldUpVec(x, y, z);\n  };\n  publicAPI.getUseHardwareSelector = () => model.rotateManipulator.getUseHardwareSelector();\n  publicAPI.setUseHardwareSelector = useHardwareSelector => {\n    model.rotateManipulator.setUseHardwareSelector(useHardwareSelector);\n  };\n  publicAPI.getFocusSphereColor = () => {\n    model.rotateManipulator.getFocusSphereColor();\n  };\n  publicAPI.setFocusSphereColor = (r, g, b) => {\n    model.rotateManipulator.setFocusSphereColor(r, g, b);\n  };\n  publicAPI.getFocusSphereRadiusFactor = () => model.rotateManipulator.getFocusSphereRadiusFactor();\n  publicAPI.setFocusSphereRadiusFactor = focusSphereRadiusFactor => {\n    model.rotateManipulator.setFocusSphereRadiusFactor(focusSphereRadiusFactor);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Object specific methods\n  vtkMouseCameraUnicamManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraUnicamManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraUnicamManipulator$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkMouseCameraUnicamManipulator$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}