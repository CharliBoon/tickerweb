{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { mat4, vec3, mat3 } from 'gl-matrix';\nimport Constants from './Glyph3DMapper/Constants.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkMapper from './Mapper.js';\nimport { F as createUninitializedBounds, n as norm } from '../../Common/Core/Math/index.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nconst {\n  OrientationModes,\n  ScaleModes\n} = Constants;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// class methods\n// ----------------------------------------------------------------------------\n\nfunction vtkGlyph3DMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkGlyph3DMapper');\n\n  /**\n   * An orientation array is a vtkDataArray with 3 components. The first\n   * component is the angle of rotation along the X axis. The second\n   * component is the angle of rotation along the Y axis. The third\n   * component is the angle of rotation along the Z axis. Orientation is\n   * specified in X,Y,Z order but the rotations are performed in Z,X an Y.\n   * This definition is compliant with SetOrientation method on vtkProp3D.\n   * By using vector or normal there is a degree of freedom or rotation\n   * left (underconstrained). With the orientation array, there is no degree of\n   * freedom left.\n   */\n  publicAPI.getOrientationModeAsString = () => macro.enumToString(OrientationModes, model.orientationMode);\n  publicAPI.setOrientationModeToDirection = () => publicAPI.setOrientationMode(OrientationModes.DIRECTION);\n  publicAPI.setOrientationModeToRotation = () => publicAPI.setOrientationMode(OrientationModes.ROTATION);\n  publicAPI.setOrientationModeToMatrix = () => publicAPI.setOrientationMode(OrientationModes.MATRIX);\n  publicAPI.getOrientationArrayData = () => {\n    const idata = publicAPI.getInputData(0);\n    if (!idata || !idata.getPointData()) {\n      return null;\n    }\n    if (!model.orientationArray) {\n      return idata.getPointData().getVectors();\n    }\n    return idata.getPointData().getArray(model.orientationArray);\n  };\n  publicAPI.getScaleModeAsString = () => macro.enumToString(ScaleModes, model.scaleMode);\n  publicAPI.setScaleModeToScaleByMagnitude = () => publicAPI.setScaleMode(ScaleModes.SCALE_BY_MAGNITUDE);\n  publicAPI.setScaleModeToScaleByComponents = () => publicAPI.setScaleMode(ScaleModes.SCALE_BY_COMPONENTS);\n  publicAPI.setScaleModeToScaleByConstant = () => publicAPI.setScaleMode(ScaleModes.SCALE_BY_CONSTANT);\n  publicAPI.getScaleArrayData = () => {\n    const idata = publicAPI.getInputData(0);\n    if (!idata || !idata.getPointData()) {\n      return null;\n    }\n    if (!model.scaleArray) {\n      return idata.getPointData().getScalars();\n    }\n    return idata.getPointData().getArray(model.scaleArray);\n  };\n  publicAPI.getBounds = () => {\n    const idata = publicAPI.getInputData(0);\n    const gdata = publicAPI.getInputData(1);\n    if (!idata || !gdata) {\n      return createUninitializedBounds();\n    }\n\n    // first we build the arrays used for the glyphing\n    publicAPI.buildArrays();\n    return model.bounds;\n  };\n  publicAPI.buildArrays = () => {\n    // if the mtgime requires it, rebuild\n    const idata = publicAPI.getInputData(0);\n    const gdata = publicAPI.getInputData(1);\n    if (model.buildTime.getMTime() < gdata.getMTime() || model.buildTime.getMTime() < idata.getMTime() || model.buildTime.getMTime() < publicAPI.getMTime()) {\n      const pts = idata.getPoints().getData();\n      let sArray = publicAPI.getScaleArrayData();\n      let sData = null;\n      let numSComp = 0;\n      if (sArray) {\n        sData = sArray.getData();\n        numSComp = sArray.getNumberOfComponents();\n      }\n      if (model.scaling && sArray && model.scaleMode === ScaleModes.SCALE_BY_COMPONENTS && sArray.getNumberOfComponents() !== 3) {\n        vtkErrorMacro('Cannot scale by components since scale array does not have 3 components.');\n        sArray = null;\n      }\n\n      // get the glyph bounds\n      const gbounds = gdata.getBounds();\n      // convert them to 8 points so we can compute the\n      // overall bounds while building the arrays\n      const corners = [];\n      vtkBoundingBox.getCorners(gbounds, corners);\n      model.bounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n      model.bounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n      model.bounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n      model.bounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n      model.bounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n      model.bounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n      const tcorner = new Float64Array(3);\n      const oArray = publicAPI.getOrientationArrayData();\n      const identity = mat4.identity(new Float64Array(16));\n      const trans = [];\n      const scale = [];\n      const numPts = pts.length / 3;\n      model.matrixArray = new Float32Array(16 * numPts);\n      const mbuff = model.matrixArray.buffer;\n      model.normalArray = new Float32Array(9 * numPts);\n      const nbuff = model.normalArray.buffer;\n      const tuple = [];\n      const orientation = [];\n      for (let i = 0; i < numPts; ++i) {\n        const z = new Float32Array(mbuff, i * 64, 16);\n        trans[0] = pts[i * 3];\n        trans[1] = pts[i * 3 + 1];\n        trans[2] = pts[i * 3 + 2];\n        mat4.translate(z, identity, trans);\n        if (oArray) {\n          oArray.getTuple(i, orientation);\n          switch (model.orientationMode) {\n            case OrientationModes.MATRIX:\n              {\n                // prettier-ignore\n                const rotMat4 = [...orientation.slice(0, 3), 0, ...orientation.slice(3, 6), 0, ...orientation.slice(6, 9), 0, 0, 0, 0, 1];\n                mat4.multiply(z, z, rotMat4);\n                break;\n              }\n            case OrientationModes.ROTATION:\n              mat4.rotateZ(z, z, orientation[2]);\n              mat4.rotateX(z, z, orientation[0]);\n              mat4.rotateY(z, z, orientation[1]);\n              break;\n            case OrientationModes.DIRECTION:\n              if (orientation[1] === 0.0 && orientation[2] === 0.0) {\n                if (orientation[0] < 0) {\n                  mat4.rotateY(z, z, 3.1415926);\n                }\n              } else {\n                const vMag = norm(orientation);\n                const vNew = [];\n                vNew[0] = (orientation[0] + vMag) / 2.0;\n                vNew[1] = orientation[1] / 2.0;\n                vNew[2] = orientation[2] / 2.0;\n                mat4.rotate(z, z, 3.1415926, vNew);\n              }\n              break;\n          }\n        }\n\n        // scale data if appropriate\n        if (model.scaling) {\n          scale[0] = model.scaleFactor;\n          scale[1] = model.scaleFactor;\n          scale[2] = model.scaleFactor;\n          // Get the scalar and vector data\n          if (sArray) {\n            switch (model.scaleMode) {\n              case ScaleModes.SCALE_BY_MAGNITUDE:\n                for (let t = 0; t < numSComp; ++t) {\n                  tuple[t] = sData[i * numSComp + t];\n                }\n                scale[0] *= norm(tuple, numSComp);\n                scale[1] = scale[0];\n                scale[2] = scale[0];\n                break;\n              case ScaleModes.SCALE_BY_COMPONENTS:\n                for (let t = 0; t < numSComp; ++t) {\n                  tuple[t] = sData[i * numSComp + t];\n                }\n                scale[0] *= tuple[0];\n                scale[1] *= tuple[1];\n                scale[2] *= tuple[2];\n                break;\n              case ScaleModes.SCALE_BY_CONSTANT:\n            }\n          }\n          if (scale[0] === 0.0) {\n            scale[0] = 1.0e-10;\n          }\n          if (scale[1] === 0.0) {\n            scale[1] = 1.0e-10;\n          }\n          if (scale[2] === 0.0) {\n            scale[2] = 1.0e-10;\n          }\n          mat4.scale(z, z, scale);\n        }\n\n        // update bounds\n        for (let p = 0; p < 8; ++p) {\n          vec3.transformMat4(tcorner, corners[p], z);\n          if (tcorner[0] < model.bounds[0]) {\n            model.bounds[0] = tcorner[0];\n          }\n          if (tcorner[1] < model.bounds[2]) {\n            model.bounds[2] = tcorner[1];\n          }\n          if (tcorner[2] < model.bounds[4]) {\n            model.bounds[4] = tcorner[2];\n          }\n          if (tcorner[0] > model.bounds[1]) {\n            model.bounds[1] = tcorner[0];\n          }\n          if (tcorner[1] > model.bounds[3]) {\n            model.bounds[3] = tcorner[1];\n          }\n          if (tcorner[2] > model.bounds[5]) {\n            model.bounds[5] = tcorner[2];\n          }\n        }\n        const n = new Float32Array(nbuff, i * 36, 9);\n        mat3.fromMat4(n, z);\n        mat3.invert(n, n);\n        mat3.transpose(n, n);\n      }\n\n      // map scalars as well\n      const scalars = publicAPI.getAbstractScalars(idata, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n      if (!model.useLookupTableScalarRange) {\n        publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n      }\n      model.colorArray = null;\n      const lut = publicAPI.getLookupTable();\n      if (lut && scalars) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorArray = lut.mapScalars(scalars, model.colorMode, 0);\n      }\n      model.buildTime.modified();\n    }\n  };\n  publicAPI.getPrimitiveCount = () => {\n    const glyph = publicAPI.getInputData(1);\n    const mult = publicAPI.getInputData().getPoints().getNumberOfValues() / 3;\n    const pcount = {\n      points: mult * glyph.getPoints().getNumberOfValues() / 3,\n      verts: mult * (glyph.getVerts().getNumberOfValues() - glyph.getVerts().getNumberOfCells()),\n      lines: mult * (glyph.getLines().getNumberOfValues() - 2 * glyph.getLines().getNumberOfCells()),\n      triangles: mult * (glyph.getPolys().getNumberOfValues() - 3 * glyph.getLines().getNumberOfCells())\n    };\n    return pcount;\n  };\n  publicAPI.setSourceConnection = outputPort => publicAPI.setInputConnection(outputPort, 1);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orient: true,\n  orientationMode: OrientationModes.DIRECTION,\n  orientationArray: null,\n  scaling: true,\n  scaleFactor: 1.0,\n  scaleMode: ScaleModes.SCALE_BY_MAGNITUDE,\n  scaleArray: null,\n  matrixArray: null,\n  normalArray: null,\n  colorArray: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkMapper.extend(publicAPI, model, initialValues);\n  macro.algo(publicAPI, model, 2, 0);\n  model.buildTime = {};\n  macro.obj(model.buildTime, {\n    mtime: 0\n  });\n  model.boundsTime = {};\n  macro.obj(model.boundsTime, {\n    mtime: 0\n  });\n  macro.setGet(publicAPI, model, ['orient', 'orientationMode', 'orientationArray', 'scaleArray', 'scaleFactor', 'scaleMode', 'scaling']);\n  macro.get(publicAPI, model, ['colorArray', 'matrixArray', 'normalArray', 'buildTime']);\n\n  // Object methods\n  vtkGlyph3DMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkGlyph3DMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkGlyph3DMapper$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\nexport { vtkGlyph3DMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["mat4","vec3","mat3","Constants","m","macro","vtkMapper","F","createUninitializedBounds","n","norm","vtkBoundingBox","OrientationModes","ScaleModes","vtkErrorMacro","vtkGlyph3DMapper","publicAPI","model","classHierarchy","push","getOrientationModeAsString","enumToString","orientationMode","setOrientationModeToDirection","setOrientationMode","DIRECTION","setOrientationModeToRotation","ROTATION","setOrientationModeToMatrix","MATRIX","getOrientationArrayData","idata","getInputData","getPointData","orientationArray","getVectors","getArray","getScaleModeAsString","scaleMode","setScaleModeToScaleByMagnitude","setScaleMode","SCALE_BY_MAGNITUDE","setScaleModeToScaleByComponents","SCALE_BY_COMPONENTS","setScaleModeToScaleByConstant","SCALE_BY_CONSTANT","getScaleArrayData","scaleArray","getScalars","getBounds","gdata","buildArrays","bounds","buildTime","getMTime","pts","getPoints","getData","sArray","sData","numSComp","getNumberOfComponents","scaling","gbounds","corners","getCorners","INIT_BOUNDS","tcorner","Float64Array","oArray","identity","trans","scale","numPts","length","matrixArray","Float32Array","mbuff","buffer","normalArray","nbuff","tuple","orientation","i","z","translate","getTuple","rotMat4","slice","multiply","rotateZ","rotateX","rotateY","vMag","vNew","rotate","scaleFactor","t","p","transformMat4","fromMat4","invert","transpose","scalars","getAbstractScalars","scalarMode","arrayAccessMode","arrayId","colorByArrayName","useLookupTableScalarRange","getLookupTable","setRange","scalarRange","colorArray","lut","build","mapScalars","colorMode","modified","getPrimitiveCount","glyph","mult","getNumberOfValues","pcount","points","verts","getVerts","getNumberOfCells","lines","getLines","triangles","getPolys","setSourceConnection","outputPort","setInputConnection","DEFAULT_VALUES","orient","extend","initialValues","arguments","undefined","Object","assign","algo","obj","mtime","boundsTime","setGet","get","newInstance","vtkGlyph3DMapper$1","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/Core/Glyph3DMapper.js"],"sourcesContent":["import { mat4, vec3, mat3 } from 'gl-matrix';\nimport Constants from './Glyph3DMapper/Constants.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkMapper from './Mapper.js';\nimport { F as createUninitializedBounds, n as norm } from '../../Common/Core/Math/index.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\n\nconst {\n  OrientationModes,\n  ScaleModes\n} = Constants;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// class methods\n// ----------------------------------------------------------------------------\n\nfunction vtkGlyph3DMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkGlyph3DMapper');\n\n  /**\n   * An orientation array is a vtkDataArray with 3 components. The first\n   * component is the angle of rotation along the X axis. The second\n   * component is the angle of rotation along the Y axis. The third\n   * component is the angle of rotation along the Z axis. Orientation is\n   * specified in X,Y,Z order but the rotations are performed in Z,X an Y.\n   * This definition is compliant with SetOrientation method on vtkProp3D.\n   * By using vector or normal there is a degree of freedom or rotation\n   * left (underconstrained). With the orientation array, there is no degree of\n   * freedom left.\n   */\n  publicAPI.getOrientationModeAsString = () => macro.enumToString(OrientationModes, model.orientationMode);\n  publicAPI.setOrientationModeToDirection = () => publicAPI.setOrientationMode(OrientationModes.DIRECTION);\n  publicAPI.setOrientationModeToRotation = () => publicAPI.setOrientationMode(OrientationModes.ROTATION);\n  publicAPI.setOrientationModeToMatrix = () => publicAPI.setOrientationMode(OrientationModes.MATRIX);\n  publicAPI.getOrientationArrayData = () => {\n    const idata = publicAPI.getInputData(0);\n    if (!idata || !idata.getPointData()) {\n      return null;\n    }\n    if (!model.orientationArray) {\n      return idata.getPointData().getVectors();\n    }\n    return idata.getPointData().getArray(model.orientationArray);\n  };\n  publicAPI.getScaleModeAsString = () => macro.enumToString(ScaleModes, model.scaleMode);\n  publicAPI.setScaleModeToScaleByMagnitude = () => publicAPI.setScaleMode(ScaleModes.SCALE_BY_MAGNITUDE);\n  publicAPI.setScaleModeToScaleByComponents = () => publicAPI.setScaleMode(ScaleModes.SCALE_BY_COMPONENTS);\n  publicAPI.setScaleModeToScaleByConstant = () => publicAPI.setScaleMode(ScaleModes.SCALE_BY_CONSTANT);\n  publicAPI.getScaleArrayData = () => {\n    const idata = publicAPI.getInputData(0);\n    if (!idata || !idata.getPointData()) {\n      return null;\n    }\n    if (!model.scaleArray) {\n      return idata.getPointData().getScalars();\n    }\n    return idata.getPointData().getArray(model.scaleArray);\n  };\n  publicAPI.getBounds = () => {\n    const idata = publicAPI.getInputData(0);\n    const gdata = publicAPI.getInputData(1);\n    if (!idata || !gdata) {\n      return createUninitializedBounds();\n    }\n\n    // first we build the arrays used for the glyphing\n    publicAPI.buildArrays();\n    return model.bounds;\n  };\n  publicAPI.buildArrays = () => {\n    // if the mtgime requires it, rebuild\n    const idata = publicAPI.getInputData(0);\n    const gdata = publicAPI.getInputData(1);\n    if (model.buildTime.getMTime() < gdata.getMTime() || model.buildTime.getMTime() < idata.getMTime() || model.buildTime.getMTime() < publicAPI.getMTime()) {\n      const pts = idata.getPoints().getData();\n      let sArray = publicAPI.getScaleArrayData();\n      let sData = null;\n      let numSComp = 0;\n      if (sArray) {\n        sData = sArray.getData();\n        numSComp = sArray.getNumberOfComponents();\n      }\n      if (model.scaling && sArray && model.scaleMode === ScaleModes.SCALE_BY_COMPONENTS && sArray.getNumberOfComponents() !== 3) {\n        vtkErrorMacro('Cannot scale by components since scale array does not have 3 components.');\n        sArray = null;\n      }\n\n      // get the glyph bounds\n      const gbounds = gdata.getBounds();\n      // convert them to 8 points so we can compute the\n      // overall bounds while building the arrays\n      const corners = [];\n      vtkBoundingBox.getCorners(gbounds, corners);\n      model.bounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n      model.bounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n      model.bounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n      model.bounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n      model.bounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n      model.bounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n      const tcorner = new Float64Array(3);\n      const oArray = publicAPI.getOrientationArrayData();\n      const identity = mat4.identity(new Float64Array(16));\n      const trans = [];\n      const scale = [];\n      const numPts = pts.length / 3;\n      model.matrixArray = new Float32Array(16 * numPts);\n      const mbuff = model.matrixArray.buffer;\n      model.normalArray = new Float32Array(9 * numPts);\n      const nbuff = model.normalArray.buffer;\n      const tuple = [];\n      const orientation = [];\n      for (let i = 0; i < numPts; ++i) {\n        const z = new Float32Array(mbuff, i * 64, 16);\n        trans[0] = pts[i * 3];\n        trans[1] = pts[i * 3 + 1];\n        trans[2] = pts[i * 3 + 2];\n        mat4.translate(z, identity, trans);\n        if (oArray) {\n          oArray.getTuple(i, orientation);\n          switch (model.orientationMode) {\n            case OrientationModes.MATRIX:\n              {\n                // prettier-ignore\n                const rotMat4 = [...orientation.slice(0, 3), 0, ...orientation.slice(3, 6), 0, ...orientation.slice(6, 9), 0, 0, 0, 0, 1];\n                mat4.multiply(z, z, rotMat4);\n                break;\n              }\n            case OrientationModes.ROTATION:\n              mat4.rotateZ(z, z, orientation[2]);\n              mat4.rotateX(z, z, orientation[0]);\n              mat4.rotateY(z, z, orientation[1]);\n              break;\n            case OrientationModes.DIRECTION:\n              if (orientation[1] === 0.0 && orientation[2] === 0.0) {\n                if (orientation[0] < 0) {\n                  mat4.rotateY(z, z, 3.1415926);\n                }\n              } else {\n                const vMag = norm(orientation);\n                const vNew = [];\n                vNew[0] = (orientation[0] + vMag) / 2.0;\n                vNew[1] = orientation[1] / 2.0;\n                vNew[2] = orientation[2] / 2.0;\n                mat4.rotate(z, z, 3.1415926, vNew);\n              }\n              break;\n          }\n        }\n\n        // scale data if appropriate\n        if (model.scaling) {\n          scale[0] = model.scaleFactor;\n          scale[1] = model.scaleFactor;\n          scale[2] = model.scaleFactor;\n          // Get the scalar and vector data\n          if (sArray) {\n            switch (model.scaleMode) {\n              case ScaleModes.SCALE_BY_MAGNITUDE:\n                for (let t = 0; t < numSComp; ++t) {\n                  tuple[t] = sData[i * numSComp + t];\n                }\n                scale[0] *= norm(tuple, numSComp);\n                scale[1] = scale[0];\n                scale[2] = scale[0];\n                break;\n              case ScaleModes.SCALE_BY_COMPONENTS:\n                for (let t = 0; t < numSComp; ++t) {\n                  tuple[t] = sData[i * numSComp + t];\n                }\n                scale[0] *= tuple[0];\n                scale[1] *= tuple[1];\n                scale[2] *= tuple[2];\n                break;\n              case ScaleModes.SCALE_BY_CONSTANT:\n            }\n          }\n          if (scale[0] === 0.0) {\n            scale[0] = 1.0e-10;\n          }\n          if (scale[1] === 0.0) {\n            scale[1] = 1.0e-10;\n          }\n          if (scale[2] === 0.0) {\n            scale[2] = 1.0e-10;\n          }\n          mat4.scale(z, z, scale);\n        }\n\n        // update bounds\n        for (let p = 0; p < 8; ++p) {\n          vec3.transformMat4(tcorner, corners[p], z);\n          if (tcorner[0] < model.bounds[0]) {\n            model.bounds[0] = tcorner[0];\n          }\n          if (tcorner[1] < model.bounds[2]) {\n            model.bounds[2] = tcorner[1];\n          }\n          if (tcorner[2] < model.bounds[4]) {\n            model.bounds[4] = tcorner[2];\n          }\n          if (tcorner[0] > model.bounds[1]) {\n            model.bounds[1] = tcorner[0];\n          }\n          if (tcorner[1] > model.bounds[3]) {\n            model.bounds[3] = tcorner[1];\n          }\n          if (tcorner[2] > model.bounds[5]) {\n            model.bounds[5] = tcorner[2];\n          }\n        }\n        const n = new Float32Array(nbuff, i * 36, 9);\n        mat3.fromMat4(n, z);\n        mat3.invert(n, n);\n        mat3.transpose(n, n);\n      }\n\n      // map scalars as well\n      const scalars = publicAPI.getAbstractScalars(idata, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;\n      if (!model.useLookupTableScalarRange) {\n        publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n      }\n      model.colorArray = null;\n      const lut = publicAPI.getLookupTable();\n      if (lut && scalars) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorArray = lut.mapScalars(scalars, model.colorMode, 0);\n      }\n      model.buildTime.modified();\n    }\n  };\n  publicAPI.getPrimitiveCount = () => {\n    const glyph = publicAPI.getInputData(1);\n    const mult = publicAPI.getInputData().getPoints().getNumberOfValues() / 3;\n    const pcount = {\n      points: mult * glyph.getPoints().getNumberOfValues() / 3,\n      verts: mult * (glyph.getVerts().getNumberOfValues() - glyph.getVerts().getNumberOfCells()),\n      lines: mult * (glyph.getLines().getNumberOfValues() - 2 * glyph.getLines().getNumberOfCells()),\n      triangles: mult * (glyph.getPolys().getNumberOfValues() - 3 * glyph.getLines().getNumberOfCells())\n    };\n    return pcount;\n  };\n  publicAPI.setSourceConnection = outputPort => publicAPI.setInputConnection(outputPort, 1);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orient: true,\n  orientationMode: OrientationModes.DIRECTION,\n  orientationArray: null,\n  scaling: true,\n  scaleFactor: 1.0,\n  scaleMode: ScaleModes.SCALE_BY_MAGNITUDE,\n  scaleArray: null,\n  matrixArray: null,\n  normalArray: null,\n  colorArray: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkMapper.extend(publicAPI, model, initialValues);\n  macro.algo(publicAPI, model, 2, 0);\n  model.buildTime = {};\n  macro.obj(model.buildTime, {\n    mtime: 0\n  });\n  model.boundsTime = {};\n  macro.obj(model.boundsTime, {\n    mtime: 0\n  });\n  macro.setGet(publicAPI, model, ['orient', 'orientationMode', 'orientationArray', 'scaleArray', 'scaleFactor', 'scaleMode', 'scaling']);\n  macro.get(publicAPI, model, ['colorArray', 'matrixArray', 'normalArray', 'buildTime']);\n\n  // Object methods\n  vtkGlyph3DMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkGlyph3DMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkGlyph3DMapper$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkGlyph3DMapper$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}