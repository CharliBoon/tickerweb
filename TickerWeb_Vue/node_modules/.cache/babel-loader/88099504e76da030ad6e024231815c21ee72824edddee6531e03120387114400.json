{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/web.structured-clone.js\";\nimport Constants from './Texture/Constants.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\nimport { n as newInstance$1, o as obj, s as set, e as setGet, g as get, i as moveToProtected, a as newTypedArray, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { T as isPowerOfTwo, P as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  Wrap,\n  Filter\n} = Constants;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\nconst {\n  toHalf\n} = HalfFloat;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLTexture');\n  // Renders myself\n  publicAPI.render = function () {\n    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (renWin) {\n      model._openGLRenderWindow = renWin;\n    } else {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      // sync renderable properties\n      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');\n    }\n    model.context = model._openGLRenderWindow.getContext();\n    if (model.renderable.getInterpolate()) {\n      if (model.generateMipmap) {\n        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n      } else {\n        publicAPI.setMinificationFilter(Filter.LINEAR);\n      }\n      publicAPI.setMagnificationFilter(Filter.LINEAR);\n    } else {\n      publicAPI.setMinificationFilter(Filter.NEAREST);\n      publicAPI.setMagnificationFilter(Filter.NEAREST);\n    }\n    if (model.renderable.getRepeat()) {\n      publicAPI.setWrapR(Wrap.REPEAT);\n      publicAPI.setWrapS(Wrap.REPEAT);\n      publicAPI.setWrapT(Wrap.REPEAT);\n    }\n    // clear image if input data is set\n    if (model.renderable.getInputData()) {\n      model.renderable.setImage(null);\n    }\n    // create the texture if it is not done already\n    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {\n      // if we have an Image\n      if (model.renderable.getImage() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        // Have an Image which may not be complete\n        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImage(model.renderable.getImage());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      }\n      // if we have a canvas\n      if (model.renderable.getCanvas() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        const canvas = model.renderable.getCanvas();\n        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have jsImageData\n      if (model.renderable.getJsImageData() !== null) {\n        const jsid = model.renderable.getJsImageData();\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have InputData\n      const input = model.renderable.getInputData(0);\n      if (input && input.getPointData().getScalars()) {\n        const ext = input.getExtent();\n        const inScalars = input.getPointData().getScalars();\n\n        // do we have a cube map? Six inputs\n        const data = [];\n        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {\n          const indata = model.renderable.getInputData(i);\n          const scalars = indata ? indata.getPointData().getScalars().getData() : null;\n          if (scalars) {\n            data.push(scalars);\n          }\n        }\n        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        if (data.length % 6 === 0) {\n          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);\n        } else {\n          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n        }\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n    }\n    if (model.handle) {\n      publicAPI.activate();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.destroyTexture = () => {\n    // deactivate it first\n    publicAPI.deactivate();\n    if (model.context && model.handle) {\n      model.context.deleteTexture(model.handle);\n    }\n    model.handle = 0;\n    model.numberOfDimensions = 0;\n    model.target = 0;\n    model.components = 0;\n    model.width = 0;\n    model.height = 0;\n    model.depth = 0;\n    publicAPI.resetFormatAndType();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createTexture = () => {\n    // reuse the existing handle if we have one\n    if (!model.handle) {\n      model.handle = model.context.createTexture();\n      if (model.target) {\n        model.context.bindTexture(model.target, model.handle);\n\n        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture\n        // turn off mip map filter or set the base and max level correctly. here\n        // both are done.\n        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n        if (model._openGLRenderWindow.getWebgl2()) {\n          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n        }\n        model.context.bindTexture(model.target, null);\n      }\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.getTextureUnit = () => {\n    if (model._openGLRenderWindow) {\n      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);\n    }\n    return -1;\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.activate = () => {\n    // activate a free texture unit for this texture\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.bind();\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.deactivate = () => {\n    if (model._openGLRenderWindow) {\n      model._openGLRenderWindow.deactivateTexture(publicAPI);\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.releaseGraphicsResources = rwin => {\n    if (rwin && model.handle) {\n      rwin.activateTexture(publicAPI);\n      rwin.deactivateTexture(publicAPI);\n      model.context.deleteTexture(model.handle);\n      model.handle = 0;\n      model.numberOfDimensions = 0;\n      model.target = 0;\n      model.internalFormat = 0;\n      model.format = 0;\n      model.openGLDataType = 0;\n      model.components = 0;\n      model.width = 0;\n      model.height = 0;\n      model.depth = 0;\n      model.allocatedGPUMemoryInBytes = 0;\n    }\n    if (model.shaderProgram) {\n      model.shaderProgram.releaseGraphicsResources(rwin);\n      model.shaderProgram = null;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.bind = () => {\n    model.context.bindTexture(model.target, model.handle);\n    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {\n      publicAPI.sendParameters();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.isBound = () => {\n    let result = false;\n    if (model.context && model.handle) {\n      let target = 0;\n      switch (model.target) {\n        case model.context.TEXTURE_2D:\n          target = model.context.TEXTURE_BINDING_2D;\n          break;\n        default:\n          vtkWarningMacro('impossible case');\n          break;\n      }\n      const oid = model.context.getIntegerv(target);\n      result = oid === model.handle;\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.sendParameters = () => {\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n    }\n    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);\n      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);\n    }\n\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);\n\n    model.sendParametersTime.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getInternalFormat = (vtktype, numComps) => {\n    if (!model._forceInternalFormat) {\n      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);\n    }\n    if (!model.internalFormat) {\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension('OES_texture_float_linear')) {\n      vtkWarningMacro('Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.');\n    }\n    return model.internalFormat;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {\n    let result = 0;\n    // try default next\n    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    if (result) {\n      return result;\n    }\n    if (!result) {\n      vtkDebugMacro('Unsupported internal texture type!');\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return result;\n  };\n  publicAPI.useHalfFloat = () => model.enableUseHalfFloat && model.canUseHalfFloat;\n\n  //----------------------------------------------------------------------------\n  publicAPI.setInternalFormat = iFormat => {\n    model._forceInternalFormat = true;\n    if (iFormat !== model.internalFormat) {\n      model.internalFormat = iFormat;\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getFormat = (vtktype, numComps) => {\n    model.format = publicAPI.getDefaultFormat(vtktype, numComps);\n    return model.format;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultFormat = (vtktype, numComps) => {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (numComps) {\n        case 1:\n          return model.context.RED;\n        case 2:\n          return model.context.RG;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    } else {\n      // webgl1\n      switch (numComps) {\n        case 1:\n          return model.context.LUMINANCE;\n        case 2:\n          return model.context.LUMINANCE_ALPHA;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetFormatAndType = () => {\n    model.format = 0;\n    model.internalFormat = 0;\n    model._forceInternalFormat = false;\n    model.openGLDataType = 0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultDataType = vtkScalarType => {\n    const useHalfFloat = publicAPI.useHalfFloat();\n    // DON'T DEAL with VTK_CHAR as this is platform dependent.\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (vtkScalarType) {\n        // case VtkDataTypes.SIGNED_CHAR:\n        //   return model.context.BYTE;\n        case VtkDataTypes.UNSIGNED_CHAR:\n          return model.context.UNSIGNED_BYTE;\n        // prefer norm16 since that is accurate compared to\n        // half float which is not\n        case model.oglNorm16Ext && !useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.SHORT;\n        case model.oglNorm16Ext && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.UNSIGNED_SHORT;\n        // use half float type\n        case useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.HALF_FLOAT;\n        case useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.HALF_FLOAT;\n        // case VtkDataTypes.INT:\n        //   return model.context.INT;\n        // case VtkDataTypes.UNSIGNED_INT:\n        //   return model.context.UNSIGNED_INT;\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.VOID: // used for depth component textures.\n        default:\n          return model.context.FLOAT;\n      }\n    }\n    switch (vtkScalarType) {\n      // case VtkDataTypes.SIGNED_CHAR:\n      //   return model.context.BYTE;\n      case VtkDataTypes.UNSIGNED_CHAR:\n        return model.context.UNSIGNED_BYTE;\n      // case VtkDataTypes.SHORT:\n      //   return model.context.SHORT;\n      // case VtkDataTypes.UNSIGNED_SHORT:\n      //   return model.context.UNSIGNED_SHORT;\n      // case VtkDataTypes.INT:\n      //   return model.context.INT;\n      // case VtkDataTypes.UNSIGNED_INT:\n      //   return model.context.UNSIGNED_INT;\n      case VtkDataTypes.FLOAT:\n      case VtkDataTypes.VOID: // used for depth component textures.\n      default:\n        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n          return model.context.FLOAT;\n        }\n        {\n          const halfFloat = model.context.getExtension('OES_texture_half_float');\n          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {\n            return halfFloat.HALF_FLOAT_OES;\n          }\n        }\n        return model.context.UNSIGNED_BYTE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLDataType = function (vtkScalarType) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!model.openGLDataType || forceUpdate) {\n      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);\n    }\n    return model.openGLDataType;\n  };\n  publicAPI.getShiftAndScale = () => {\n    let shift = 0.0;\n    let scale = 1.0;\n\n    // for all float type internal formats\n    switch (model.openGLDataType) {\n      case model.context.BYTE:\n        scale = 127.5;\n        shift = scale - 128.0;\n        break;\n      case model.context.UNSIGNED_BYTE:\n        scale = 255.0;\n        shift = 0.0;\n        break;\n      case model.context.SHORT:\n        scale = 32767.5;\n        shift = scale - 32768.0;\n        break;\n      case model.context.UNSIGNED_SHORT:\n        scale = 65536.0;\n        shift = 0.0;\n        break;\n      case model.context.INT:\n        scale = 2147483647.5;\n        shift = scale - 2147483648.0;\n        break;\n      case model.context.UNSIGNED_INT:\n        scale = 4294967295.0;\n        shift = 0.0;\n        break;\n      case model.context.FLOAT:\n    }\n    return {\n      shift,\n      scale\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLFilterMode = emode => {\n    switch (emode) {\n      case Filter.NEAREST:\n        return model.context.NEAREST;\n      case Filter.LINEAR:\n        return model.context.LINEAR;\n      case Filter.NEAREST_MIPMAP_NEAREST:\n        return model.context.NEAREST_MIPMAP_NEAREST;\n      case Filter.NEAREST_MIPMAP_LINEAR:\n        return model.context.NEAREST_MIPMAP_LINEAR;\n      case Filter.LINEAR_MIPMAP_NEAREST:\n        return model.context.LINEAR_MIPMAP_NEAREST;\n      case Filter.LINEAR_MIPMAP_LINEAR:\n        return model.context.LINEAR_MIPMAP_LINEAR;\n      default:\n        return model.context.NEAREST;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLWrapMode = vtktype => {\n    switch (vtktype) {\n      case Wrap.CLAMP_TO_EDGE:\n        return model.context.CLAMP_TO_EDGE;\n      case Wrap.REPEAT:\n        return model.context.REPEAT;\n      case Wrap.MIRRORED_REPEAT:\n        return model.context.MIRRORED_REPEAT;\n      default:\n        return model.context.CLAMP_TO_EDGE;\n    }\n  };\n\n  /**\n   * Updates the data array to match the required data type for OpenGL.\n   *\n   * This function takes the input data and converts it to the appropriate\n   * format required by the OpenGL texture, based on the specified data type.\n   *\n   * @param {string} dataType - The original data type of the input data.\n   * @param {Array} data - The input data array that needs to be updated.\n   * @param {boolean} [depth=false] - Indicates whether the data is a 3D array.\n   * @returns {Array} The updated data array that matches the OpenGL data type.\n   */\n  publicAPI.updateArrayDataTypeForGL = function (dataType, data) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const pixData = [];\n    let pixCount = model.width * model.height * model.components;\n    if (depth) {\n      pixCount *= model.depth;\n    }\n\n    // if the opengl data type is float\n    // then the data array must be float\n    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Float32Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is ubyte\n    // then the data array must be u8, we currently simply truncate the data\n    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Uint8Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is half float\n    // then the data array must be u16\n    let halfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    if (halfFloat) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const newArray = new Uint16Array(pixCount);\n          const src = data[idx];\n          for (let i = 0; i < pixCount; i++) {\n            newArray[i] = toHalf(src[i]);\n          }\n          pixData.push(newArray);\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  };\n\n  //----------------------------------------------------------------------------\n  function scaleTextureToHighestPowerOfTwo(data) {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // No need if webGL2\n      return data;\n    }\n    const pixData = [];\n    const width = model.width;\n    const height = model.height;\n    const numComps = model.components;\n    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {\n      // Scale up the texture to the next highest power of two dimensions.\n      const halfFloat = model.context.getExtension('OES_texture_half_float');\n      const newWidth = nearestPowerOfTwo(width);\n      const newHeight = nearestPowerOfTwo(height);\n      const pixCount = newWidth * newHeight * model.components;\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx] !== null) {\n          let newArray = null;\n          const jFactor = height / newHeight;\n          const iFactor = width / newWidth;\n          let usingHalf = false;\n          if (model.openGLDataType === model.context.FLOAT) {\n            newArray = new Float32Array(pixCount);\n          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {\n            newArray = new Uint16Array(pixCount);\n            usingHalf = true;\n          } else {\n            newArray = new Uint8Array(pixCount);\n          }\n          for (let j = 0; j < newHeight; j++) {\n            const joff = j * newWidth * numComps;\n            const jidx = j * jFactor;\n            let jlow = Math.floor(jidx);\n            let jhi = Math.ceil(jidx);\n            if (jhi >= height) {\n              jhi = height - 1;\n            }\n            const jmix = jidx - jlow;\n            const jmix1 = 1.0 - jmix;\n            jlow = jlow * width * numComps;\n            jhi = jhi * width * numComps;\n            for (let i = 0; i < newWidth; i++) {\n              const ioff = i * numComps;\n              const iidx = i * iFactor;\n              let ilow = Math.floor(iidx);\n              let ihi = Math.ceil(iidx);\n              if (ihi >= width) {\n                ihi = width - 1;\n              }\n              const imix = iidx - ilow;\n              ilow *= numComps;\n              ihi *= numComps;\n              for (let c = 0; c < numComps; c++) {\n                if (usingHalf) {\n                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);\n                } else {\n                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;\n                }\n              }\n            }\n          }\n          pixData.push(newArray);\n          model.width = newWidth;\n          model.height = newHeight;\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function useTexStorage(dataType) {\n    if (model._openGLRenderWindow) {\n      if (model.resizable || model.renderable?.getResizable()) {\n        // Cannot use texStorage if the texture is supposed to be resizable.\n        return false;\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        const webGLInfo = model._openGLRenderWindow.getGLInformations();\n        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && model.oglNorm16Ext && (dataType === VtkDataTypes.UNSIGNED_SHORT || dataType === VtkDataTypes.SHORT)) {\n          // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.\n          // No errors reported but the texture is unusable.\n          return false;\n        }\n        // Use texStorage for WebGL2\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {\n    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType, true);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, dataArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (scaledData[0] != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    // always reset the flip\n    if (flip) {\n      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_CUBE_MAP;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    model.maxLevel = data.length / 6 - 1;\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, data);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // invert the data because opengl is messed up with cube maps\n    // and uses the old renderman standard with Y going down\n    // even though it is completely at odds with OpenGL standards\n    const invertedData = [];\n    let widthLevel = model.width;\n    let heightLevel = model.height;\n    for (let i = 0; i < scaledData.length; i++) {\n      if (i % 6 === 0 && i !== 0) {\n        widthLevel /= 2;\n        heightLevel /= 2;\n      }\n      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);\n      for (let y = 0; y < heightLevel; ++y) {\n        const row1 = y * widthLevel * model.components;\n        const row2 = (heightLevel - y - 1) * widthLevel * model.components;\n        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);\n      }\n    }\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);\n    }\n    // We get the 6 images\n    for (let i = 0; i < 6; i++) {\n      // For each mipmap level\n      let j = 0;\n      let w = model.width;\n      let h = model.height;\n      while (w >= 1 && h >= 1) {\n        // In webgl 1, all levels need to be defined. So if the latest level size is\n        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)\n        // In webgl 2, the attribute maxLevel will be use.\n        let tempData = null;\n        if (j <= model.maxLevel) {\n          tempData = invertedData[6 * j + i];\n        }\n        if (useTexStorage(dataType)) {\n          if (tempData != null) {\n            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);\n          }\n        } else {\n          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);\n        }\n        j++;\n        w /= 2;\n        h /= 2;\n      }\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    // generateMipmap must not be called here because we manually upload all levels\n    // if it is called, all levels will be overwritten\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    model.format = model.context.DEPTH_COMPONENT;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT) {\n        model.internalFormat = model.context.DEPTH_COMPONENT32F;\n      } else {\n        model.internalFormat = model.context.DEPTH_COMPONENT16;\n      }\n    } else {\n      model.internalFormat = model.context.DEPTH_COMPONENT;\n    }\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 1;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (data != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromImage = image => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.\n    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));\n    const canvas = document.createElement('canvas');\n    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;\n    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;\n    model.width = canvas.width;\n    model.height = canvas.height;\n    const ctx = canvas.getContext('2d');\n    ctx.translate(0, canvas.height);\n    ctx.scale(1, -1);\n    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n    const safeImage = canvas;\n    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (safeImage != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  // Compute scale and offset per component from min and max per component\n  function computeScaleOffsets(min, max, numComps) {\n    const offset = new Array(numComps);\n    const scale = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = min[c];\n      scale[c] = max[c] - min[c] || 1.0;\n    }\n    return {\n      scale,\n      offset\n    };\n  }\n\n  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,\n  // for numbers outside of this range there is a precision limitation\n  function hasExactHalfFloat(offset, scale) {\n    // Per Component\n    for (let c = 0; c < offset.length; c++) {\n      const min = offset[c];\n      const max = scale[c] + min;\n      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function setCanUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {\n    publicAPI.getOpenGLDataType(dataType);\n\n    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat\n    // AND it is not preferable to have a smaller texture than an exact texture.\n    const isExactHalfFloat = hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy;\n    let useHalfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // If OES_texture_float_linear is not available, and using a half float would still be exact, force half floats\n      // This is because half floats are always texture filterable in webgl2, while full *32F floats are not (unless the extension is present)\n      const forceHalfFloat = model.openGLDataType === model.context.FLOAT && model.context.getExtension('OES_texture_float_linear') === null && isExactHalfFloat;\n      useHalfFloat = forceHalfFloat || model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    model.canUseHalfFloat = useHalfFloat && isExactHalfFloat;\n  }\n  function processDataArray(dataArray, preferSizeOverAccuracy) {\n    const numComps = dataArray.getNumberOfComponents();\n    const dataType = dataArray.getDataType();\n    const data = dataArray.getData();\n\n    // Compute min max from array\n    // Using the vtkDataArray.getRange() enables caching\n    const minArray = new Array(numComps);\n    const maxArray = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      const [min, max] = dataArray.getRange(c);\n      minArray[c] = min;\n      maxArray[c] = max;\n    }\n    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);\n\n    // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247\n    setCanUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);\n\n    // since our default is to use half float, in case that we can't use it\n    // we need to use another type\n    if (!publicAPI.useHalfFloat()) {\n      publicAPI.getOpenGLDataType(dataType, true);\n    }\n    return {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    };\n  }\n  publicAPI.create2DFilterableFromRaw = function (width, height, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    return publicAPI.create2DFilterableFromDataArray(width, height, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n  publicAPI.create2DFilterableFromDataArray = function (width, height, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      numComps,\n      dataType,\n      data\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);\n  };\n  publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {\n    let isScalingApplied = false;\n    const useHalfFloat = publicAPI.useHalfFloat();\n\n    // Initialize volume info if it doesn't exist\n    if (!model.volumeInfo?.scale || !model.volumeInfo?.offset) {\n      model.volumeInfo = {\n        scale: new Array(numComps),\n        offset: new Array(numComps)\n      };\n    }\n\n    // Default scaling and offset\n    for (let c = 0; c < numComps; ++c) {\n      model.volumeInfo.scale[c] = 1.0;\n      model.volumeInfo.offset[c] = 0.0;\n    }\n\n    // Handle SHORT data type with EXT_texture_norm16 extension\n    if (model.oglNorm16Ext && !useHalfFloat && dataType === VtkDataTypes.SHORT) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 32767.0; // Scale to [-1, 1] range\n      }\n      isScalingApplied = true;\n    }\n\n    // Handle UNSIGNED_SHORT data type with EXT_texture_norm16 extension\n    if (model.oglNorm16Ext && !useHalfFloat && dataType === VtkDataTypes.UNSIGNED_SHORT) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 65535.0; // Scale to [0, 1] range\n      }\n      isScalingApplied = true;\n    }\n\n    // Handle UNSIGNED_CHAR data type\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 255.0; // Scale to [0, 1] range\n      }\n      isScalingApplied = true;\n    }\n\n    // No scaling needed for FLOAT or HalfFloat (SHORT/UNSIGNED_SHORT)\n    if (dataType === VtkDataTypes.FLOAT || useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {\n      isScalingApplied = true;\n    }\n    return isScalingApplied;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {\n    let dataTypeToUse = dataType;\n    let dataToUse = data;\n    if (!publicAPI.updateVolumeInfoForGL(dataTypeToUse, numComps) && dataToUse) {\n      const numPixelsIn = width * height * depth;\n      const scaleOffsetsCopy = structuredClone(model.volumeInfo);\n      // otherwise convert to float\n      const newArray = new Float32Array(numPixelsIn * numComps);\n      // use computed scale and offset\n      model.volumeInfo.offset = scaleOffsetsCopy.offset;\n      model.volumeInfo.scale = scaleOffsetsCopy.scale;\n      let count = 0;\n      const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);\n      for (let i = 0; i < numPixelsIn; i++) {\n        for (let nc = 0; nc < numComps; nc++) {\n          newArray[count] = (dataToUse[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];\n          count++;\n        }\n      }\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      dataToUse = newArray;\n    }\n\n    // Permit OpenGLDataType to be half float, if applicable, for 3D\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_3D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = depth;\n    model.numberOfDimensions = 3;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n    // Create an array of texture with one texture\n    const dataArray = [dataToUse];\n    const is3DArray = true;\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataTypeToUse, dataArray, is3DArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // openGLDataType\n\n    if (useTexStorage(dataTypeToUse)) {\n      model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);\n      if (scaledData[0] != null) {\n        model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataTypeToUse, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // This method simulates a 3D texture using 2D\n  // Prefer create3DFilterableFromDataArray to enable caching of min and max values\n  publicAPI.create3DFilterableFromRaw = function (width, height, depth, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    return publicAPI.create3DFilterableFromDataArray(width, height, depth, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n\n  //----------------------------------------------------------------------------\n  // This method create a 3D texture from dimensions and a DataArray\n  publicAPI.create3DFilterableFromDataArray = function (width, height, depth, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    const offset = [];\n    const scale = [];\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = 0.0;\n      scale[c] = 1.0;\n    }\n\n    // store the information, we will need it later\n    // offset and scale are the offset and scale required to get\n    // the texture value back to data values ala\n    // data = texture * scale + offset\n    // and texture = (data - offset)/scale\n    model.volumeInfo = {\n      scale,\n      offset,\n      dataComputedScale: scaleOffsets.scale,\n      dataComputedOffset: scaleOffsets.offset,\n      width,\n      height,\n      depth\n    };\n\n    // Create a copy of scale and offset to avoid aliasing issues\n    // Original is read only, copy is read/write\n    // Use the copy as volumeInfo.scale and volumeInfo.offset\n\n    // WebGL2 path, we have 3d textures etc\n    if (model._openGLRenderWindow.getWebgl2()) {\n      return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n    }\n    const numPixelsIn = width * height * depth;\n    const scaleOffsetsCopy = structuredClone(scaleOffsets);\n\n    // not webgl2, deal with webgl1, no 3d textures\n    // and maybe no float textures\n\n    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {\n      outArray[outIdx] = inValue;\n    };\n    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n    // unsigned char gets used as is\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        scaleOffsetsCopy.offset[c] = 0.0;\n        scaleOffsetsCopy.scale[c] = 255.0;\n      }\n    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n      // use float textures scaled to 0.0 to 1.0\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (inValue - soffset) / sscale;\n      };\n    } else {\n      // worst case, scale data to uchar\n      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;\n      };\n    }\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    // have to pack this 3D texture into pot 2D texture\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,\n    // but it doesn't mean it will fit in memory. If we have to use a float data type\n    // or 4 components, there are good chances that the texture size will blow up\n    // and could not fit in the GPU memory. Use a smaller texture size in that case,\n    // which will force a downsampling of the dataset.\n    // That problem does not occur when using webGL2 since we can pack the data in\n    // denser textures based on our data type.\n    // TODO: try to fit in the biggest supported texture, catch the gl error if it\n    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture\n    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);\n    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {\n      maxTexDim = 4096;\n    }\n\n    // compute estimate for XY subsample\n    let xstride = 1;\n    let ystride = 1;\n    if (numPixelsIn > maxTexDim * maxTexDim) {\n      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));\n      ystride = xstride;\n    }\n    let targetWidth = Math.sqrt(numPixelsIn) / xstride;\n    targetWidth = nearestPowerOfTwo(targetWidth);\n    // determine X reps\n    const xreps = Math.floor(targetWidth * xstride / width);\n    const yreps = Math.ceil(depth / xreps);\n    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);\n    model.width = targetWidth;\n    model.height = targetHeight;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // store the information, we will need it later\n    model.volumeInfo.xreps = xreps;\n    model.volumeInfo.yreps = yreps;\n    model.volumeInfo.xstride = xstride;\n    model.volumeInfo.ystride = ystride;\n    model.volumeInfo.offset = scaleOffsetsCopy.offset;\n    model.volumeInfo.scale = scaleOffsetsCopy.scale;\n\n    // OK stuff the data into the 2d TEXTURE\n\n    // first allocate the new texture\n    let newArray;\n    const pixCount = targetWidth * targetHeight * numComps;\n    if (dataTypeToUse === VtkDataTypes.FLOAT) {\n      newArray = new Float32Array(pixCount);\n    } else {\n      newArray = new Uint8Array(pixCount);\n    }\n\n    // then stuff the data into it, nothing fancy right now\n    // for stride\n    let outIdx = 0;\n    const tileWidth = Math.floor(width / xstride);\n    const tileHeight = Math.floor(height / ystride);\n    for (let yRep = 0; yRep < yreps; yRep++) {\n      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);\n      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));\n      for (let tileY = 0; tileY < tileHeight; tileY++) {\n        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {\n          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);\n          for (let tileX = 0; tileX < tileWidth; tileX++) {\n            // copy value\n            for (let nc = 0; nc < numComps; nc++) {\n              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);\n              outIdx++;\n            }\n          }\n        }\n        outIdx += outXContIncr;\n      }\n    }\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataTypeToUse)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (newArray != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);\n    }\n    publicAPI.deactivate();\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getMaximumTextureSize = ctx => {\n    if (ctx && ctx.isCurrent()) {\n      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);\n    }\n    return -1;\n  };\n\n  // set use half float\n  publicAPI.enableUseHalfFloat = use => {\n    model.enableUseHalfFloat = use;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  _openGLRenderWindow: null,\n  _forceInternalFormat: false,\n  context: null,\n  handle: 0,\n  sendParametersTime: null,\n  textureBuildTime: null,\n  numberOfDimensions: 0,\n  target: 0,\n  format: 0,\n  openGLDataType: 0,\n  components: 0,\n  width: 0,\n  height: 0,\n  depth: 0,\n  autoParameters: true,\n  wrapS: Wrap.CLAMP_TO_EDGE,\n  wrapT: Wrap.CLAMP_TO_EDGE,\n  wrapR: Wrap.CLAMP_TO_EDGE,\n  minificationFilter: Filter.NEAREST,\n  magnificationFilter: Filter.NEAREST,\n  minLOD: -1000.0,\n  maxLOD: 1000.0,\n  baseLevel: 0,\n  maxLevel: 1000,\n  generateMipmap: false,\n  oglNorm16Ext: null,\n  allocatedGPUMemoryInBytes: 0,\n  // by default it is enabled\n  enableUseHalfFloat: true,\n  // but by default we don't know if we can use half float base on the data range\n  canUseHalfFloat: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.sendParametersTime = {};\n  obj(model.sendParametersTime, {\n    mtime: 0\n  });\n  model.textureBuildTime = {};\n  obj(model.textureBuildTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  set(publicAPI, model, ['format', 'openGLDataType']);\n  setGet(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);\n  get(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);\n  moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkOpenGLTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLTexture');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLTexture$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkTexture', newInstance);\nexport { vtkOpenGLTexture$1 as default, extend, newInstance };","map":{"version":3,"names":["Constants","HalfFloat","n","newInstance$1","o","obj","s","set","e","setGet","g","get","i","moveToProtected","a","newTypedArray","c","macro","vtkDataArray","T","isPowerOfTwo","P","nearestPowerOfTwo","vtkViewNode","registerOverride","Wrap","Filter","VtkDataTypes","vtkDebugMacro","vtkErrorMacro","vtkWarningMacro","toHalf","vtkOpenGLTexture","publicAPI","model","classHierarchy","push","render","renWin","arguments","length","undefined","_openGLRenderWindow","_openGLRenderer","getFirstAncestorOfType","getLastAncestorOfType","context","getContext","renderable","getInterpolate","generateMipmap","setMinificationFilter","LINEAR_MIPMAP_LINEAR","LINEAR","setMagnificationFilter","NEAREST","getRepeat","setWrapR","REPEAT","setWrapS","setWrapT","getInputData","setImage","handle","getMTime","textureBuildTime","getImage","getImageLoaded","create2DFromImage","activate","sendParameters","modified","getCanvas","canvas","create2DFromRaw","width","height","UNSIGNED_CHAR","getJsImageData","jsid","data","input","getPointData","getScalars","ext","getExtent","inScalars","getNumberOfInputPorts","indata","scalars","getData","getNumberOfComponents","createCubeFromRaw","getDataType","destroyTexture","deactivate","deleteTexture","numberOfDimensions","target","components","depth","resetFormatAndType","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","getOpenGLFilterMode","minificationFilter","TEXTURE_MAG_FILTER","magnificationFilter","TEXTURE_WRAP_S","getOpenGLWrapMode","wrapS","TEXTURE_WRAP_T","wrapT","getWebgl2","TEXTURE_WRAP_R","wrapR","getTextureUnit","getTextureUnitForTexture","activateTexture","bind","deactivateTexture","releaseGraphicsResources","rwin","internalFormat","format","openGLDataType","allocatedGPUMemoryInBytes","shaderProgram","autoParameters","sendParametersTime","isBound","result","TEXTURE_2D","TEXTURE_BINDING_2D","oid","getIntegerv","TEXTURE_BASE_LEVEL","baseLevel","TEXTURE_MAX_LEVEL","maxLevel","getInternalFormat","vtktype","numComps","_forceInternalFormat","getDefaultInternalFormat","R32F","RG32F","RGB32F","RGBA32F","includes","getExtension","getDefaultTextureInternalFormat","oglNorm16Ext","useHalfFloat","enableUseHalfFloat","canUseHalfFloat","setInternalFormat","iFormat","getFormat","getDefaultFormat","RED","RG","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","getDefaultDataType","vtkScalarType","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","HALF_FLOAT","FLOAT","VOID","halfFloat","HALF_FLOAT_OES","getOpenGLDataType","forceUpdate","getShiftAndScale","shift","scale","BYTE","INT","UNSIGNED_INT","emode","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","CLAMP_TO_EDGE","MIRRORED_REPEAT","updateArrayDataTypeForGL","dataType","pixData","pixCount","idx","dataArrayToCopy","subarray","Float32Array","Uint8Array","halfFloatExt","newArray","Uint16Array","src","scaleTextureToHighestPowerOfTwo","newWidth","newHeight","jFactor","iFactor","usingHalf","j","joff","jidx","jlow","Math","floor","jhi","ceil","jmix","jmix1","ioff","iidx","ilow","ihi","imix","fromHalf","useTexStorage","resizable","getResizable","webGLInfo","getGLInformations","RENDERER","value","match","navigator","platform","flip","dataArray","scaledData","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_ALIGNMENT","texStorage2D","texSubImage2D","texImage2D","getDefaultTextureByteSize","TEXTURE_CUBE_MAP","invertedData","widthLevel","heightLevel","y","row1","row2","slice","w","h","tempData","TEXTURE_CUBE_MAP_POSITIVE_X","createDepthFromRaw","DEPTH_COMPONENT","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","image","needNearestPowerOfTwo","document","createElement","ctx","translate","drawImage","safeImage","computeScaleOffsets","min","max","offset","Array","hasExactHalfFloat","setCanUseHalfFloat","preferSizeOverAccuracy","isExactHalfFloat","forceHalfFloat","processDataArray","minArray","maxArray","getRange","scaleOffsets","create2DFilterableFromRaw","numberOfComponents","values","create2DFilterableFromDataArray","newInstance","updateVolumeInfoForGL","isScalingApplied","volumeInfo","create3DFromRaw","dataTypeToUse","dataToUse","numPixelsIn","scaleOffsetsCopy","structuredClone","count","scaleInverse","map","nc","TEXTURE_3D","is3DArray","texStorage3D","texSubImage3D","texImage3D","create3DFilterableFromRaw","create3DFilterableFromDataArray","dataComputedScale","dataComputedOffset","volCopyData","outArray","outIdx","inValue","smin","smax","soffset","sscale","maxTexDim","getParameter","MAX_TEXTURE_SIZE","xstride","ystride","sqrt","targetWidth","xreps","yreps","targetHeight","tileWidth","tileHeight","yRep","xrepsThisRow","outXContIncr","tileY","xRep","inOffset","tileX","setOpenGLRenderWindow","rw","getMaximumTextureSize","isCurrent","use","DEFAULT_VALUES","minLOD","maxLOD","extend","initialValues","Object","assign","mtime","vtkOpenGLTexture$1","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js"],"sourcesContent":["import Constants from './Texture/Constants.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\nimport { n as newInstance$1, o as obj, s as set, e as setGet, g as get, i as moveToProtected, a as newTypedArray, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { T as isPowerOfTwo, P as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  Wrap,\n  Filter\n} = Constants;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\nconst {\n  toHalf\n} = HalfFloat;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLTexture');\n  // Renders myself\n  publicAPI.render = function () {\n    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (renWin) {\n      model._openGLRenderWindow = renWin;\n    } else {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      // sync renderable properties\n      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');\n    }\n    model.context = model._openGLRenderWindow.getContext();\n    if (model.renderable.getInterpolate()) {\n      if (model.generateMipmap) {\n        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n      } else {\n        publicAPI.setMinificationFilter(Filter.LINEAR);\n      }\n      publicAPI.setMagnificationFilter(Filter.LINEAR);\n    } else {\n      publicAPI.setMinificationFilter(Filter.NEAREST);\n      publicAPI.setMagnificationFilter(Filter.NEAREST);\n    }\n    if (model.renderable.getRepeat()) {\n      publicAPI.setWrapR(Wrap.REPEAT);\n      publicAPI.setWrapS(Wrap.REPEAT);\n      publicAPI.setWrapT(Wrap.REPEAT);\n    }\n    // clear image if input data is set\n    if (model.renderable.getInputData()) {\n      model.renderable.setImage(null);\n    }\n    // create the texture if it is not done already\n    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {\n      // if we have an Image\n      if (model.renderable.getImage() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        // Have an Image which may not be complete\n        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImage(model.renderable.getImage());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      }\n      // if we have a canvas\n      if (model.renderable.getCanvas() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        const canvas = model.renderable.getCanvas();\n        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have jsImageData\n      if (model.renderable.getJsImageData() !== null) {\n        const jsid = model.renderable.getJsImageData();\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have InputData\n      const input = model.renderable.getInputData(0);\n      if (input && input.getPointData().getScalars()) {\n        const ext = input.getExtent();\n        const inScalars = input.getPointData().getScalars();\n\n        // do we have a cube map? Six inputs\n        const data = [];\n        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {\n          const indata = model.renderable.getInputData(i);\n          const scalars = indata ? indata.getPointData().getScalars().getData() : null;\n          if (scalars) {\n            data.push(scalars);\n          }\n        }\n        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        if (data.length % 6 === 0) {\n          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);\n        } else {\n          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n        }\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n    }\n    if (model.handle) {\n      publicAPI.activate();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.destroyTexture = () => {\n    // deactivate it first\n    publicAPI.deactivate();\n    if (model.context && model.handle) {\n      model.context.deleteTexture(model.handle);\n    }\n    model.handle = 0;\n    model.numberOfDimensions = 0;\n    model.target = 0;\n    model.components = 0;\n    model.width = 0;\n    model.height = 0;\n    model.depth = 0;\n    publicAPI.resetFormatAndType();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createTexture = () => {\n    // reuse the existing handle if we have one\n    if (!model.handle) {\n      model.handle = model.context.createTexture();\n      if (model.target) {\n        model.context.bindTexture(model.target, model.handle);\n\n        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture\n        // turn off mip map filter or set the base and max level correctly. here\n        // both are done.\n        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n        if (model._openGLRenderWindow.getWebgl2()) {\n          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n        }\n        model.context.bindTexture(model.target, null);\n      }\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.getTextureUnit = () => {\n    if (model._openGLRenderWindow) {\n      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);\n    }\n    return -1;\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.activate = () => {\n    // activate a free texture unit for this texture\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.bind();\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.deactivate = () => {\n    if (model._openGLRenderWindow) {\n      model._openGLRenderWindow.deactivateTexture(publicAPI);\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.releaseGraphicsResources = rwin => {\n    if (rwin && model.handle) {\n      rwin.activateTexture(publicAPI);\n      rwin.deactivateTexture(publicAPI);\n      model.context.deleteTexture(model.handle);\n      model.handle = 0;\n      model.numberOfDimensions = 0;\n      model.target = 0;\n      model.internalFormat = 0;\n      model.format = 0;\n      model.openGLDataType = 0;\n      model.components = 0;\n      model.width = 0;\n      model.height = 0;\n      model.depth = 0;\n      model.allocatedGPUMemoryInBytes = 0;\n    }\n    if (model.shaderProgram) {\n      model.shaderProgram.releaseGraphicsResources(rwin);\n      model.shaderProgram = null;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.bind = () => {\n    model.context.bindTexture(model.target, model.handle);\n    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {\n      publicAPI.sendParameters();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.isBound = () => {\n    let result = false;\n    if (model.context && model.handle) {\n      let target = 0;\n      switch (model.target) {\n        case model.context.TEXTURE_2D:\n          target = model.context.TEXTURE_BINDING_2D;\n          break;\n        default:\n          vtkWarningMacro('impossible case');\n          break;\n      }\n      const oid = model.context.getIntegerv(target);\n      result = oid === model.handle;\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.sendParameters = () => {\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n    }\n    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);\n      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);\n    }\n\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);\n\n    model.sendParametersTime.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getInternalFormat = (vtktype, numComps) => {\n    if (!model._forceInternalFormat) {\n      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);\n    }\n    if (!model.internalFormat) {\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension('OES_texture_float_linear')) {\n      vtkWarningMacro('Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.');\n    }\n    return model.internalFormat;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {\n    let result = 0;\n    // try default next\n    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    if (result) {\n      return result;\n    }\n    if (!result) {\n      vtkDebugMacro('Unsupported internal texture type!');\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return result;\n  };\n  publicAPI.useHalfFloat = () => model.enableUseHalfFloat && model.canUseHalfFloat;\n\n  //----------------------------------------------------------------------------\n  publicAPI.setInternalFormat = iFormat => {\n    model._forceInternalFormat = true;\n    if (iFormat !== model.internalFormat) {\n      model.internalFormat = iFormat;\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getFormat = (vtktype, numComps) => {\n    model.format = publicAPI.getDefaultFormat(vtktype, numComps);\n    return model.format;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultFormat = (vtktype, numComps) => {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (numComps) {\n        case 1:\n          return model.context.RED;\n        case 2:\n          return model.context.RG;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    } else {\n      // webgl1\n      switch (numComps) {\n        case 1:\n          return model.context.LUMINANCE;\n        case 2:\n          return model.context.LUMINANCE_ALPHA;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetFormatAndType = () => {\n    model.format = 0;\n    model.internalFormat = 0;\n    model._forceInternalFormat = false;\n    model.openGLDataType = 0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultDataType = vtkScalarType => {\n    const useHalfFloat = publicAPI.useHalfFloat();\n    // DON'T DEAL with VTK_CHAR as this is platform dependent.\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (vtkScalarType) {\n        // case VtkDataTypes.SIGNED_CHAR:\n        //   return model.context.BYTE;\n        case VtkDataTypes.UNSIGNED_CHAR:\n          return model.context.UNSIGNED_BYTE;\n        // prefer norm16 since that is accurate compared to\n        // half float which is not\n        case model.oglNorm16Ext && !useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.SHORT;\n        case model.oglNorm16Ext && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.UNSIGNED_SHORT;\n        // use half float type\n        case useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.HALF_FLOAT;\n        case useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.HALF_FLOAT;\n        // case VtkDataTypes.INT:\n        //   return model.context.INT;\n        // case VtkDataTypes.UNSIGNED_INT:\n        //   return model.context.UNSIGNED_INT;\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.VOID: // used for depth component textures.\n        default:\n          return model.context.FLOAT;\n      }\n    }\n    switch (vtkScalarType) {\n      // case VtkDataTypes.SIGNED_CHAR:\n      //   return model.context.BYTE;\n      case VtkDataTypes.UNSIGNED_CHAR:\n        return model.context.UNSIGNED_BYTE;\n      // case VtkDataTypes.SHORT:\n      //   return model.context.SHORT;\n      // case VtkDataTypes.UNSIGNED_SHORT:\n      //   return model.context.UNSIGNED_SHORT;\n      // case VtkDataTypes.INT:\n      //   return model.context.INT;\n      // case VtkDataTypes.UNSIGNED_INT:\n      //   return model.context.UNSIGNED_INT;\n      case VtkDataTypes.FLOAT:\n      case VtkDataTypes.VOID: // used for depth component textures.\n      default:\n        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n          return model.context.FLOAT;\n        }\n        {\n          const halfFloat = model.context.getExtension('OES_texture_half_float');\n          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {\n            return halfFloat.HALF_FLOAT_OES;\n          }\n        }\n        return model.context.UNSIGNED_BYTE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLDataType = function (vtkScalarType) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!model.openGLDataType || forceUpdate) {\n      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);\n    }\n    return model.openGLDataType;\n  };\n  publicAPI.getShiftAndScale = () => {\n    let shift = 0.0;\n    let scale = 1.0;\n\n    // for all float type internal formats\n    switch (model.openGLDataType) {\n      case model.context.BYTE:\n        scale = 127.5;\n        shift = scale - 128.0;\n        break;\n      case model.context.UNSIGNED_BYTE:\n        scale = 255.0;\n        shift = 0.0;\n        break;\n      case model.context.SHORT:\n        scale = 32767.5;\n        shift = scale - 32768.0;\n        break;\n      case model.context.UNSIGNED_SHORT:\n        scale = 65536.0;\n        shift = 0.0;\n        break;\n      case model.context.INT:\n        scale = 2147483647.5;\n        shift = scale - 2147483648.0;\n        break;\n      case model.context.UNSIGNED_INT:\n        scale = 4294967295.0;\n        shift = 0.0;\n        break;\n      case model.context.FLOAT:\n    }\n    return {\n      shift,\n      scale\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLFilterMode = emode => {\n    switch (emode) {\n      case Filter.NEAREST:\n        return model.context.NEAREST;\n      case Filter.LINEAR:\n        return model.context.LINEAR;\n      case Filter.NEAREST_MIPMAP_NEAREST:\n        return model.context.NEAREST_MIPMAP_NEAREST;\n      case Filter.NEAREST_MIPMAP_LINEAR:\n        return model.context.NEAREST_MIPMAP_LINEAR;\n      case Filter.LINEAR_MIPMAP_NEAREST:\n        return model.context.LINEAR_MIPMAP_NEAREST;\n      case Filter.LINEAR_MIPMAP_LINEAR:\n        return model.context.LINEAR_MIPMAP_LINEAR;\n      default:\n        return model.context.NEAREST;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLWrapMode = vtktype => {\n    switch (vtktype) {\n      case Wrap.CLAMP_TO_EDGE:\n        return model.context.CLAMP_TO_EDGE;\n      case Wrap.REPEAT:\n        return model.context.REPEAT;\n      case Wrap.MIRRORED_REPEAT:\n        return model.context.MIRRORED_REPEAT;\n      default:\n        return model.context.CLAMP_TO_EDGE;\n    }\n  };\n\n  /**\n   * Updates the data array to match the required data type for OpenGL.\n   *\n   * This function takes the input data and converts it to the appropriate\n   * format required by the OpenGL texture, based on the specified data type.\n   *\n   * @param {string} dataType - The original data type of the input data.\n   * @param {Array} data - The input data array that needs to be updated.\n   * @param {boolean} [depth=false] - Indicates whether the data is a 3D array.\n   * @returns {Array} The updated data array that matches the OpenGL data type.\n   */\n  publicAPI.updateArrayDataTypeForGL = function (dataType, data) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const pixData = [];\n    let pixCount = model.width * model.height * model.components;\n    if (depth) {\n      pixCount *= model.depth;\n    }\n\n    // if the opengl data type is float\n    // then the data array must be float\n    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Float32Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is ubyte\n    // then the data array must be u8, we currently simply truncate the data\n    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n          pixData.push(new Uint8Array(dataArrayToCopy));\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is half float\n    // then the data array must be u16\n    let halfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    if (halfFloat) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const newArray = new Uint16Array(pixCount);\n          const src = data[idx];\n          for (let i = 0; i < pixCount; i++) {\n            newArray[i] = toHalf(src[i]);\n          }\n          pixData.push(newArray);\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  };\n\n  //----------------------------------------------------------------------------\n  function scaleTextureToHighestPowerOfTwo(data) {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // No need if webGL2\n      return data;\n    }\n    const pixData = [];\n    const width = model.width;\n    const height = model.height;\n    const numComps = model.components;\n    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {\n      // Scale up the texture to the next highest power of two dimensions.\n      const halfFloat = model.context.getExtension('OES_texture_half_float');\n      const newWidth = nearestPowerOfTwo(width);\n      const newHeight = nearestPowerOfTwo(height);\n      const pixCount = newWidth * newHeight * model.components;\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx] !== null) {\n          let newArray = null;\n          const jFactor = height / newHeight;\n          const iFactor = width / newWidth;\n          let usingHalf = false;\n          if (model.openGLDataType === model.context.FLOAT) {\n            newArray = new Float32Array(pixCount);\n          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {\n            newArray = new Uint16Array(pixCount);\n            usingHalf = true;\n          } else {\n            newArray = new Uint8Array(pixCount);\n          }\n          for (let j = 0; j < newHeight; j++) {\n            const joff = j * newWidth * numComps;\n            const jidx = j * jFactor;\n            let jlow = Math.floor(jidx);\n            let jhi = Math.ceil(jidx);\n            if (jhi >= height) {\n              jhi = height - 1;\n            }\n            const jmix = jidx - jlow;\n            const jmix1 = 1.0 - jmix;\n            jlow = jlow * width * numComps;\n            jhi = jhi * width * numComps;\n            for (let i = 0; i < newWidth; i++) {\n              const ioff = i * numComps;\n              const iidx = i * iFactor;\n              let ilow = Math.floor(iidx);\n              let ihi = Math.ceil(iidx);\n              if (ihi >= width) {\n                ihi = width - 1;\n              }\n              const imix = iidx - ilow;\n              ilow *= numComps;\n              ihi *= numComps;\n              for (let c = 0; c < numComps; c++) {\n                if (usingHalf) {\n                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);\n                } else {\n                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;\n                }\n              }\n            }\n          }\n          pixData.push(newArray);\n          model.width = newWidth;\n          model.height = newHeight;\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function useTexStorage(dataType) {\n    if (model._openGLRenderWindow) {\n      if (model.resizable || model.renderable?.getResizable()) {\n        // Cannot use texStorage if the texture is supposed to be resizable.\n        return false;\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        const webGLInfo = model._openGLRenderWindow.getGLInformations();\n        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && model.oglNorm16Ext && (dataType === VtkDataTypes.UNSIGNED_SHORT || dataType === VtkDataTypes.SHORT)) {\n          // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.\n          // No errors reported but the texture is unusable.\n          return false;\n        }\n        // Use texStorage for WebGL2\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {\n    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType, true);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, dataArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (scaledData[0] != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    // always reset the flip\n    if (flip) {\n      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_CUBE_MAP;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    model.maxLevel = data.length / 6 - 1;\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, data);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // invert the data because opengl is messed up with cube maps\n    // and uses the old renderman standard with Y going down\n    // even though it is completely at odds with OpenGL standards\n    const invertedData = [];\n    let widthLevel = model.width;\n    let heightLevel = model.height;\n    for (let i = 0; i < scaledData.length; i++) {\n      if (i % 6 === 0 && i !== 0) {\n        widthLevel /= 2;\n        heightLevel /= 2;\n      }\n      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);\n      for (let y = 0; y < heightLevel; ++y) {\n        const row1 = y * widthLevel * model.components;\n        const row2 = (heightLevel - y - 1) * widthLevel * model.components;\n        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);\n      }\n    }\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);\n    }\n    // We get the 6 images\n    for (let i = 0; i < 6; i++) {\n      // For each mipmap level\n      let j = 0;\n      let w = model.width;\n      let h = model.height;\n      while (w >= 1 && h >= 1) {\n        // In webgl 1, all levels need to be defined. So if the latest level size is\n        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)\n        // In webgl 2, the attribute maxLevel will be use.\n        let tempData = null;\n        if (j <= model.maxLevel) {\n          tempData = invertedData[6 * j + i];\n        }\n        if (useTexStorage(dataType)) {\n          if (tempData != null) {\n            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);\n          }\n        } else {\n          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);\n        }\n        j++;\n        w /= 2;\n        h /= 2;\n      }\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    // generateMipmap must not be called here because we manually upload all levels\n    // if it is called, all levels will be overwritten\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    model.format = model.context.DEPTH_COMPONENT;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT) {\n        model.internalFormat = model.context.DEPTH_COMPONENT32F;\n      } else {\n        model.internalFormat = model.context.DEPTH_COMPONENT16;\n      }\n    } else {\n      model.internalFormat = model.context.DEPTH_COMPONENT;\n    }\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 1;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (data != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromImage = image => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.\n    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));\n    const canvas = document.createElement('canvas');\n    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;\n    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;\n    model.width = canvas.width;\n    model.height = canvas.height;\n    const ctx = canvas.getContext('2d');\n    ctx.translate(0, canvas.height);\n    ctx.scale(1, -1);\n    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n    const safeImage = canvas;\n    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (safeImage != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  // Compute scale and offset per component from min and max per component\n  function computeScaleOffsets(min, max, numComps) {\n    const offset = new Array(numComps);\n    const scale = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = min[c];\n      scale[c] = max[c] - min[c] || 1.0;\n    }\n    return {\n      scale,\n      offset\n    };\n  }\n\n  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,\n  // for numbers outside of this range there is a precision limitation\n  function hasExactHalfFloat(offset, scale) {\n    // Per Component\n    for (let c = 0; c < offset.length; c++) {\n      const min = offset[c];\n      const max = scale[c] + min;\n      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function setCanUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {\n    publicAPI.getOpenGLDataType(dataType);\n\n    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat\n    // AND it is not preferable to have a smaller texture than an exact texture.\n    const isExactHalfFloat = hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy;\n    let useHalfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // If OES_texture_float_linear is not available, and using a half float would still be exact, force half floats\n      // This is because half floats are always texture filterable in webgl2, while full *32F floats are not (unless the extension is present)\n      const forceHalfFloat = model.openGLDataType === model.context.FLOAT && model.context.getExtension('OES_texture_float_linear') === null && isExactHalfFloat;\n      useHalfFloat = forceHalfFloat || model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    model.canUseHalfFloat = useHalfFloat && isExactHalfFloat;\n  }\n  function processDataArray(dataArray, preferSizeOverAccuracy) {\n    const numComps = dataArray.getNumberOfComponents();\n    const dataType = dataArray.getDataType();\n    const data = dataArray.getData();\n\n    // Compute min max from array\n    // Using the vtkDataArray.getRange() enables caching\n    const minArray = new Array(numComps);\n    const maxArray = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      const [min, max] = dataArray.getRange(c);\n      minArray[c] = min;\n      maxArray[c] = max;\n    }\n    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);\n\n    // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247\n    setCanUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);\n\n    // since our default is to use half float, in case that we can't use it\n    // we need to use another type\n    if (!publicAPI.useHalfFloat()) {\n      publicAPI.getOpenGLDataType(dataType, true);\n    }\n    return {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    };\n  }\n  publicAPI.create2DFilterableFromRaw = function (width, height, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    return publicAPI.create2DFilterableFromDataArray(width, height, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n  publicAPI.create2DFilterableFromDataArray = function (width, height, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      numComps,\n      dataType,\n      data\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);\n  };\n  publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {\n    let isScalingApplied = false;\n    const useHalfFloat = publicAPI.useHalfFloat();\n\n    // Initialize volume info if it doesn't exist\n    if (!model.volumeInfo?.scale || !model.volumeInfo?.offset) {\n      model.volumeInfo = {\n        scale: new Array(numComps),\n        offset: new Array(numComps)\n      };\n    }\n\n    // Default scaling and offset\n    for (let c = 0; c < numComps; ++c) {\n      model.volumeInfo.scale[c] = 1.0;\n      model.volumeInfo.offset[c] = 0.0;\n    }\n\n    // Handle SHORT data type with EXT_texture_norm16 extension\n    if (model.oglNorm16Ext && !useHalfFloat && dataType === VtkDataTypes.SHORT) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 32767.0; // Scale to [-1, 1] range\n      }\n\n      isScalingApplied = true;\n    }\n\n    // Handle UNSIGNED_SHORT data type with EXT_texture_norm16 extension\n    if (model.oglNorm16Ext && !useHalfFloat && dataType === VtkDataTypes.UNSIGNED_SHORT) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 65535.0; // Scale to [0, 1] range\n      }\n\n      isScalingApplied = true;\n    }\n\n    // Handle UNSIGNED_CHAR data type\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 255.0; // Scale to [0, 1] range\n      }\n\n      isScalingApplied = true;\n    }\n\n    // No scaling needed for FLOAT or HalfFloat (SHORT/UNSIGNED_SHORT)\n    if (dataType === VtkDataTypes.FLOAT || useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {\n      isScalingApplied = true;\n    }\n    return isScalingApplied;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {\n    let dataTypeToUse = dataType;\n    let dataToUse = data;\n    if (!publicAPI.updateVolumeInfoForGL(dataTypeToUse, numComps) && dataToUse) {\n      const numPixelsIn = width * height * depth;\n      const scaleOffsetsCopy = structuredClone(model.volumeInfo);\n      // otherwise convert to float\n      const newArray = new Float32Array(numPixelsIn * numComps);\n      // use computed scale and offset\n      model.volumeInfo.offset = scaleOffsetsCopy.offset;\n      model.volumeInfo.scale = scaleOffsetsCopy.scale;\n      let count = 0;\n      const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);\n      for (let i = 0; i < numPixelsIn; i++) {\n        for (let nc = 0; nc < numComps; nc++) {\n          newArray[count] = (dataToUse[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];\n          count++;\n        }\n      }\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      dataToUse = newArray;\n    }\n\n    // Permit OpenGLDataType to be half float, if applicable, for 3D\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_3D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = depth;\n    model.numberOfDimensions = 3;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n    // Create an array of texture with one texture\n    const dataArray = [dataToUse];\n    const is3DArray = true;\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataTypeToUse, dataArray, is3DArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // openGLDataType\n\n    if (useTexStorage(dataTypeToUse)) {\n      model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);\n      if (scaledData[0] != null) {\n        model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataTypeToUse, model.oglNorm16Ext, publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // This method simulates a 3D texture using 2D\n  // Prefer create3DFilterableFromDataArray to enable caching of min and max values\n  publicAPI.create3DFilterableFromRaw = function (width, height, depth, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    return publicAPI.create3DFilterableFromDataArray(width, height, depth, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values\n    }), preferSizeOverAccuracy);\n  };\n\n  //----------------------------------------------------------------------------\n  // This method create a 3D texture from dimensions and a DataArray\n  publicAPI.create3DFilterableFromDataArray = function (width, height, depth, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    const offset = [];\n    const scale = [];\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = 0.0;\n      scale[c] = 1.0;\n    }\n\n    // store the information, we will need it later\n    // offset and scale are the offset and scale required to get\n    // the texture value back to data values ala\n    // data = texture * scale + offset\n    // and texture = (data - offset)/scale\n    model.volumeInfo = {\n      scale,\n      offset,\n      dataComputedScale: scaleOffsets.scale,\n      dataComputedOffset: scaleOffsets.offset,\n      width,\n      height,\n      depth\n    };\n\n    // Create a copy of scale and offset to avoid aliasing issues\n    // Original is read only, copy is read/write\n    // Use the copy as volumeInfo.scale and volumeInfo.offset\n\n    // WebGL2 path, we have 3d textures etc\n    if (model._openGLRenderWindow.getWebgl2()) {\n      return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);\n    }\n    const numPixelsIn = width * height * depth;\n    const scaleOffsetsCopy = structuredClone(scaleOffsets);\n\n    // not webgl2, deal with webgl1, no 3d textures\n    // and maybe no float textures\n\n    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {\n      outArray[outIdx] = inValue;\n    };\n    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n    // unsigned char gets used as is\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        scaleOffsetsCopy.offset[c] = 0.0;\n        scaleOffsetsCopy.scale[c] = 255.0;\n      }\n    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n      // use float textures scaled to 0.0 to 1.0\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (inValue - soffset) / sscale;\n      };\n    } else {\n      // worst case, scale data to uchar\n      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;\n      };\n    }\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    // have to pack this 3D texture into pot 2D texture\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,\n    // but it doesn't mean it will fit in memory. If we have to use a float data type\n    // or 4 components, there are good chances that the texture size will blow up\n    // and could not fit in the GPU memory. Use a smaller texture size in that case,\n    // which will force a downsampling of the dataset.\n    // That problem does not occur when using webGL2 since we can pack the data in\n    // denser textures based on our data type.\n    // TODO: try to fit in the biggest supported texture, catch the gl error if it\n    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture\n    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);\n    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {\n      maxTexDim = 4096;\n    }\n\n    // compute estimate for XY subsample\n    let xstride = 1;\n    let ystride = 1;\n    if (numPixelsIn > maxTexDim * maxTexDim) {\n      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));\n      ystride = xstride;\n    }\n    let targetWidth = Math.sqrt(numPixelsIn) / xstride;\n    targetWidth = nearestPowerOfTwo(targetWidth);\n    // determine X reps\n    const xreps = Math.floor(targetWidth * xstride / width);\n    const yreps = Math.ceil(depth / xreps);\n    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);\n    model.width = targetWidth;\n    model.height = targetHeight;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // store the information, we will need it later\n    model.volumeInfo.xreps = xreps;\n    model.volumeInfo.yreps = yreps;\n    model.volumeInfo.xstride = xstride;\n    model.volumeInfo.ystride = ystride;\n    model.volumeInfo.offset = scaleOffsetsCopy.offset;\n    model.volumeInfo.scale = scaleOffsetsCopy.scale;\n\n    // OK stuff the data into the 2d TEXTURE\n\n    // first allocate the new texture\n    let newArray;\n    const pixCount = targetWidth * targetHeight * numComps;\n    if (dataTypeToUse === VtkDataTypes.FLOAT) {\n      newArray = new Float32Array(pixCount);\n    } else {\n      newArray = new Uint8Array(pixCount);\n    }\n\n    // then stuff the data into it, nothing fancy right now\n    // for stride\n    let outIdx = 0;\n    const tileWidth = Math.floor(width / xstride);\n    const tileHeight = Math.floor(height / ystride);\n    for (let yRep = 0; yRep < yreps; yRep++) {\n      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);\n      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));\n      for (let tileY = 0; tileY < tileHeight; tileY++) {\n        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {\n          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);\n          for (let tileX = 0; tileX < tileWidth; tileX++) {\n            // copy value\n            for (let nc = 0; nc < numComps; nc++) {\n              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);\n              outIdx++;\n            }\n          }\n        }\n        outIdx += outXContIncr;\n      }\n    }\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataTypeToUse)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (newArray != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);\n    }\n    publicAPI.deactivate();\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getMaximumTextureSize = ctx => {\n    if (ctx && ctx.isCurrent()) {\n      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);\n    }\n    return -1;\n  };\n\n  // set use half float\n  publicAPI.enableUseHalfFloat = use => {\n    model.enableUseHalfFloat = use;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  _openGLRenderWindow: null,\n  _forceInternalFormat: false,\n  context: null,\n  handle: 0,\n  sendParametersTime: null,\n  textureBuildTime: null,\n  numberOfDimensions: 0,\n  target: 0,\n  format: 0,\n  openGLDataType: 0,\n  components: 0,\n  width: 0,\n  height: 0,\n  depth: 0,\n  autoParameters: true,\n  wrapS: Wrap.CLAMP_TO_EDGE,\n  wrapT: Wrap.CLAMP_TO_EDGE,\n  wrapR: Wrap.CLAMP_TO_EDGE,\n  minificationFilter: Filter.NEAREST,\n  magnificationFilter: Filter.NEAREST,\n  minLOD: -1000.0,\n  maxLOD: 1000.0,\n  baseLevel: 0,\n  maxLevel: 1000,\n  generateMipmap: false,\n  oglNorm16Ext: null,\n  allocatedGPUMemoryInBytes: 0,\n  // by default it is enabled\n  enableUseHalfFloat: true,\n  // but by default we don't know if we can use half float base on the data range\n  canUseHalfFloat: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.sendParametersTime = {};\n  obj(model.sendParametersTime, {\n    mtime: 0\n  });\n  model.textureBuildTime = {};\n  obj(model.textureBuildTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  set(publicAPI, model, ['format', 'openGLDataType']);\n  setGet(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);\n  get(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);\n  moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkOpenGLTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLTexture');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLTexture$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkTexture', newInstance);\n\nexport { vtkOpenGLTexture$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}