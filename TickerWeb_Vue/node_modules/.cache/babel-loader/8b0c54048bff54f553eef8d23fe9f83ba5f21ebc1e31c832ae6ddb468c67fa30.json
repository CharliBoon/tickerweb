{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkAbstractMapper3D from './AbstractMapper3D.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkLookupTable from '../../Common/Core/LookupTable.js';\nimport { F as createUninitializedBounds, i as isNan } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors/Constants.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nimport Constants from './Mapper/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport { PassTypes } from '../OpenGL/HardwareSelector/Constants.js';\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  ColorMode,\n  ScalarMode,\n  GetArray\n} = Constants;\nconst {\n  VectorMode\n} = vtkScalarsToColors;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\n\n// ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);\n}\n\n/**\n * Increase by one the 3D coordinates\n * It will follow a zigzag pattern so that each coordinate is the neighbor of the next coordinate\n * This enables interpolation between two texels without issues\n * Note: texture coordinates can't be interpolated using this pattern\n * @param {vec3} coordinates The 3D coordinates using integers for each coorinate\n * @param {vec3} dimensions The 3D dimensions of the volume\n */\nfunction updateZigzaggingCoordinates(coordinates, dimensions) {\n  const directionX = coordinates[1] % 2 === 0 ? 1 : -1;\n  coordinates[0] += directionX;\n  if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {\n    const directionY = coordinates[2] % 2 === 0 ? 1 : -1;\n    coordinates[0] -= directionX;\n    coordinates[1] += directionY;\n    if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {\n      coordinates[1] -= directionY;\n      coordinates[2]++;\n    }\n  }\n}\n\n/**\n * Returns the index in the array representing the volume from a 3D coordinate\n * @param {vec3} coordinates The 3D integer coordinates\n * @param {vec3} dimensions The 3D dimensions of the volume\n * @returns The index in a flat array representing the volume\n */\nfunction getIndexFromCoordinates(coordinates, dimensions) {\n  return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);\n}\n\n/**\n * Write texture coordinates for the given `texelIndexPosition` in `textureCoordinate`.\n * The `texelIndexPosition` is a floating point number that represents the distance in index space\n * from the center of the first texel to the final output position.\n * The output is given in texture coordinates and not in index coordinates (this is done at the very end of the function)\n * @param {vec3} textureCoordinate The output texture coordinates (to avoid allocating a new Array)\n * @param {Number} texelIndexPosition The floating point distance from the center of the first texel, following a zigzag pattern\n * @param {vec3} dimensions The 3D dimensions of the volume\n */\nfunction getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {\n  // First compute the integer textureCoordinate\n  const intTexelIndex = Math.floor(texelIndexPosition);\n  const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);\n  let xDirection;\n  let xEndFlag;\n  if (xCoordBeforeWrap < dimensions[0]) {\n    textureCoordinate[0] = xCoordBeforeWrap;\n    xDirection = 1;\n    xEndFlag = textureCoordinate[0] === dimensions[0] - 1;\n  } else {\n    textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;\n    xDirection = -1;\n    xEndFlag = textureCoordinate[0] === 0;\n  }\n  const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);\n  const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);\n  let yDirection;\n  let yEndFlag;\n  if (yCoordBeforeWrap < dimensions[1]) {\n    textureCoordinate[1] = yCoordBeforeWrap;\n    yDirection = 1;\n    yEndFlag = textureCoordinate[1] === dimensions[1] - 1;\n  } else {\n    textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;\n    yDirection = -1;\n    yEndFlag = textureCoordinate[1] === 0;\n  }\n  textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);\n\n  // Now add the remainder either in x, y or z\n  const remainder = texelIndexPosition - intTexelIndex;\n  if (xEndFlag) {\n    if (yEndFlag) {\n      textureCoordinate[2] += remainder;\n    } else {\n      textureCoordinate[1] += yDirection * remainder;\n    }\n  } else {\n    textureCoordinate[0] += xDirection * remainder;\n  }\n\n  // textureCoordinates are in index space, convert to texture space\n  textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];\n  textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];\n  textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];\n}\n\n// Associate an input vtkDataArray to an object { stringHash, textureCoordinates }\n// A single dataArray only caches one array of texture coordinates, so this cache is useless when\n// the input data array is used with two different lookup tables (which is very unlikely)\nconst colorTextureCoordinatesCache = new WeakMap();\n/**\n * The minimum of the range is mapped to the center of the first texel excluding min texel (texel at index distance 1)\n * The maximum of the range is mapped to the center of the last texel excluding max and NaN texels (texel at index distance numberOfColorsInRange)\n * The result is cached, and is reused if the arguments are the same and the input doesn't change\n * @param {vtkDataArray} input The input data array used for coloring\n * @param {Number} component The component of the input data array that is used for coloring (-1 for magnitude of the vectors)\n * @param {Range} range The range of the scalars\n * @param {Number} numberOfColorsInRange The number of colors that are used in the range\n * @param {vec3} dimensions The dimensions of the texture\n * @param {boolean} useLogScale If log scale should be used to transform input scalars\n * @param {boolean} useZigzagPattern If a zigzag pattern should be used. Otherwise 1 row for colors (including min and max) and 1 row for NaN are used.\n * @returns A vtkDataArray containing the texture coordinates (2D or 3D)\n */\nfunction getOrCreateColorTextureCoordinates(input, component, range, numberOfColorsInRange, dimensions, useLogScale, useZigzagPattern) {\n  // Caching using the \"arguments\" special object (because it is a pure function)\n  const argStrings = new Array(arguments.length);\n  for (let argIndex = 0; argIndex < arguments.length; ++argIndex) {\n    // eslint-disable-next-line prefer-rest-params\n    const arg = arguments[argIndex];\n    argStrings[argIndex] = arg.getMTime?.() ?? arg;\n  }\n  const stringHash = argStrings.join('/');\n  const cachedResult = colorTextureCoordinatesCache.get(input);\n  if (cachedResult && cachedResult.stringHash === stringHash) {\n    return cachedResult.textureCoordinates;\n  }\n\n  // The range used for computing coordinates have to change\n  // slightly to accommodate the special above- and below-range\n  // colors that are the first and last texels, respectively.\n  const scalarTexelWidth = (range[1] - range[0]) / (numberOfColorsInRange - 1);\n  const [paddedRangeMin, paddedRangeMax] = [range[0] - scalarTexelWidth, range[1] + scalarTexelWidth];\n\n  // Use the center of the voxel\n  const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;\n  const textureSCoeff = 1.0 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);\n\n  // Compute in index space first\n  const texelIndexOrigin = paddedRangeMin;\n  const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);\n  const inputV = input.getData();\n  const numScalars = input.getNumberOfTuples();\n  const numComps = input.getNumberOfComponents();\n  const useMagnitude = component < 0 || component >= numComps;\n  const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;\n  const output = vtkDataArray.newInstance({\n    numberOfComponents: numberOfOutputComponents,\n    values: new Float32Array(numScalars * numberOfOutputComponents)\n  });\n  const outputV = output.getData();\n  const nanTextureCoordinate = [0, 0, 0];\n  // Distance of NaN from the beginning:\n  // min: 0, ...colorsInRange, max: numberOfColorsInRange + 1, NaN = numberOfColorsInRange + 2\n  getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);\n\n  // Set a texture coordinate in the output for each tuple in the input\n  let inputIdx = 0;\n  let outputIdx = 0;\n  const textureCoordinate = [0.5, 0.5, 0.5];\n  for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n    // Get scalar value from magnitude or a single component\n    let scalarValue;\n    if (useMagnitude) {\n      let sum = 0;\n      for (let compIdx = 0; compIdx < numComps; ++compIdx) {\n        const compValue = inputV[inputIdx + compIdx];\n        sum += compValue * compValue;\n      }\n      scalarValue = Math.sqrt(sum);\n    } else {\n      scalarValue = inputV[inputIdx + component];\n    }\n    inputIdx += numComps;\n\n    // Apply log scale if necessary\n    if (useLogScale) {\n      scalarValue = vtkLookupTable.applyLogScale(scalarValue, range, range);\n    }\n\n    // Convert to texture coordinates and update output\n    if (isNan(scalarValue)) {\n      // Last texels are NaN colors (there is at least one NaN color)\n      textureCoordinate[0] = nanTextureCoordinate[0];\n      textureCoordinate[1] = nanTextureCoordinate[1];\n      textureCoordinate[2] = nanTextureCoordinate[2];\n    } else if (useZigzagPattern) {\n      // Texel position is in [0, numberOfColorsInRange + 1]\n      let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;\n      if (texelIndexPosition < 1) {\n        // Use min color when smaller than range\n        texelIndexPosition = 0;\n      } else if (texelIndexPosition > numberOfColorsInRange) {\n        // Use max color when greater than range\n        texelIndexPosition = numberOfColorsInRange + 1;\n      }\n\n      // Convert the texel position into texture coordinate following a zigzag pattern\n      getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);\n    } else {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      textureCoordinate[1] = 0.49;\n\n      // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n      const textureS = (scalarValue - textureSOrigin) * textureSCoeff;\n      if (textureS > 1000.0) {\n        textureCoordinate[0] = 1000.0;\n      } else if (textureS < -1000.0) {\n        textureCoordinate[0] = -1000.0;\n      } else {\n        textureCoordinate[0] = textureS;\n      }\n    }\n    for (let i = 0; i < numberOfOutputComponents; ++i) {\n      outputV[outputIdx++] = textureCoordinate[i];\n    }\n  }\n  colorTextureCoordinatesCache.set(input, {\n    stringHash,\n    textureCoordinates: output\n  });\n  return output;\n}\n\n// ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n  publicAPI.getBounds = () => {\n    const input = publicAPI.getInputData();\n    if (!input) {\n      model.bounds = createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n      model.bounds = input.getBounds();\n    }\n    return model.bounds;\n  };\n  publicAPI.setForceCompileOnly = v => {\n    model.forceCompileOnly = v;\n    // make sure we do NOT call modified()\n  };\n  publicAPI.setSelectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds => {\n    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;\n    // make sure we do NOT call modified()\n    // this attribute is only used when processing a selection made with the hardware selector\n    // the mtime of the mapper doesn't need to be changed\n  };\n  publicAPI.createDefaultLookupTable = () => {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode, model.colorMode);\n  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);\n  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);\n  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);\n  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode, model.scalarMode);\n  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);\n  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);\n  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);\n  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);\n  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);\n  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);\n  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return {\n        scalars: null,\n        cellFlag: false\n      };\n    }\n    let scalars = null;\n    let cellFlag = false;\n\n    // get and scalar data according to scalar mode\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      const pd = input.getPointData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      const cd = input.getCellData();\n      cellFlag = true;\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      const fd = input.getFieldData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n    return {\n      scalars,\n      cellFlag\n    };\n  };\n  publicAPI.mapScalars = (input, alpha) => {\n    const {\n      scalars,\n      cellFlag\n    } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    model.areScalarsMappedFromCells = cellFlag;\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    }\n\n    // we want to only recompute when something has changed\n    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n    if (model.colorBuildString === toString) return;\n    if (!model.useLookupTableScalarRange) {\n      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n    }\n\n    // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n    if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {\n      model.mapScalarsToTexture(scalars, cellFlag, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      const lut = publicAPI.getLookupTable();\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);\n      }\n    }\n    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n  };\n\n  // Protected method\n  model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {\n    const range = model.lookupTable.getRange();\n    const useLogScale = model.lookupTable.usingLogScale();\n    if (useLogScale) {\n      // convert range to log.\n      vtkLookupTable.getLogRange(range, range);\n    }\n    const origAlpha = model.lookupTable.getAlpha();\n\n    // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n    model.colorMapColors = null;\n\n    // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null;\n\n      // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n      model.lookupTable.build();\n      const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();\n\n      // Maximum dimensions and number of colors in range\n      const maxTextureWidthForCells = 2048;\n      const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3; // 3D but keep a color for min, max and NaN\n      const maxTextureWidthForPoints = 4096;\n      const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2; // 1D but keep a color for min and max (NaN is in a different row)\n      // Minimum number of colors in range (excluding special colors like minColor, maxColor and NaNColor)\n      const minColorsInRange = 2;\n      // Maximum number of colors, limited by the maximum possible texture size\n      const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;\n      model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);\n      const numberOfColorsForCells = model.numberOfColorsInRange + 3; // Add min, max and NaN\n      const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2; // Add min and max ; the lower row will be used for NaN color\n      const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];\n      const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];\n      const scalarsArray = new Float64Array(textureSize);\n\n      // Colors for NaN by default\n      scalarsArray.fill(NaN);\n\n      // Colors in range\n      // Add 2 to also get color for min and max\n      const numberOfNonSpecialColors = model.numberOfColorsInRange;\n      const numberOfNonNaNColors = numberOfNonSpecialColors + 2;\n      const textureCoordinates = [0, 0, 0];\n      const rangeMin = range[0];\n      const rangeDifference = range[1] - range[0];\n      for (let i = 0; i < numberOfNonNaNColors; ++i) {\n        const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);\n\n        // Minus 1 start at min color\n        const scalarValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);\n        scalarsArray[scalarsArrayIndex] = useLogScale ? 10.0 ** scalarValue : scalarValue;\n\n        // Colors are zigzagging to allow interpolation between two neighbor colors when coloring cells\n        updateZigzaggingCoordinates(textureCoordinates, textureDimensions);\n      }\n      const scalarsDataArray = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: scalarsArray\n      });\n      const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setDimensions(textureDimensions);\n      model.colorTextureMap.getPointData().setScalars(colorsDataArray);\n      model.lookupTable.setAlpha(origAlpha);\n    }\n\n    // Although I like the feature of applying magnitude to single component\n    // scalars, it is not how the old MapScalars for vertex coloring works.\n    const scalarComponent = model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();\n\n    // Create new coordinates if necessary, this function uses cache if possible.\n    // A zigzag pattern can't be used with point data, as interpolation of texture coordinates will be wrong\n    // A zigzag pattern can be used with cell data, as there will be no texture coordinates interpolation\n    // The texture generated using a zigzag pattern in one dimension is the same as without zigzag\n    // Therefore, the same code can be used for texture generation of point/cell data but not for texture coordinates\n    model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, range, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), useLogScale, cellFlag);\n  };\n  publicAPI.getIsOpaque = () => {\n    const input = publicAPI.getInputData();\n    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    const scalars = gasResult.scalars;\n    if (!model.scalarVisibility || scalars == null) {\n      // No scalar colors.\n      return true;\n    }\n    const lut = publicAPI.getLookupTable();\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.areScalarsOpaque(scalars, model.colorMode, -1);\n    }\n    return true;\n  };\n  publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {\n    if (cellFlag && !(model.colorMode === ColorMode.DIRECT_SCALARS)) {\n      return true; // cell data always use textures.\n    }\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    }\n\n    // index color does not use textures\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n    return true;\n  };\n  publicAPI.clearColorArrays = () => {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n  publicAPI.getLookupTable = () => {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n    return model.lookupTable;\n  };\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.lookupTable !== null) {\n      const time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getPrimitiveCount = () => {\n    const input = publicAPI.getInputData();\n    const pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),\n      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),\n      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()\n    };\n    return pcount;\n  };\n  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {\n    /* eslint-disable no-bitwise */\n    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {\n      return;\n    }\n    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    const currentPass = selector.getCurrentPass();\n    const fieldAssociation = selector.getFieldAssociation();\n    let idMap = null;\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n    if (!idMap) {\n      return;\n    }\n    pixelOffsets.forEach(pos => {\n      if (currentPass === PassTypes.ID_LOW24) {\n        let inValue = 0;\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        const outValue = idMap[inValue];\n        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        let inValue = 0;\n        inValue += rawHighData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        const outValue = idMap[inValue];\n        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  colorMapColors: null,\n  // Same as this->Colors\n  areScalarsMappedFromCells: false,\n  static: false,\n  lookupTable: null,\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1,\n  // By_NAME\n\n  renderTime: 0,\n  colorByArrayName: null,\n  fieldDataTupleId: -1,\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n  numberOfColorsInRange: 0,\n  forceCompileOnly: 0,\n  useInvertibleColors: false,\n  invertibleScalars: null,\n  customShaderAttributes: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['areScalarsMappedFromCells', 'colorCoordinates', 'colorMapColors', 'colorTextureMap', 'numberOfColorsInRange', 'selectionWebGLIdsToVTKIds']);\n  macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO\n  ]);\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\nexport { vtkMapper$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkAbstractMapper3D","vtkDataArray","vtkImageData","vtkLookupTable","F","createUninitializedBounds","i","isNan","vtkScalarsToColors","CoincidentTopologyHelper","Constants","vtkDataSet","PassTypes","FieldAssociations","staticOffsetAPI","otherStaticMethods","ColorMode","ScalarMode","GetArray","VectorMode","VtkDataTypes","notImplemented","method","vtkErrorMacro","updateZigzaggingCoordinates","coordinates","dimensions","directionX","directionY","getIndexFromCoordinates","getZigZagTextureCoordinatesFromTexelPosition","textureCoordinate","texelIndexPosition","intTexelIndex","Math","floor","xCoordBeforeWrap","xDirection","xEndFlag","intRowIndex","yCoordBeforeWrap","yDirection","yEndFlag","remainder","colorTextureCoordinatesCache","WeakMap","getOrCreateColorTextureCoordinates","input","component","range","numberOfColorsInRange","useLogScale","useZigzagPattern","argStrings","Array","arguments","length","argIndex","arg","getMTime","stringHash","join","cachedResult","get","textureCoordinates","scalarTexelWidth","paddedRangeMin","paddedRangeMax","textureSOrigin","textureSCoeff","texelIndexOrigin","texelIndexCoeff","inputV","getData","numScalars","getNumberOfTuples","numComps","getNumberOfComponents","useMagnitude","numberOfOutputComponents","output","newInstance","numberOfComponents","values","Float32Array","outputV","nanTextureCoordinate","inputIdx","outputIdx","scalarIdx","scalarValue","sum","compIdx","compValue","sqrt","applyLogScale","textureS","set","vtkMapper","publicAPI","model","classHierarchy","push","getBounds","getInputData","bounds","static","update","setForceCompileOnly","v","forceCompileOnly","setSelectionWebGLIdsToVTKIds","selectionWebGLIdsToVTKIds","createDefaultLookupTable","lookupTable","getColorModeAsString","enumToString","colorMode","setColorModeToDefault","setColorMode","setColorModeToMapScalars","setColorModeToDirectScalars","getScalarModeAsString","scalarMode","setScalarModeToDefault","setScalarMode","setScalarModeToUsePointData","setScalarModeToUseCellData","setScalarModeToUsePointFieldData","setScalarModeToUseCellFieldData","setScalarModeToUseFieldData","getAbstractScalars","arrayAccessMode","arrayId","arrayName","scalarVisibility","scalars","cellFlag","DEFAULT","getPointData","getScalars","getCellData","USE_POINT_DATA","USE_CELL_DATA","USE_POINT_FIELD_DATA","pd","BY_ID","getArrayByIndex","getArrayByName","USE_CELL_FIELD_DATA","cd","USE_FIELD_DATA","fd","getFieldData","mapScalars","alpha","colorByArrayName","areScalarsMappedFromCells","colorCoordinates","colorTextureMap","colorMapColors","toString","colorBuildString","useLookupTableScalarRange","getLookupTable","setRange","scalarRange","canUseTextureMapForColoring","mapScalarsToTexture","lut","build","fieldDataTupleId","getRange","usingLogScale","getLogRange","origAlpha","getAlpha","setAlpha","numberOfAvailableColors","getNumberOfAvailableColors","maxTextureWidthForCells","maxColorsInRangeForCells","maxTextureWidthForPoints","maxColorsInRangeForPoints","minColorsInRange","maxColorsInRange","min","max","numberOfColorsForCells","numberOfColorsInUpperRowForPoints","textureDimensions","ceil","textureSize","scalarsArray","Float64Array","fill","NaN","numberOfNonSpecialColors","numberOfNonNaNColors","rangeMin","rangeDifference","scalarsArrayIndex","scalarsDataArray","colorsDataArray","setDimensions","setScalars","scalarComponent","getVectorMode","MAGNITUDE","getVectorComponent","getDimensions","getIsOpaque","gasResult","areScalarsOpaque","DIRECT_SCALARS","interpolateScalarsBeforeMapping","getIndexedLookup","getDataType","UNSIGNED_CHAR","clearColorArrays","mt","mtime","time","getPrimitiveCount","pcount","points","getPoints","getNumberOfValues","verts","getVerts","getNumberOfCells","lines","getLines","triangles","getPolys","acquireInvertibleLookupTable","valueToColor","colorToValue","useInvertibleColorFor","clearInvertibleColor","processSelectorPixelBuffers","selector","pixelOffsets","populateSelectionSettings","rawLowData","getRawPixelBuffer","ID_LOW24","rawHighData","ID_HIGH24","currentPass","getCurrentPass","fieldAssociation","getFieldAssociation","idMap","FIELD_ASSOCIATION_POINTS","FIELD_ASSOCIATION_CELLS","cells","forEach","pos","inValue","outValue","lowData","getPixelBuffer","highData","DEFAULT_VALUES","renderTime","useInvertibleColors","invertibleScalars","customShaderAttributes","extend","initialValues","undefined","Object","assign","setGet","setGetArray","implementCoincidentTopologyMethods","vtkMapper$1","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkAbstractMapper3D from './AbstractMapper3D.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkImageData from '../../Common/DataModel/ImageData.js';\nimport vtkLookupTable from '../../Common/Core/LookupTable.js';\nimport { F as createUninitializedBounds, i as isNan } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors/Constants.js';\nimport CoincidentTopologyHelper from './Mapper/CoincidentTopologyHelper.js';\nimport Constants from './Mapper/Constants.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nimport { PassTypes } from '../OpenGL/HardwareSelector/Constants.js';\n\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  staticOffsetAPI,\n  otherStaticMethods\n} = CoincidentTopologyHelper;\nconst {\n  ColorMode,\n  ScalarMode,\n  GetArray\n} = Constants;\nconst {\n  VectorMode\n} = vtkScalarsToColors;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\n\n// ----------------------------------------------------------------------------\n\nfunction notImplemented(method) {\n  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);\n}\n\n/**\n * Increase by one the 3D coordinates\n * It will follow a zigzag pattern so that each coordinate is the neighbor of the next coordinate\n * This enables interpolation between two texels without issues\n * Note: texture coordinates can't be interpolated using this pattern\n * @param {vec3} coordinates The 3D coordinates using integers for each coorinate\n * @param {vec3} dimensions The 3D dimensions of the volume\n */\nfunction updateZigzaggingCoordinates(coordinates, dimensions) {\n  const directionX = coordinates[1] % 2 === 0 ? 1 : -1;\n  coordinates[0] += directionX;\n  if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {\n    const directionY = coordinates[2] % 2 === 0 ? 1 : -1;\n    coordinates[0] -= directionX;\n    coordinates[1] += directionY;\n    if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {\n      coordinates[1] -= directionY;\n      coordinates[2]++;\n    }\n  }\n}\n\n/**\n * Returns the index in the array representing the volume from a 3D coordinate\n * @param {vec3} coordinates The 3D integer coordinates\n * @param {vec3} dimensions The 3D dimensions of the volume\n * @returns The index in a flat array representing the volume\n */\nfunction getIndexFromCoordinates(coordinates, dimensions) {\n  return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);\n}\n\n/**\n * Write texture coordinates for the given `texelIndexPosition` in `textureCoordinate`.\n * The `texelIndexPosition` is a floating point number that represents the distance in index space\n * from the center of the first texel to the final output position.\n * The output is given in texture coordinates and not in index coordinates (this is done at the very end of the function)\n * @param {vec3} textureCoordinate The output texture coordinates (to avoid allocating a new Array)\n * @param {Number} texelIndexPosition The floating point distance from the center of the first texel, following a zigzag pattern\n * @param {vec3} dimensions The 3D dimensions of the volume\n */\nfunction getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {\n  // First compute the integer textureCoordinate\n  const intTexelIndex = Math.floor(texelIndexPosition);\n  const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);\n  let xDirection;\n  let xEndFlag;\n  if (xCoordBeforeWrap < dimensions[0]) {\n    textureCoordinate[0] = xCoordBeforeWrap;\n    xDirection = 1;\n    xEndFlag = textureCoordinate[0] === dimensions[0] - 1;\n  } else {\n    textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;\n    xDirection = -1;\n    xEndFlag = textureCoordinate[0] === 0;\n  }\n  const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);\n  const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);\n  let yDirection;\n  let yEndFlag;\n  if (yCoordBeforeWrap < dimensions[1]) {\n    textureCoordinate[1] = yCoordBeforeWrap;\n    yDirection = 1;\n    yEndFlag = textureCoordinate[1] === dimensions[1] - 1;\n  } else {\n    textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;\n    yDirection = -1;\n    yEndFlag = textureCoordinate[1] === 0;\n  }\n  textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);\n\n  // Now add the remainder either in x, y or z\n  const remainder = texelIndexPosition - intTexelIndex;\n  if (xEndFlag) {\n    if (yEndFlag) {\n      textureCoordinate[2] += remainder;\n    } else {\n      textureCoordinate[1] += yDirection * remainder;\n    }\n  } else {\n    textureCoordinate[0] += xDirection * remainder;\n  }\n\n  // textureCoordinates are in index space, convert to texture space\n  textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];\n  textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];\n  textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];\n}\n\n// Associate an input vtkDataArray to an object { stringHash, textureCoordinates }\n// A single dataArray only caches one array of texture coordinates, so this cache is useless when\n// the input data array is used with two different lookup tables (which is very unlikely)\nconst colorTextureCoordinatesCache = new WeakMap();\n/**\n * The minimum of the range is mapped to the center of the first texel excluding min texel (texel at index distance 1)\n * The maximum of the range is mapped to the center of the last texel excluding max and NaN texels (texel at index distance numberOfColorsInRange)\n * The result is cached, and is reused if the arguments are the same and the input doesn't change\n * @param {vtkDataArray} input The input data array used for coloring\n * @param {Number} component The component of the input data array that is used for coloring (-1 for magnitude of the vectors)\n * @param {Range} range The range of the scalars\n * @param {Number} numberOfColorsInRange The number of colors that are used in the range\n * @param {vec3} dimensions The dimensions of the texture\n * @param {boolean} useLogScale If log scale should be used to transform input scalars\n * @param {boolean} useZigzagPattern If a zigzag pattern should be used. Otherwise 1 row for colors (including min and max) and 1 row for NaN are used.\n * @returns A vtkDataArray containing the texture coordinates (2D or 3D)\n */\nfunction getOrCreateColorTextureCoordinates(input, component, range, numberOfColorsInRange, dimensions, useLogScale, useZigzagPattern) {\n  // Caching using the \"arguments\" special object (because it is a pure function)\n  const argStrings = new Array(arguments.length);\n  for (let argIndex = 0; argIndex < arguments.length; ++argIndex) {\n    // eslint-disable-next-line prefer-rest-params\n    const arg = arguments[argIndex];\n    argStrings[argIndex] = arg.getMTime?.() ?? arg;\n  }\n  const stringHash = argStrings.join('/');\n  const cachedResult = colorTextureCoordinatesCache.get(input);\n  if (cachedResult && cachedResult.stringHash === stringHash) {\n    return cachedResult.textureCoordinates;\n  }\n\n  // The range used for computing coordinates have to change\n  // slightly to accommodate the special above- and below-range\n  // colors that are the first and last texels, respectively.\n  const scalarTexelWidth = (range[1] - range[0]) / (numberOfColorsInRange - 1);\n  const [paddedRangeMin, paddedRangeMax] = [range[0] - scalarTexelWidth, range[1] + scalarTexelWidth];\n\n  // Use the center of the voxel\n  const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;\n  const textureSCoeff = 1.0 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);\n\n  // Compute in index space first\n  const texelIndexOrigin = paddedRangeMin;\n  const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);\n  const inputV = input.getData();\n  const numScalars = input.getNumberOfTuples();\n  const numComps = input.getNumberOfComponents();\n  const useMagnitude = component < 0 || component >= numComps;\n  const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;\n  const output = vtkDataArray.newInstance({\n    numberOfComponents: numberOfOutputComponents,\n    values: new Float32Array(numScalars * numberOfOutputComponents)\n  });\n  const outputV = output.getData();\n  const nanTextureCoordinate = [0, 0, 0];\n  // Distance of NaN from the beginning:\n  // min: 0, ...colorsInRange, max: numberOfColorsInRange + 1, NaN = numberOfColorsInRange + 2\n  getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);\n\n  // Set a texture coordinate in the output for each tuple in the input\n  let inputIdx = 0;\n  let outputIdx = 0;\n  const textureCoordinate = [0.5, 0.5, 0.5];\n  for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {\n    // Get scalar value from magnitude or a single component\n    let scalarValue;\n    if (useMagnitude) {\n      let sum = 0;\n      for (let compIdx = 0; compIdx < numComps; ++compIdx) {\n        const compValue = inputV[inputIdx + compIdx];\n        sum += compValue * compValue;\n      }\n      scalarValue = Math.sqrt(sum);\n    } else {\n      scalarValue = inputV[inputIdx + component];\n    }\n    inputIdx += numComps;\n\n    // Apply log scale if necessary\n    if (useLogScale) {\n      scalarValue = vtkLookupTable.applyLogScale(scalarValue, range, range);\n    }\n\n    // Convert to texture coordinates and update output\n    if (isNan(scalarValue)) {\n      // Last texels are NaN colors (there is at least one NaN color)\n      textureCoordinate[0] = nanTextureCoordinate[0];\n      textureCoordinate[1] = nanTextureCoordinate[1];\n      textureCoordinate[2] = nanTextureCoordinate[2];\n    } else if (useZigzagPattern) {\n      // Texel position is in [0, numberOfColorsInRange + 1]\n      let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;\n      if (texelIndexPosition < 1) {\n        // Use min color when smaller than range\n        texelIndexPosition = 0;\n      } else if (texelIndexPosition > numberOfColorsInRange) {\n        // Use max color when greater than range\n        texelIndexPosition = numberOfColorsInRange + 1;\n      }\n\n      // Convert the texel position into texture coordinate following a zigzag pattern\n      getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);\n    } else {\n      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?\n      // Because when you are mapping scalars and you have a NaN adjacent to\n      // anything else, the interpolation everywhere should be NaN.  Thus, I\n      // want the NaN color everywhere except right on the non-NaN neighbors.\n      // To simulate this, I set the t coord for the real numbers close to\n      // the threshold so that the interpolation almost immediately looks up\n      // the NaN value.\n      textureCoordinate[1] = 0.49;\n\n      // Some implementations apparently don't handle relatively large\n      // numbers (compared to the range [0.0, 1.0]) very well. In fact,\n      // values above 1122.0f appear to cause texture wrap-around on\n      // some systems even when edge clamping is enabled. Why 1122.0f? I\n      // don't know. For safety, we'll clamp at +/- 1000. This will\n      // result in incorrect images when the texture value should be\n      // above or below 1000, but I don't have a better solution.\n      const textureS = (scalarValue - textureSOrigin) * textureSCoeff;\n      if (textureS > 1000.0) {\n        textureCoordinate[0] = 1000.0;\n      } else if (textureS < -1000.0) {\n        textureCoordinate[0] = -1000.0;\n      } else {\n        textureCoordinate[0] = textureS;\n      }\n    }\n    for (let i = 0; i < numberOfOutputComponents; ++i) {\n      outputV[outputIdx++] = textureCoordinate[i];\n    }\n  }\n  colorTextureCoordinatesCache.set(input, {\n    stringHash,\n    textureCoordinates: output\n  });\n  return output;\n}\n\n// ----------------------------------------------------------------------------\n// vtkMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMapper');\n  publicAPI.getBounds = () => {\n    const input = publicAPI.getInputData();\n    if (!input) {\n      model.bounds = createUninitializedBounds();\n    } else {\n      if (!model.static) {\n        publicAPI.update();\n      }\n      model.bounds = input.getBounds();\n    }\n    return model.bounds;\n  };\n  publicAPI.setForceCompileOnly = v => {\n    model.forceCompileOnly = v;\n    // make sure we do NOT call modified()\n  };\n\n  publicAPI.setSelectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds => {\n    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;\n    // make sure we do NOT call modified()\n    // this attribute is only used when processing a selection made with the hardware selector\n    // the mtime of the mapper doesn't need to be changed\n  };\n\n  publicAPI.createDefaultLookupTable = () => {\n    model.lookupTable = vtkLookupTable.newInstance();\n  };\n  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode, model.colorMode);\n  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);\n  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);\n  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);\n  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode, model.scalarMode);\n  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);\n  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);\n  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);\n  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);\n  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);\n  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);\n  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {\n    // make sure we have an input\n    if (!input || !model.scalarVisibility) {\n      return {\n        scalars: null,\n        cellFlag: false\n      };\n    }\n    let scalars = null;\n    let cellFlag = false;\n\n    // get and scalar data according to scalar mode\n    if (scalarMode === ScalarMode.DEFAULT) {\n      scalars = input.getPointData().getScalars();\n      if (!scalars) {\n        scalars = input.getCellData().getScalars();\n        cellFlag = true;\n      }\n    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {\n      scalars = input.getPointData().getScalars();\n    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {\n      scalars = input.getCellData().getScalars();\n      cellFlag = true;\n    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {\n      const pd = input.getPointData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = pd.getArrayByIndex(arrayId);\n      } else {\n        scalars = pd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {\n      const cd = input.getCellData();\n      cellFlag = true;\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = cd.getArrayByIndex(arrayId);\n      } else {\n        scalars = cd.getArrayByName(arrayName);\n      }\n    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {\n      const fd = input.getFieldData();\n      if (arrayAccessMode === GetArray.BY_ID) {\n        scalars = fd.getArrayByIndex(arrayId);\n      } else {\n        scalars = fd.getArrayByName(arrayName);\n      }\n    }\n    return {\n      scalars,\n      cellFlag\n    };\n  };\n  publicAPI.mapScalars = (input, alpha) => {\n    const {\n      scalars,\n      cellFlag\n    } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    model.areScalarsMappedFromCells = cellFlag;\n    if (!scalars) {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      model.colorMapColors = null;\n      return;\n    }\n\n    // we want to only recompute when something has changed\n    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n    if (model.colorBuildString === toString) return;\n    if (!model.useLookupTableScalarRange) {\n      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);\n    }\n\n    // Decide between texture color or vertex color.\n    // Cell data always uses vertex color.\n    // Only point data can use both texture and vertex coloring.\n    if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {\n      model.mapScalarsToTexture(scalars, cellFlag, alpha);\n    } else {\n      model.colorCoordinates = null;\n      model.colorTextureMap = null;\n      const lut = publicAPI.getLookupTable();\n      if (lut) {\n        // Ensure that the lookup table is built\n        lut.build();\n        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);\n      }\n    }\n    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;\n  };\n\n  // Protected method\n  model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {\n    const range = model.lookupTable.getRange();\n    const useLogScale = model.lookupTable.usingLogScale();\n    if (useLogScale) {\n      // convert range to log.\n      vtkLookupTable.getLogRange(range, range);\n    }\n    const origAlpha = model.lookupTable.getAlpha();\n\n    // Get rid of vertex color array.  Only texture or vertex coloring\n    // can be active at one time.  The existence of the array is the\n    // signal to use that technique.\n    model.colorMapColors = null;\n\n    // If the lookup table has changed, then recreate the color texture map.\n    // Set a new lookup table changes this->MTime.\n    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {\n      model.lookupTable.setAlpha(alpha);\n      model.colorTextureMap = null;\n\n      // Get the texture map from the lookup table.\n      // Create a dummy ramp of scalars.\n      // In the future, we could extend vtkScalarsToColors.\n      model.lookupTable.build();\n      const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();\n\n      // Maximum dimensions and number of colors in range\n      const maxTextureWidthForCells = 2048;\n      const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3; // 3D but keep a color for min, max and NaN\n      const maxTextureWidthForPoints = 4096;\n      const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2; // 1D but keep a color for min and max (NaN is in a different row)\n      // Minimum number of colors in range (excluding special colors like minColor, maxColor and NaNColor)\n      const minColorsInRange = 2;\n      // Maximum number of colors, limited by the maximum possible texture size\n      const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;\n      model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);\n      const numberOfColorsForCells = model.numberOfColorsInRange + 3; // Add min, max and NaN\n      const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2; // Add min and max ; the lower row will be used for NaN color\n      const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];\n      const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];\n      const scalarsArray = new Float64Array(textureSize);\n\n      // Colors for NaN by default\n      scalarsArray.fill(NaN);\n\n      // Colors in range\n      // Add 2 to also get color for min and max\n      const numberOfNonSpecialColors = model.numberOfColorsInRange;\n      const numberOfNonNaNColors = numberOfNonSpecialColors + 2;\n      const textureCoordinates = [0, 0, 0];\n      const rangeMin = range[0];\n      const rangeDifference = range[1] - range[0];\n      for (let i = 0; i < numberOfNonNaNColors; ++i) {\n        const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);\n\n        // Minus 1 start at min color\n        const scalarValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);\n        scalarsArray[scalarsArrayIndex] = useLogScale ? 10.0 ** scalarValue : scalarValue;\n\n        // Colors are zigzagging to allow interpolation between two neighbor colors when coloring cells\n        updateZigzaggingCoordinates(textureCoordinates, textureDimensions);\n      }\n      const scalarsDataArray = vtkDataArray.newInstance({\n        numberOfComponents: 1,\n        values: scalarsArray\n      });\n      const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);\n      model.colorTextureMap = vtkImageData.newInstance();\n      model.colorTextureMap.setDimensions(textureDimensions);\n      model.colorTextureMap.getPointData().setScalars(colorsDataArray);\n      model.lookupTable.setAlpha(origAlpha);\n    }\n\n    // Although I like the feature of applying magnitude to single component\n    // scalars, it is not how the old MapScalars for vertex coloring works.\n    const scalarComponent = model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();\n\n    // Create new coordinates if necessary, this function uses cache if possible.\n    // A zigzag pattern can't be used with point data, as interpolation of texture coordinates will be wrong\n    // A zigzag pattern can be used with cell data, as there will be no texture coordinates interpolation\n    // The texture generated using a zigzag pattern in one dimension is the same as without zigzag\n    // Therefore, the same code can be used for texture generation of point/cell data but not for texture coordinates\n    model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, range, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), useLogScale, cellFlag);\n  };\n  publicAPI.getIsOpaque = () => {\n    const input = publicAPI.getInputData();\n    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);\n    const scalars = gasResult.scalars;\n    if (!model.scalarVisibility || scalars == null) {\n      // No scalar colors.\n      return true;\n    }\n    const lut = publicAPI.getLookupTable();\n    if (lut) {\n      // Ensure that the lookup table is built\n      lut.build();\n      return lut.areScalarsOpaque(scalars, model.colorMode, -1);\n    }\n    return true;\n  };\n  publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {\n    if (cellFlag && !(model.colorMode === ColorMode.DIRECT_SCALARS)) {\n      return true; // cell data always use textures.\n    }\n\n    if (!model.interpolateScalarsBeforeMapping) {\n      return false; // user doesn't want us to use texture maps at all.\n    }\n\n    // index color does not use textures\n    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {\n      return false;\n    }\n    if (!scalars) {\n      // no scalars on this dataset, we don't care if texture is used at all.\n      return false;\n    }\n    if (model.colorMode === ColorMode.DEFAULT && scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR || model.colorMode === ColorMode.DIRECT_SCALARS) {\n      // Don't use texture is direct coloring using RGB unsigned chars is\n      // requested.\n      return false;\n    }\n    return true;\n  };\n  publicAPI.clearColorArrays = () => {\n    model.colorMapColors = null;\n    model.colorCoordinates = null;\n    model.colorTextureMap = null;\n  };\n  publicAPI.getLookupTable = () => {\n    if (!model.lookupTable) {\n      publicAPI.createDefaultLookupTable();\n    }\n    return model.lookupTable;\n  };\n  publicAPI.getMTime = () => {\n    let mt = model.mtime;\n    if (model.lookupTable !== null) {\n      const time = model.lookupTable.getMTime();\n      mt = time > mt ? time : mt;\n    }\n    return mt;\n  };\n  publicAPI.getPrimitiveCount = () => {\n    const input = publicAPI.getInputData();\n    const pcount = {\n      points: input.getPoints().getNumberOfValues() / 3,\n      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),\n      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),\n      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()\n    };\n    return pcount;\n  };\n  publicAPI.acquireInvertibleLookupTable = notImplemented('AcquireInvertibleLookupTable');\n  publicAPI.valueToColor = notImplemented('ValueToColor');\n  publicAPI.colorToValue = notImplemented('ColorToValue');\n  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');\n  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');\n  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {\n    /* eslint-disable no-bitwise */\n    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {\n      return;\n    }\n    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);\n    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);\n    const currentPass = selector.getCurrentPass();\n    const fieldAssociation = selector.getFieldAssociation();\n    let idMap = null;\n    if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_POINTS) {\n      idMap = model.selectionWebGLIdsToVTKIds.points;\n    } else if (fieldAssociation === FieldAssociations.FIELD_ASSOCIATION_CELLS) {\n      idMap = model.selectionWebGLIdsToVTKIds.cells;\n    }\n    if (!idMap) {\n      return;\n    }\n    pixelOffsets.forEach(pos => {\n      if (currentPass === PassTypes.ID_LOW24) {\n        let inValue = 0;\n        if (rawHighData) {\n          inValue += rawHighData[pos];\n          inValue *= 256;\n        }\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        const outValue = idMap[inValue];\n        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);\n        lowData[pos] = outValue & 0xff;\n        lowData[pos + 1] = (outValue & 0xff00) >> 8;\n        lowData[pos + 2] = (outValue & 0xff0000) >> 16;\n      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {\n        let inValue = 0;\n        inValue += rawHighData[pos];\n        inValue *= 256;\n        inValue += rawLowData[pos + 2];\n        inValue *= 256;\n        inValue += rawLowData[pos + 1];\n        inValue *= 256;\n        inValue += rawLowData[pos];\n        const outValue = idMap[inValue];\n        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);\n        highData[pos] = (outValue & 0xff000000) >> 24;\n      }\n    });\n    /* eslint-enable no-bitwise */\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  colorMapColors: null,\n  // Same as this->Colors\n  areScalarsMappedFromCells: false,\n  static: false,\n  lookupTable: null,\n  scalarVisibility: true,\n  scalarRange: [0, 1],\n  useLookupTableScalarRange: false,\n  colorMode: 0,\n  scalarMode: 0,\n  arrayAccessMode: 1,\n  // By_NAME\n\n  renderTime: 0,\n  colorByArrayName: null,\n  fieldDataTupleId: -1,\n  populateSelectionSettings: true,\n  selectionWebGLIdsToVTKIds: null,\n  interpolateScalarsBeforeMapping: false,\n  colorCoordinates: null,\n  colorTextureMap: null,\n  numberOfColorsInRange: 0,\n  forceCompileOnly: 0,\n  useInvertibleColors: false,\n  invertibleScalars: null,\n  customShaderAttributes: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkAbstractMapper3D.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['areScalarsMappedFromCells', 'colorCoordinates', 'colorMapColors', 'colorTextureMap', 'numberOfColorsInRange', 'selectionWebGLIdsToVTKIds']);\n  macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO\n  ]);\n\n  macro.setGetArray(publicAPI, model, ['scalarRange'], 2);\n  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);\n\n  // Object methods\n  vtkMapper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMapper');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMapper$1 = {\n  newInstance,\n  extend,\n  ...staticOffsetAPI,\n  ...otherStaticMethods,\n  ...Constants\n};\n\nexport { vtkMapper$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}