{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { create } from 'xmlbuilder2';\nimport { zlibSync } from 'fflate';\nimport { m as macro } from '../../macros2.js';\nimport { fromArrayBuffer } from '../../Common/Core/Base64.js';\nimport { FormatTypes, TYPED_ARRAY } from './XMLWriter/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction compressBlock(uncompressed) {\n  return zlibSync(uncompressed);\n}\nfunction processDataArray(dataArray, format, blockSize) {\n  let compressor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'vtkZLibDataCompressor';\n  if (format === FormatTypes.ASCII) {\n    return dataArray.getData().join(' ');\n  }\n  if (format === FormatTypes.BINARY) {\n    if (compressor === 'vtkZLibDataCompressor') {\n      // ----------------------------------------------------------------------\n      // Layout of the data\n      // header[N, s1, s1, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n      // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n      // [header] s1: uncompress size of each block except the last one\n      // [header] s2: uncompress size of the last blocks\n      // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n      // ----------------------------------------------------------------------\n\n      const componentUint8Size = dataArray.getElementComponentSize();\n      const uncompressedUint8Size = dataArray.getNumberOfValues() * componentUint8Size;\n      const blockUint8Size = blockSize;\n      const nbFullBlocks = Math.trunc(uncompressedUint8Size / blockUint8Size);\n      const lastBlockUint8Size = uncompressedUint8Size % blockUint8Size;\n      const nbBlocks = nbFullBlocks + (lastBlockUint8Size ? 1 : 0);\n      const header = new Uint32Array(3 + nbBlocks);\n      header[0] = nbBlocks; // N\n      header[1] = blockUint8Size; // s1\n      header[2] = lastBlockUint8Size; // s2\n\n      let totalUint8Length = 0;\n      const blocks = [];\n      let dataOffset = 0;\n      const lastBlockId = nbBlocks - 1;\n      for (let blockId = 0; blockId < nbBlocks; ++blockId) {\n        const currentBlockUint8Size = lastBlockUint8Size === 0 || blockId < lastBlockId ? blockUint8Size : header[2];\n        const uncompressedBlock = new Uint8Array(dataArray.getData().buffer, dataOffset, currentBlockUint8Size);\n        dataOffset += blockUint8Size;\n        const compressedUint8Block = compressBlock(uncompressedBlock);\n        blocks.push(compressedUint8Block);\n        header[3 + blockId] = compressedUint8Block.length;\n        totalUint8Length += compressedUint8Block.length;\n      }\n      const uint8 = new Uint8Array(totalUint8Length);\n      let uint8Offset = 0;\n      const headerUint8 = new Uint8Array(header.buffer);\n      for (let blockId = 0; blockId < nbBlocks; ++blockId) {\n        uint8.set(blocks[blockId], uint8Offset);\n        uint8Offset += header[3 + blockId];\n      }\n      return fromArrayBuffer(headerUint8.buffer) + fromArrayBuffer(uint8.buffer);\n    }\n    throw new Error('Only vtkZLibDataCompressor is supported');\n  }\n  if (format === FormatTypes.APPENDED) {\n    throw new Error('Appended format is not supported');\n  }\n  throw new Error('Format is not supported');\n}\n\n// ----------------------------------------------------------------------------\n// vtkXMLWriter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkXMLWriter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLWriter');\n\n  // Can be overridden in subclass\n  publicAPI.create = dataObject => create().ele('VTKFile').att('type', model.dataType).att('version', '0.1').att('byte_order', 'LittleEndian').att('header_type', 'UInt32').att('compressor', model.format === FormatTypes.ASCII ? '' : 'vtkZLibDataCompressor');\n  publicAPI.write = object => publicAPI.create(object).end({\n    pretty: true\n  });\n  publicAPI.processDataSetAttributes = (parentElement, name, datasetAttributes) => {\n    const activeAttributes = {};\n    const attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];\n    attrTypes.forEach(attrType => {\n      const activeAttribute = datasetAttributes.getActiveAttribute(attrType);\n      if (activeAttribute) {\n        activeAttributes[attrType] = activeAttribute.getName();\n      }\n    });\n    const datasetAttributesEle = parentElement.ele(name, activeAttributes);\n    for (let i = 0; i < datasetAttributes.getNumberOfArrays(); ++i) {\n      publicAPI.processDataArray(datasetAttributesEle, datasetAttributes.getArrayByIndex(i));\n    }\n    return datasetAttributesEle;\n  };\n  publicAPI.processDataArray = (parentEle, scalars) => parentEle.ele('DataArray', {\n    type: TYPED_ARRAY[scalars.getDataType()],\n    Name: scalars.getName(),\n    format: publicAPI.getFormat(),\n    RangeMin: scalars.getRange()[0],\n    RangeMax: scalars.getRange()[1],\n    NumberOfComponents: scalars.getNumberOfComponents()\n  }).txt(processDataArray(scalars, publicAPI.getFormat(), publicAPI.getBlockSize()));\n  publicAPI.requestData = (inData, outData) => {\n    model.file = publicAPI.write(inData);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  blockSize: 1024,\n  // file: null,\n  format: FormatTypes.BINARY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['blockSize', 'format']);\n  macro.get(publicAPI, model, ['file']);\n  macro.algo(publicAPI, model, 1, 0);\n\n  // vtkXMLWriter methods\n  vtkXMLWriter(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nvar vtkXMLWriter$1 = {\n  extend,\n  compressBlock,\n  processDataArray,\n  FormatTypes\n};\nexport { vtkXMLWriter$1 as default, extend };","map":{"version":3,"names":["create","zlibSync","m","macro","fromArrayBuffer","FormatTypes","TYPED_ARRAY","compressBlock","uncompressed","processDataArray","dataArray","format","blockSize","compressor","arguments","length","undefined","ASCII","getData","join","BINARY","componentUint8Size","getElementComponentSize","uncompressedUint8Size","getNumberOfValues","blockUint8Size","nbFullBlocks","Math","trunc","lastBlockUint8Size","nbBlocks","header","Uint32Array","totalUint8Length","blocks","dataOffset","lastBlockId","blockId","currentBlockUint8Size","uncompressedBlock","Uint8Array","buffer","compressedUint8Block","push","uint8","uint8Offset","headerUint8","set","Error","APPENDED","vtkXMLWriter","publicAPI","model","classHierarchy","dataObject","ele","att","dataType","write","object","end","pretty","processDataSetAttributes","parentElement","name","datasetAttributes","activeAttributes","attrTypes","forEach","attrType","activeAttribute","getActiveAttribute","getName","datasetAttributesEle","i","getNumberOfArrays","getArrayByIndex","parentEle","scalars","type","getDataType","Name","getFormat","RangeMin","getRange","RangeMax","NumberOfComponents","getNumberOfComponents","txt","getBlockSize","requestData","inData","outData","file","DEFAULT_VALUES","extend","initialValues","Object","assign","obj","setGet","get","algo","vtkXMLWriter$1","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/node_modules/@kitware/vtk.js/IO/XML/XMLWriter.js"],"sourcesContent":["import { create } from 'xmlbuilder2';\nimport { zlibSync } from 'fflate';\nimport { m as macro } from '../../macros2.js';\nimport { fromArrayBuffer } from '../../Common/Core/Base64.js';\nimport { FormatTypes, TYPED_ARRAY } from './XMLWriter/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction compressBlock(uncompressed) {\n  return zlibSync(uncompressed);\n}\nfunction processDataArray(dataArray, format, blockSize) {\n  let compressor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'vtkZLibDataCompressor';\n  if (format === FormatTypes.ASCII) {\n    return dataArray.getData().join(' ');\n  }\n  if (format === FormatTypes.BINARY) {\n    if (compressor === 'vtkZLibDataCompressor') {\n      // ----------------------------------------------------------------------\n      // Layout of the data\n      // header[N, s1, s1, blockSize1, ..., blockSizeN], [padding???], block[compressedData], ..., block[compressedData]\n      // [header] N, s1 and s2 are uint 32 or 64 (defined by header_type=\"UInt64\" attribute on the root node)\n      // [header] s1: uncompress size of each block except the last one\n      // [header] s2: uncompress size of the last blocks\n      // [header] blockSize: size of the block in compressed space that represent to bloc to inflate in zlib. (This also give the offset to the next block)\n      // ----------------------------------------------------------------------\n\n      const componentUint8Size = dataArray.getElementComponentSize();\n      const uncompressedUint8Size = dataArray.getNumberOfValues() * componentUint8Size;\n      const blockUint8Size = blockSize;\n      const nbFullBlocks = Math.trunc(uncompressedUint8Size / blockUint8Size);\n      const lastBlockUint8Size = uncompressedUint8Size % blockUint8Size;\n      const nbBlocks = nbFullBlocks + (lastBlockUint8Size ? 1 : 0);\n      const header = new Uint32Array(3 + nbBlocks);\n      header[0] = nbBlocks; // N\n      header[1] = blockUint8Size; // s1\n      header[2] = lastBlockUint8Size; // s2\n\n      let totalUint8Length = 0;\n      const blocks = [];\n      let dataOffset = 0;\n      const lastBlockId = nbBlocks - 1;\n      for (let blockId = 0; blockId < nbBlocks; ++blockId) {\n        const currentBlockUint8Size = lastBlockUint8Size === 0 || blockId < lastBlockId ? blockUint8Size : header[2];\n        const uncompressedBlock = new Uint8Array(dataArray.getData().buffer, dataOffset, currentBlockUint8Size);\n        dataOffset += blockUint8Size;\n        const compressedUint8Block = compressBlock(uncompressedBlock);\n        blocks.push(compressedUint8Block);\n        header[3 + blockId] = compressedUint8Block.length;\n        totalUint8Length += compressedUint8Block.length;\n      }\n      const uint8 = new Uint8Array(totalUint8Length);\n      let uint8Offset = 0;\n      const headerUint8 = new Uint8Array(header.buffer);\n      for (let blockId = 0; blockId < nbBlocks; ++blockId) {\n        uint8.set(blocks[blockId], uint8Offset);\n        uint8Offset += header[3 + blockId];\n      }\n      return fromArrayBuffer(headerUint8.buffer) + fromArrayBuffer(uint8.buffer);\n    }\n    throw new Error('Only vtkZLibDataCompressor is supported');\n  }\n  if (format === FormatTypes.APPENDED) {\n    throw new Error('Appended format is not supported');\n  }\n  throw new Error('Format is not supported');\n}\n\n// ----------------------------------------------------------------------------\n// vtkXMLWriter methods\n// ----------------------------------------------------------------------------\n\nfunction vtkXMLWriter(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkXMLWriter');\n\n  // Can be overridden in subclass\n  publicAPI.create = dataObject => create().ele('VTKFile').att('type', model.dataType).att('version', '0.1').att('byte_order', 'LittleEndian').att('header_type', 'UInt32').att('compressor', model.format === FormatTypes.ASCII ? '' : 'vtkZLibDataCompressor');\n  publicAPI.write = object => publicAPI.create(object).end({\n    pretty: true\n  });\n  publicAPI.processDataSetAttributes = (parentElement, name, datasetAttributes) => {\n    const activeAttributes = {};\n    const attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];\n    attrTypes.forEach(attrType => {\n      const activeAttribute = datasetAttributes.getActiveAttribute(attrType);\n      if (activeAttribute) {\n        activeAttributes[attrType] = activeAttribute.getName();\n      }\n    });\n    const datasetAttributesEle = parentElement.ele(name, activeAttributes);\n    for (let i = 0; i < datasetAttributes.getNumberOfArrays(); ++i) {\n      publicAPI.processDataArray(datasetAttributesEle, datasetAttributes.getArrayByIndex(i));\n    }\n    return datasetAttributesEle;\n  };\n  publicAPI.processDataArray = (parentEle, scalars) => parentEle.ele('DataArray', {\n    type: TYPED_ARRAY[scalars.getDataType()],\n    Name: scalars.getName(),\n    format: publicAPI.getFormat(),\n    RangeMin: scalars.getRange()[0],\n    RangeMax: scalars.getRange()[1],\n    NumberOfComponents: scalars.getNumberOfComponents()\n  }).txt(processDataArray(scalars, publicAPI.getFormat(), publicAPI.getBlockSize()));\n  publicAPI.requestData = (inData, outData) => {\n    model.file = publicAPI.write(inData);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  blockSize: 1024,\n  // file: null,\n  format: FormatTypes.BINARY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['blockSize', 'format']);\n  macro.get(publicAPI, model, ['file']);\n  macro.algo(publicAPI, model, 1, 0);\n\n  // vtkXMLWriter methods\n  vtkXMLWriter(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nvar vtkXMLWriter$1 = {\n  extend,\n  compressBlock,\n  processDataArray,\n  FormatTypes\n};\n\nexport { vtkXMLWriter$1 as default, extend };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}