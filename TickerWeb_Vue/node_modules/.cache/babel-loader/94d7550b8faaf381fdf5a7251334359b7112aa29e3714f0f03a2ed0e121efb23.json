{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkAbstractPicker from './AbstractPicker.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport { d as dot, l as normalize, s as subtract, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport { vec3, mat4, vec4 } from 'gl-matrix';\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPicker');\n  const superClass = {\n    ...publicAPI\n  };\n  function initialize() {\n    superClass.initialize();\n    model.actors = [];\n    model.pickedPositions = [];\n    model.mapperPosition[0] = 0.0;\n    model.mapperPosition[1] = 0.0;\n    model.mapperPosition[2] = 0.0;\n    model.mapper = null;\n    model.dataSet = null;\n    model.globalTMin = Number.MAX_VALUE;\n  }\n\n  /**\n   * Compute the tolerance in world coordinates.\n   * Do this by determining the world coordinates of the diagonal points of the\n   * window, computing the width of the window in world coordinates, and\n   * multiplying by the tolerance.\n   * @param {Number} selectionZ\n   * @param {Number} aspect\n   * @param {vtkRenderer} renderer\n   * @returns {Number} the computed tolerance\n   */\n  function computeTolerance(selectionZ, aspect, renderer) {\n    let tolerance = 0.0;\n    const view = renderer.getRenderWindow().getViews()[0];\n    const viewport = renderer.getViewport();\n    const winSize = view.getSize();\n    let x = winSize[0] * viewport[0];\n    let y = winSize[1] * viewport[1];\n    const normalizedLeftDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);\n    const windowLowerLeft = renderer.normalizedDisplayToWorld(normalizedLeftDisplay[0], normalizedLeftDisplay[1], normalizedLeftDisplay[2], aspect);\n    x = winSize[0] * viewport[2];\n    y = winSize[1] * viewport[3];\n    const normalizedRightDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);\n    const windowUpperRight = renderer.normalizedDisplayToWorld(normalizedRightDisplay[0], normalizedRightDisplay[1], normalizedRightDisplay[2], aspect);\n    for (let i = 0; i < 3; i++) {\n      tolerance += (windowUpperRight[i] - windowLowerLeft[i]) * (windowUpperRight[i] - windowLowerLeft[i]);\n    }\n    return Math.sqrt(tolerance);\n  }\n\n  /**\n   * Perform picking on the given renderer, given a ray defined in world coordinates.\n   * @param {*} renderer\n   * @param {*} tolerance\n   * @param {*} p1World\n   * @param {*} p2World\n   * @returns true if we picked something else false\n   */\n  function pick3DInternal(renderer, tolerance, p1World, p2World) {\n    const p1Mapper = new Float64Array(4);\n    const p2Mapper = new Float64Array(4);\n    const ray = [];\n    const hitPosition = [];\n    const props = model.pickFromList ? model.pickList : renderer.getActors();\n\n    // pre-allocate some arrays.\n    const transformScale = new Float64Array(3);\n    const pickedPosition = new Float64Array(3);\n\n    // Loop over props.\n    // Transform ray (defined from position of camera to selection point) into coordinates of mapper (not\n    // transformed to actors coordinates!  Reduces overall computation!!!).\n    // Note that only vtkProp3D's can be picked by vtkPicker.\n    props.forEach(prop => {\n      const mapper = prop.getMapper();\n      const propIsFullyTranslucent = prop.getProperty?.().getOpacity?.() === 0.0;\n      const pickable = prop.getNestedPickable() && prop.getNestedVisibility() && !propIsFullyTranslucent;\n      if (!pickable) {\n        // prop cannot be picked\n        return;\n      }\n\n      // The prop is candidate for picking:\n      // - get its composite matrix and invert it\n      // - use the inverted matrix to transform the ray points into mapper coordinates\n      model.transformMatrix = prop.getMatrix().slice(0);\n      mat4.transpose(model.transformMatrix, model.transformMatrix);\n      mat4.invert(model.transformMatrix, model.transformMatrix);\n      vec4.transformMat4(p1Mapper, p1World, model.transformMatrix);\n      vec4.transformMat4(p2Mapper, p2World, model.transformMatrix);\n      vec3.scale(p1Mapper, p1Mapper, 1 / p1Mapper[3]);\n      vec3.scale(p2Mapper, p2Mapper, 1 / p2Mapper[3]);\n      subtract(p2Mapper, p1Mapper, ray);\n\n      // We now have the ray endpoints in mapper coordinates.\n      // Compare it with the mapper bounds to check if intersection is possible.\n\n      // Get the bounding box of the mapper.\n      // Note that the tolerance is added to the bounding box to make sure things on the edge of the\n      // bounding box are picked correctly.\n      const bounds = mapper ? vtkBoundingBox.inflate(mapper.getBounds(), tolerance) : [...vtkBoundingBox.INIT_BOUNDS];\n      if (vtkBoundingBox.intersectBox(bounds, p1Mapper, ray, hitPosition, [])) {\n        mat4.getScaling(transformScale, model.transformMatrix);\n        const t = model.intersectWithLine(p1Mapper, p2Mapper, tolerance * 0.333 * (transformScale[0] + transformScale[1] + transformScale[2]), prop, mapper);\n        if (t < Number.MAX_VALUE) {\n          pickedPosition[0] = (1.0 - t) * p1World[0] + t * p2World[0];\n          pickedPosition[1] = (1.0 - t) * p1World[1] + t * p2World[1];\n          pickedPosition[2] = (1.0 - t) * p1World[2] + t * p2World[2];\n          const actorIndex = model.actors.indexOf(prop);\n          if (actorIndex !== -1) {\n            // If already in list, compare the previous picked position with the new one.\n            // Store the new one if it is closer from the ray endpoint.\n            const previousPickedPosition = model.pickedPositions[actorIndex];\n            if (distance2BetweenPoints(p1World, pickedPosition) < distance2BetweenPoints(p1World, previousPickedPosition)) {\n              model.pickedPositions[actorIndex] = pickedPosition.slice(0);\n            }\n          } else {\n            model.actors.push(prop);\n            model.pickedPositions.push(pickedPosition.slice(0));\n          }\n        }\n      }\n    });\n\n    // sort array by distance\n    const tempArray = [];\n    for (let i = 0; i < model.pickedPositions.length; i++) {\n      tempArray.push({\n        actor: model.actors[i],\n        pickedPosition: model.pickedPositions[i],\n        distance2: distance2BetweenPoints(p1World, model.pickedPositions[i])\n      });\n    }\n    tempArray.sort((a, b) => {\n      const keyA = a.distance2;\n      const keyB = b.distance2;\n      // order the actors based on the distance2 attribute, so the near actors comes\n      // first in the list\n      if (keyA < keyB) return -1;\n      if (keyA > keyB) return 1;\n      return 0;\n    });\n    model.pickedPositions = [];\n    model.actors = [];\n    tempArray.forEach(obj => {\n      model.pickedPositions.push(obj.pickedPosition);\n      model.actors.push(obj.actor);\n    });\n  }\n\n  // Intersect data with specified ray.\n  // Project the center point of the mapper onto the ray and determine its parametric value\n  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {\n    if (!mapper) {\n      return Number.MAX_VALUE;\n    }\n    const center = mapper.getCenter();\n    const ray = vec3.subtract(new Float64Array(3), p2, p1);\n    const rayFactor = dot(ray, ray);\n    if (rayFactor === 0.0) {\n      return 2.0;\n    }\n\n    // Project the center point onto the ray and determine its parametric value\n    const t = (ray[0] * (center[0] - p1[0]) + ray[1] * (center[1] - p1[1]) + ray[2] * (center[2] - p1[2])) / rayFactor;\n    return t;\n  };\n\n  // To be overridden in subclasses\n  publicAPI.pick = (selection, renderer) => {\n    if (selection.length !== 3) {\n      vtkWarningMacro('vtkPicker.pick - selection needs three components');\n    }\n    if (!renderer) {\n      vtkErrorMacro('vtkPicker.pick - renderer cannot be null');\n      throw new Error('renderer cannot be null');\n    }\n    initialize();\n    const selectionX = selection[0];\n    const selectionY = selection[1];\n    let selectionZ = selection[2];\n    model.renderer = renderer;\n    model.selectionPoint[0] = selectionX;\n    model.selectionPoint[1] = selectionY;\n    model.selectionPoint[2] = selectionZ;\n    const p1World = new Float64Array(4);\n    const p2World = new Float64Array(4);\n\n    // Get camera focal point and position. Convert to display (screen)\n    // coordinates. We need a depth value for z-buffer.\n    const camera = renderer.getActiveCamera();\n    const cameraPos = camera.getPosition();\n    const cameraFP = camera.getFocalPoint();\n    const view = renderer.getRenderWindow().getViews()[0];\n    const dims = view.getViewportSize(renderer);\n    if (dims[1] === 0) {\n      vtkWarningMacro('vtkPicker.pick - viewport area is 0');\n      return;\n    }\n    const aspect = dims[0] / dims[1];\n    let displayCoords = [];\n    displayCoords = renderer.worldToNormalizedDisplay(cameraFP[0], cameraFP[1], cameraFP[2], aspect);\n    displayCoords = view.normalizedDisplayToDisplay(displayCoords[0], displayCoords[1], displayCoords[2]);\n    selectionZ = displayCoords[2];\n\n    // Convert the selection point into world coordinates.\n    const normalizedDisplay = view.displayToNormalizedDisplay(selectionX, selectionY, selectionZ);\n    const worldCoords = renderer.normalizedDisplayToWorld(normalizedDisplay[0], normalizedDisplay[1], normalizedDisplay[2], aspect);\n    for (let i = 0; i < 3; i++) {\n      model.pickPosition[i] = worldCoords[i];\n    }\n\n    //  Compute the ray endpoints. The ray is along the line running from\n    //  the camera position to the selection point, starting where this line\n    //  intersects the front clipping plane, and terminating where this\n    //  line intersects the back clipping plane.\n    const ray = [];\n    for (let i = 0; i < 3; i++) {\n      ray[i] = model.pickPosition[i] - cameraPos[i];\n    }\n    const cameraDOP = [];\n    for (let i = 0; i < 3; i++) {\n      cameraDOP[i] = cameraFP[i] - cameraPos[i];\n    }\n    normalize(cameraDOP);\n    const rayLength = dot(cameraDOP, ray);\n    if (rayLength === 0.0) {\n      vtkWarningMacro('Picker::Pick Cannot process points');\n      return;\n    }\n    const clipRange = camera.getClippingRange();\n    let tF;\n    let tB;\n    if (camera.getParallelProjection()) {\n      tF = clipRange[0] - rayLength;\n      tB = clipRange[1] - rayLength;\n      for (let i = 0; i < 3; i++) {\n        p1World[i] = model.pickPosition[i] + tF * cameraDOP[i];\n        p2World[i] = model.pickPosition[i] + tB * cameraDOP[i];\n      }\n    } else {\n      tF = clipRange[0] / rayLength;\n      tB = clipRange[1] / rayLength;\n      for (let i = 0; i < 3; i++) {\n        p1World[i] = cameraPos[i] + tF * ray[i];\n        p2World[i] = cameraPos[i] + tB * ray[i];\n      }\n    }\n    p1World[3] = 1.0;\n    p2World[3] = 1.0;\n    const tolerance = computeTolerance(selectionZ, aspect, renderer) * model.tolerance;\n    pick3DInternal(model.renderer, tolerance, p1World, p2World);\n  };\n  publicAPI.pick3DPoint = (selectionPoint, focalPoint, renderer) => {\n    if (!renderer) {\n      throw new Error('renderer cannot be null');\n    }\n    initialize();\n    model.renderer = renderer;\n    vec3.copy(model.selectionPoint, selectionPoint);\n    const view = renderer.getRenderWindow().getViews()[0];\n    const dims = view.getViewportSize(renderer);\n    if (dims[1] === 0) {\n      vtkWarningMacro('vtkPicker.pick3DPoint - viewport area is 0');\n      return;\n    }\n    const aspect = dims[0] / dims[1];\n    const tolerance = computeTolerance(model.selectionPoint[2], aspect, renderer) * model.tolerance;\n    pick3DInternal(renderer, tolerance, selectionPoint, focalPoint);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  tolerance: 0.025,\n  mapperPosition: [0.0, 0.0, 0.0],\n  mapper: null,\n  dataSet: null,\n  actors: [],\n  pickedPositions: [],\n  transformMatrix: null,\n  globalTMin: Number.MAX_VALUE\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkAbstractPicker.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['tolerance']);\n  macro.setGetArray(publicAPI, model, ['mapperPosition'], 3);\n  macro.get(publicAPI, model, ['mapper', 'dataSet', 'actors', 'pickedPositions']);\n  macro.event(publicAPI, model, 'pickChange');\n  vtkPicker(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPicker');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPicker$1 = {\n  newInstance,\n  extend\n};\nexport { vtkPicker$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkAbstractPicker","vtkBoundingBox","d","dot","l","normalize","s","subtract","e","distance2BetweenPoints","vec3","mat4","vec4","vtkErrorMacro","vtkWarningMacro","vtkPicker","publicAPI","model","classHierarchy","push","superClass","initialize","actors","pickedPositions","mapperPosition","mapper","dataSet","globalTMin","Number","MAX_VALUE","computeTolerance","selectionZ","aspect","renderer","tolerance","view","getRenderWindow","getViews","viewport","getViewport","winSize","getSize","x","y","normalizedLeftDisplay","displayToNormalizedDisplay","windowLowerLeft","normalizedDisplayToWorld","normalizedRightDisplay","windowUpperRight","i","Math","sqrt","pick3DInternal","p1World","p2World","p1Mapper","Float64Array","p2Mapper","ray","hitPosition","props","pickFromList","pickList","getActors","transformScale","pickedPosition","forEach","prop","getMapper","propIsFullyTranslucent","getProperty","getOpacity","pickable","getNestedPickable","getNestedVisibility","transformMatrix","getMatrix","slice","transpose","invert","transformMat4","scale","bounds","inflate","getBounds","INIT_BOUNDS","intersectBox","getScaling","t","intersectWithLine","actorIndex","indexOf","previousPickedPosition","tempArray","length","actor","distance2","sort","a","b","keyA","keyB","obj","p1","p2","center","getCenter","rayFactor","pick","selection","Error","selectionX","selectionY","selectionPoint","camera","getActiveCamera","cameraPos","getPosition","cameraFP","getFocalPoint","dims","getViewportSize","displayCoords","worldToNormalizedDisplay","normalizedDisplayToDisplay","normalizedDisplay","worldCoords","pickPosition","cameraDOP","rayLength","clipRange","getClippingRange","tF","tB","getParallelProjection","pick3DPoint","focalPoint","copy","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","setGet","setGetArray","get","event","newInstance","vtkPicker$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/Core/Picker.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkAbstractPicker from './AbstractPicker.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport { d as dot, l as normalize, s as subtract, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport { vec3, mat4, vec4 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPicker');\n  const superClass = {\n    ...publicAPI\n  };\n  function initialize() {\n    superClass.initialize();\n    model.actors = [];\n    model.pickedPositions = [];\n    model.mapperPosition[0] = 0.0;\n    model.mapperPosition[1] = 0.0;\n    model.mapperPosition[2] = 0.0;\n    model.mapper = null;\n    model.dataSet = null;\n    model.globalTMin = Number.MAX_VALUE;\n  }\n\n  /**\n   * Compute the tolerance in world coordinates.\n   * Do this by determining the world coordinates of the diagonal points of the\n   * window, computing the width of the window in world coordinates, and\n   * multiplying by the tolerance.\n   * @param {Number} selectionZ\n   * @param {Number} aspect\n   * @param {vtkRenderer} renderer\n   * @returns {Number} the computed tolerance\n   */\n  function computeTolerance(selectionZ, aspect, renderer) {\n    let tolerance = 0.0;\n    const view = renderer.getRenderWindow().getViews()[0];\n    const viewport = renderer.getViewport();\n    const winSize = view.getSize();\n    let x = winSize[0] * viewport[0];\n    let y = winSize[1] * viewport[1];\n    const normalizedLeftDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);\n    const windowLowerLeft = renderer.normalizedDisplayToWorld(normalizedLeftDisplay[0], normalizedLeftDisplay[1], normalizedLeftDisplay[2], aspect);\n    x = winSize[0] * viewport[2];\n    y = winSize[1] * viewport[3];\n    const normalizedRightDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);\n    const windowUpperRight = renderer.normalizedDisplayToWorld(normalizedRightDisplay[0], normalizedRightDisplay[1], normalizedRightDisplay[2], aspect);\n    for (let i = 0; i < 3; i++) {\n      tolerance += (windowUpperRight[i] - windowLowerLeft[i]) * (windowUpperRight[i] - windowLowerLeft[i]);\n    }\n    return Math.sqrt(tolerance);\n  }\n\n  /**\n   * Perform picking on the given renderer, given a ray defined in world coordinates.\n   * @param {*} renderer\n   * @param {*} tolerance\n   * @param {*} p1World\n   * @param {*} p2World\n   * @returns true if we picked something else false\n   */\n  function pick3DInternal(renderer, tolerance, p1World, p2World) {\n    const p1Mapper = new Float64Array(4);\n    const p2Mapper = new Float64Array(4);\n    const ray = [];\n    const hitPosition = [];\n    const props = model.pickFromList ? model.pickList : renderer.getActors();\n\n    // pre-allocate some arrays.\n    const transformScale = new Float64Array(3);\n    const pickedPosition = new Float64Array(3);\n\n    // Loop over props.\n    // Transform ray (defined from position of camera to selection point) into coordinates of mapper (not\n    // transformed to actors coordinates!  Reduces overall computation!!!).\n    // Note that only vtkProp3D's can be picked by vtkPicker.\n    props.forEach(prop => {\n      const mapper = prop.getMapper();\n      const propIsFullyTranslucent = prop.getProperty?.().getOpacity?.() === 0.0;\n      const pickable = prop.getNestedPickable() && prop.getNestedVisibility() && !propIsFullyTranslucent;\n      if (!pickable) {\n        // prop cannot be picked\n        return;\n      }\n\n      // The prop is candidate for picking:\n      // - get its composite matrix and invert it\n      // - use the inverted matrix to transform the ray points into mapper coordinates\n      model.transformMatrix = prop.getMatrix().slice(0);\n      mat4.transpose(model.transformMatrix, model.transformMatrix);\n      mat4.invert(model.transformMatrix, model.transformMatrix);\n      vec4.transformMat4(p1Mapper, p1World, model.transformMatrix);\n      vec4.transformMat4(p2Mapper, p2World, model.transformMatrix);\n      vec3.scale(p1Mapper, p1Mapper, 1 / p1Mapper[3]);\n      vec3.scale(p2Mapper, p2Mapper, 1 / p2Mapper[3]);\n      subtract(p2Mapper, p1Mapper, ray);\n\n      // We now have the ray endpoints in mapper coordinates.\n      // Compare it with the mapper bounds to check if intersection is possible.\n\n      // Get the bounding box of the mapper.\n      // Note that the tolerance is added to the bounding box to make sure things on the edge of the\n      // bounding box are picked correctly.\n      const bounds = mapper ? vtkBoundingBox.inflate(mapper.getBounds(), tolerance) : [...vtkBoundingBox.INIT_BOUNDS];\n      if (vtkBoundingBox.intersectBox(bounds, p1Mapper, ray, hitPosition, [])) {\n        mat4.getScaling(transformScale, model.transformMatrix);\n        const t = model.intersectWithLine(p1Mapper, p2Mapper, tolerance * 0.333 * (transformScale[0] + transformScale[1] + transformScale[2]), prop, mapper);\n        if (t < Number.MAX_VALUE) {\n          pickedPosition[0] = (1.0 - t) * p1World[0] + t * p2World[0];\n          pickedPosition[1] = (1.0 - t) * p1World[1] + t * p2World[1];\n          pickedPosition[2] = (1.0 - t) * p1World[2] + t * p2World[2];\n          const actorIndex = model.actors.indexOf(prop);\n          if (actorIndex !== -1) {\n            // If already in list, compare the previous picked position with the new one.\n            // Store the new one if it is closer from the ray endpoint.\n            const previousPickedPosition = model.pickedPositions[actorIndex];\n            if (distance2BetweenPoints(p1World, pickedPosition) < distance2BetweenPoints(p1World, previousPickedPosition)) {\n              model.pickedPositions[actorIndex] = pickedPosition.slice(0);\n            }\n          } else {\n            model.actors.push(prop);\n            model.pickedPositions.push(pickedPosition.slice(0));\n          }\n        }\n      }\n    });\n\n    // sort array by distance\n    const tempArray = [];\n    for (let i = 0; i < model.pickedPositions.length; i++) {\n      tempArray.push({\n        actor: model.actors[i],\n        pickedPosition: model.pickedPositions[i],\n        distance2: distance2BetweenPoints(p1World, model.pickedPositions[i])\n      });\n    }\n    tempArray.sort((a, b) => {\n      const keyA = a.distance2;\n      const keyB = b.distance2;\n      // order the actors based on the distance2 attribute, so the near actors comes\n      // first in the list\n      if (keyA < keyB) return -1;\n      if (keyA > keyB) return 1;\n      return 0;\n    });\n    model.pickedPositions = [];\n    model.actors = [];\n    tempArray.forEach(obj => {\n      model.pickedPositions.push(obj.pickedPosition);\n      model.actors.push(obj.actor);\n    });\n  }\n\n  // Intersect data with specified ray.\n  // Project the center point of the mapper onto the ray and determine its parametric value\n  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {\n    if (!mapper) {\n      return Number.MAX_VALUE;\n    }\n    const center = mapper.getCenter();\n    const ray = vec3.subtract(new Float64Array(3), p2, p1);\n    const rayFactor = dot(ray, ray);\n    if (rayFactor === 0.0) {\n      return 2.0;\n    }\n\n    // Project the center point onto the ray and determine its parametric value\n    const t = (ray[0] * (center[0] - p1[0]) + ray[1] * (center[1] - p1[1]) + ray[2] * (center[2] - p1[2])) / rayFactor;\n    return t;\n  };\n\n  // To be overridden in subclasses\n  publicAPI.pick = (selection, renderer) => {\n    if (selection.length !== 3) {\n      vtkWarningMacro('vtkPicker.pick - selection needs three components');\n    }\n    if (!renderer) {\n      vtkErrorMacro('vtkPicker.pick - renderer cannot be null');\n      throw new Error('renderer cannot be null');\n    }\n    initialize();\n    const selectionX = selection[0];\n    const selectionY = selection[1];\n    let selectionZ = selection[2];\n    model.renderer = renderer;\n    model.selectionPoint[0] = selectionX;\n    model.selectionPoint[1] = selectionY;\n    model.selectionPoint[2] = selectionZ;\n    const p1World = new Float64Array(4);\n    const p2World = new Float64Array(4);\n\n    // Get camera focal point and position. Convert to display (screen)\n    // coordinates. We need a depth value for z-buffer.\n    const camera = renderer.getActiveCamera();\n    const cameraPos = camera.getPosition();\n    const cameraFP = camera.getFocalPoint();\n    const view = renderer.getRenderWindow().getViews()[0];\n    const dims = view.getViewportSize(renderer);\n    if (dims[1] === 0) {\n      vtkWarningMacro('vtkPicker.pick - viewport area is 0');\n      return;\n    }\n    const aspect = dims[0] / dims[1];\n    let displayCoords = [];\n    displayCoords = renderer.worldToNormalizedDisplay(cameraFP[0], cameraFP[1], cameraFP[2], aspect);\n    displayCoords = view.normalizedDisplayToDisplay(displayCoords[0], displayCoords[1], displayCoords[2]);\n    selectionZ = displayCoords[2];\n\n    // Convert the selection point into world coordinates.\n    const normalizedDisplay = view.displayToNormalizedDisplay(selectionX, selectionY, selectionZ);\n    const worldCoords = renderer.normalizedDisplayToWorld(normalizedDisplay[0], normalizedDisplay[1], normalizedDisplay[2], aspect);\n    for (let i = 0; i < 3; i++) {\n      model.pickPosition[i] = worldCoords[i];\n    }\n\n    //  Compute the ray endpoints. The ray is along the line running from\n    //  the camera position to the selection point, starting where this line\n    //  intersects the front clipping plane, and terminating where this\n    //  line intersects the back clipping plane.\n    const ray = [];\n    for (let i = 0; i < 3; i++) {\n      ray[i] = model.pickPosition[i] - cameraPos[i];\n    }\n    const cameraDOP = [];\n    for (let i = 0; i < 3; i++) {\n      cameraDOP[i] = cameraFP[i] - cameraPos[i];\n    }\n    normalize(cameraDOP);\n    const rayLength = dot(cameraDOP, ray);\n    if (rayLength === 0.0) {\n      vtkWarningMacro('Picker::Pick Cannot process points');\n      return;\n    }\n    const clipRange = camera.getClippingRange();\n    let tF;\n    let tB;\n    if (camera.getParallelProjection()) {\n      tF = clipRange[0] - rayLength;\n      tB = clipRange[1] - rayLength;\n      for (let i = 0; i < 3; i++) {\n        p1World[i] = model.pickPosition[i] + tF * cameraDOP[i];\n        p2World[i] = model.pickPosition[i] + tB * cameraDOP[i];\n      }\n    } else {\n      tF = clipRange[0] / rayLength;\n      tB = clipRange[1] / rayLength;\n      for (let i = 0; i < 3; i++) {\n        p1World[i] = cameraPos[i] + tF * ray[i];\n        p2World[i] = cameraPos[i] + tB * ray[i];\n      }\n    }\n    p1World[3] = 1.0;\n    p2World[3] = 1.0;\n    const tolerance = computeTolerance(selectionZ, aspect, renderer) * model.tolerance;\n    pick3DInternal(model.renderer, tolerance, p1World, p2World);\n  };\n  publicAPI.pick3DPoint = (selectionPoint, focalPoint, renderer) => {\n    if (!renderer) {\n      throw new Error('renderer cannot be null');\n    }\n    initialize();\n    model.renderer = renderer;\n    vec3.copy(model.selectionPoint, selectionPoint);\n    const view = renderer.getRenderWindow().getViews()[0];\n    const dims = view.getViewportSize(renderer);\n    if (dims[1] === 0) {\n      vtkWarningMacro('vtkPicker.pick3DPoint - viewport area is 0');\n      return;\n    }\n    const aspect = dims[0] / dims[1];\n    const tolerance = computeTolerance(model.selectionPoint[2], aspect, renderer) * model.tolerance;\n    pick3DInternal(renderer, tolerance, selectionPoint, focalPoint);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  tolerance: 0.025,\n  mapperPosition: [0.0, 0.0, 0.0],\n  mapper: null,\n  dataSet: null,\n  actors: [],\n  pickedPositions: [],\n  transformMatrix: null,\n  globalTMin: Number.MAX_VALUE\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkAbstractPicker.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['tolerance']);\n  macro.setGetArray(publicAPI, model, ['mapperPosition'], 3);\n  macro.get(publicAPI, model, ['mapper', 'dataSet', 'actors', 'pickedPositions']);\n  macro.event(publicAPI, model, 'pickChange');\n  vtkPicker(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPicker');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPicker$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPicker$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}