{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport vtkLine from './Line.js';\nimport { vec3 } from 'gl-matrix';\nfunction vtkPolyLine(publicAPI, model) {\n  model.classHierarchy.push('vtkPolyLine');\n  const line = vtkLine.newInstance();\n  line.getPoints().setNumberOfPoints(2);\n  publicAPI.getCellDimension = () => 1;\n  publicAPI.intersectWithLine = (t1, t2, p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    const numLines = publicAPI.getNumberOfPoints() - 1;\n    let pDistMin = Number.MAX_VALUE;\n    for (let subId = 0; subId < numLines; subId++) {\n      const pCoords = [0, 0, 0];\n      line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));\n      const lineIntersected = line.intersectWithLine(p1, p2, tol, x, pcoords);\n      if (lineIntersected.intersect === 1 && lineIntersected.t <= outObj.t + tol && lineIntersected.t >= t1 && lineIntersected.t <= t2) {\n        outObj.intersect = 1;\n        const pDist = line.getParametricDistance(pCoords);\n        if (pDist < pDistMin || pDist === pDistMin && lineIntersected.t < outObj.t) {\n          outObj.subId = subId;\n          outObj.t = lineIntersected.t;\n          pDistMin = pDist;\n        }\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {\n    line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));\n    return line.evaluateLocation(pcoords, x, weights);\n  };\n  publicAPI.evaluateOrientation = (subId, pcoords, q, weights) => {\n    if (model.orientations) {\n      line.setOrientations([model.orientations[subId], model.orientations[subId + 1]]);\n    } else {\n      line.setOrientations(null);\n    }\n    return line.evaluateOrientation(pcoords, q, weights);\n  };\n  publicAPI.getDistancesToFirstPoint = () => {\n    const dTime = model.distancesTime.getMTime();\n    if (dTime < model.points.getMTime() || dTime < publicAPI.getMTime()) {\n      const numPoints = publicAPI.getNumberOfPoints();\n      if (!model.distances) {\n        model.distances = new Array(numPoints);\n      } else {\n        model.distances.length = numPoints;\n      }\n      if (numPoints > 0) {\n        const previousPoint = new Array(3);\n        const currentPoint = new Array(3);\n        let totalDistance = 0;\n        model.distances[0] = totalDistance;\n        model.points.getPoint(0, previousPoint);\n        for (let i = 1; i < numPoints; ++i) {\n          model.points.getPoint(i, currentPoint);\n          totalDistance += model.distanceFunction(previousPoint, currentPoint);\n          model.distances[i] = totalDistance;\n          vec3.copy(previousPoint, currentPoint);\n        }\n      }\n      model.distancesTime.modified();\n    }\n    return model.distances;\n  };\n  publicAPI.findPointIdAtDistanceFromFirstPoint = distance => {\n    const distances = publicAPI.getDistancesToFirstPoint();\n    // At least two points to return an ID\n    if (distances.length < 2) {\n      return -1;\n    }\n    // Binary search in the distance array\n    let minId = 0;\n    let maxId = distances.length - 1;\n    if (distance < distances[minId] || distance > distances[maxId] || distances[maxId] === 0) {\n      return -1;\n    }\n    while (maxId - minId > 1) {\n      const midId = Math.floor((minId + maxId) / 2);\n      if (distances[midId] <= distance) {\n        minId = midId;\n      } else {\n        maxId = midId;\n      }\n    }\n    return minId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orientations: null,\n  // an array of quat or null\n  distanceFunction: vec3.dist\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations', 'distanceFunction']);\n  model.distancesTime = {};\n  macro.obj(model.distancesTime, {\n    mtime: 0\n  });\n  vtkPolyLine(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolyLine');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyLine$1 = {\n  newInstance,\n  extend\n};\nexport { vtkPolyLine$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkCell","vtkLine","vec3","vtkPolyLine","publicAPI","model","classHierarchy","push","line","newInstance","getPoints","setNumberOfPoints","getCellDimension","intersectWithLine","t1","t2","p1","p2","tol","x","pcoords","outObj","intersect","t","Number","MAX_VALUE","subId","betweenPoints","numLines","getNumberOfPoints","pDistMin","pCoords","getData","set","points","subarray","lineIntersected","pDist","getParametricDistance","evaluateLocation","weights","evaluateOrientation","q","orientations","setOrientations","getDistancesToFirstPoint","dTime","distancesTime","getMTime","numPoints","distances","Array","length","previousPoint","currentPoint","totalDistance","getPoint","i","distanceFunction","copy","modified","findPointIdAtDistanceFromFirstPoint","distance","minId","maxId","midId","Math","floor","DEFAULT_VALUES","dist","extend","initialValues","arguments","undefined","Object","assign","setGet","obj","mtime","vtkPolyLine$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Common/DataModel/PolyLine.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport vtkLine from './Line.js';\nimport { vec3 } from 'gl-matrix';\n\nfunction vtkPolyLine(publicAPI, model) {\n  model.classHierarchy.push('vtkPolyLine');\n  const line = vtkLine.newInstance();\n  line.getPoints().setNumberOfPoints(2);\n  publicAPI.getCellDimension = () => 1;\n  publicAPI.intersectWithLine = (t1, t2, p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    const numLines = publicAPI.getNumberOfPoints() - 1;\n    let pDistMin = Number.MAX_VALUE;\n    for (let subId = 0; subId < numLines; subId++) {\n      const pCoords = [0, 0, 0];\n      line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));\n      const lineIntersected = line.intersectWithLine(p1, p2, tol, x, pcoords);\n      if (lineIntersected.intersect === 1 && lineIntersected.t <= outObj.t + tol && lineIntersected.t >= t1 && lineIntersected.t <= t2) {\n        outObj.intersect = 1;\n        const pDist = line.getParametricDistance(pCoords);\n        if (pDist < pDistMin || pDist === pDistMin && lineIntersected.t < outObj.t) {\n          outObj.subId = subId;\n          outObj.t = lineIntersected.t;\n          pDistMin = pDist;\n        }\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {\n    line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));\n    return line.evaluateLocation(pcoords, x, weights);\n  };\n  publicAPI.evaluateOrientation = (subId, pcoords, q, weights) => {\n    if (model.orientations) {\n      line.setOrientations([model.orientations[subId], model.orientations[subId + 1]]);\n    } else {\n      line.setOrientations(null);\n    }\n    return line.evaluateOrientation(pcoords, q, weights);\n  };\n  publicAPI.getDistancesToFirstPoint = () => {\n    const dTime = model.distancesTime.getMTime();\n    if (dTime < model.points.getMTime() || dTime < publicAPI.getMTime()) {\n      const numPoints = publicAPI.getNumberOfPoints();\n      if (!model.distances) {\n        model.distances = new Array(numPoints);\n      } else {\n        model.distances.length = numPoints;\n      }\n      if (numPoints > 0) {\n        const previousPoint = new Array(3);\n        const currentPoint = new Array(3);\n        let totalDistance = 0;\n        model.distances[0] = totalDistance;\n        model.points.getPoint(0, previousPoint);\n        for (let i = 1; i < numPoints; ++i) {\n          model.points.getPoint(i, currentPoint);\n          totalDistance += model.distanceFunction(previousPoint, currentPoint);\n          model.distances[i] = totalDistance;\n          vec3.copy(previousPoint, currentPoint);\n        }\n      }\n      model.distancesTime.modified();\n    }\n    return model.distances;\n  };\n  publicAPI.findPointIdAtDistanceFromFirstPoint = distance => {\n    const distances = publicAPI.getDistancesToFirstPoint();\n    // At least two points to return an ID\n    if (distances.length < 2) {\n      return -1;\n    }\n    // Binary search in the distance array\n    let minId = 0;\n    let maxId = distances.length - 1;\n    if (distance < distances[minId] || distance > distances[maxId] || distances[maxId] === 0) {\n      return -1;\n    }\n    while (maxId - minId > 1) {\n      const midId = Math.floor((minId + maxId) / 2);\n      if (distances[midId] <= distance) {\n        minId = midId;\n      } else {\n        maxId = midId;\n      }\n    }\n    return minId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orientations: null,\n  // an array of quat or null\n  distanceFunction: vec3.dist\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations', 'distanceFunction']);\n  model.distancesTime = {};\n  macro.obj(model.distancesTime, {\n    mtime: 0\n  });\n  vtkPolyLine(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolyLine');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyLine$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPolyLine$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}