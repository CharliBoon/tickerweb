{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport vtkActor from '../../Rendering/Core/Actor.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\nimport vtkInteractorStyleConstants from '../../Rendering/Core/InteractorStyle/Constants.js';\nimport vtkMapper from '../../Rendering/Core/Mapper.js';\nimport vtkPointPicker from '../../Rendering/Core/PointPicker.js';\nimport vtkSphereSource from '../../Filters/Sources/SphereSource.js';\nimport { FieldAssociations } from '../../Common/DataModel/DataSet/Constants.js';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport { B as areEquals, l as normalize, d as dot, C as clampValue, s as subtract, j as cross, w as multiplyScalar, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nconst {\n  States\n} = vtkInteractorStyleConstants;\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraUnicamRotateManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraUnicamRotateManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraUnicamRotateManipulator');\n\n  // Setup Picker to pick points\n  model.picker = vtkPointPicker.newInstance();\n  model.downPoint = [0, 0, 0];\n  model.isDot = false;\n  model.state = States.IS_NONE;\n\n  // Setup focus dot\n  const sphereSource = vtkSphereSource.newInstance();\n  sphereSource.setThetaResolution(6);\n  sphereSource.setPhiResolution(6);\n  const sphereMapper = vtkMapper.newInstance();\n  sphereMapper.setInputConnection(sphereSource.getOutputPort());\n  model.focusSphere = vtkActor.newInstance();\n  model.focusSphere.setMapper(sphereMapper);\n  model.focusSphere.getProperty().setColor(0.89, 0.66, 0.41);\n  model.focusSphere.getProperty().setAmbient(1);\n  model.focusSphere.getProperty().setDiffuse(0);\n  model.focusSphere.getProperty().setRepresentationToWireframe();\n\n  //----------------------------------------------------------------------------\n  const updateAndRender = interactor => {\n    if (!interactor) {\n      return;\n    }\n    if (model.useWorldUpVec) {\n      const camera = interactor.findPokedRenderer().getActiveCamera();\n      if (!areEquals(model.worldUpVec, camera.getViewPlaneNormal())) {\n        camera.setViewUp(model.worldUpVec);\n      }\n    }\n    interactor.render();\n  };\n\n  //----------------------------------------------------------------------------\n  const normalize$1 = (position, interactor) => {\n    const renderer = interactor.findPokedRenderer();\n    const [width, height] = interactor.getView().getViewportSize(renderer);\n    const nx = -1.0 + 2.0 * position.x / width;\n    const ny = -1.0 + 2.0 * position.y / height;\n    return {\n      x: nx,\n      y: ny\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  // Rotate the camera by 'angle' degrees about the point <cx, cy, cz>\n  // and around the vector/axis <ax, ay, az>.\n  const rotateCamera = (camera, cx, cy, cz, ax, ay, az, angle) => {\n    const cameraPosition = camera.getPosition();\n    const cameraFocalPoint = camera.getFocalPoint();\n    const cameraViewUp = camera.getViewUp();\n    cameraPosition[3] = 1.0;\n    cameraFocalPoint[3] = 1.0;\n    cameraViewUp[3] = 0.0;\n    const transform = mat4.identity(new Float64Array(16));\n    mat4.translate(transform, transform, [cx, cy, cz]);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\n    const newCameraPosition = [];\n    const newCameraFocalPoint = [];\n    vec3.transformMat4(newCameraPosition, cameraPosition, transform);\n    vec3.transformMat4(newCameraFocalPoint, cameraFocalPoint, transform);\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    const newCameraViewUp = [];\n    vec3.transformMat4(newCameraViewUp, cameraViewUp, transform);\n    camera.setPosition(...newCameraPosition);\n    camera.setFocalPoint(...newCameraFocalPoint);\n    camera.setViewUp(...newCameraViewUp);\n  };\n\n  //----------------------------------------------------------------------------\n  const rotate = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    const normalizedPosition = normalize$1(position, interactor);\n    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);\n    const center = model.focusSphere.getPosition();\n    let normalizedCenter = interactor.getView().worldToDisplay(...center, renderer);\n    // let normalizedCenter = publicAPI.computeWorldToDisplay(renderer, ...center);\n    normalizedCenter = normalize$1({\n      x: center[0],\n      y: center[1]\n    }, interactor);\n    normalizedCenter = [normalizedCenter.x, normalizedCenter.y, center[2]];\n\n    // Squared rad of virtual cylinder\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n    const op = [normalizedPreviousPosition.x, 0, 0];\n    const oe = [normalizedPosition.x, 0, 0];\n    const opsq = op[0] ** 2;\n    const oesq = oe[0] ** 2;\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n    const nop = [op[0], 0, lop];\n    normalize(nop);\n    const noe = [oe[0], 0, loe];\n    normalize(noe);\n    const dot$1 = dot(nop, noe);\n    if (Math.abs(dot$1) > 0.0001) {\n      const angle = -2 * Math.acos(clampValue(dot$1, -1.0, 1.0)) * Math.sign(normalizedPosition.x - normalizedPreviousPosition.x) * publicAPI.getRotationFactor();\n      const camera = renderer.getActiveCamera();\n      const upVec = model.useWorldUpVec ? model.worldUpVec : camera.getViewUp();\n      normalize(upVec);\n      rotateCamera(camera, ...center, ...upVec, angle);\n      const dVec = [];\n      const cameraPosition = camera.getPosition();\n      subtract(cameraPosition, position, dVec);\n      let rDist = (normalizedPosition.y - normalizedPreviousPosition.y) * publicAPI.getRotationFactor();\n      normalize(dVec);\n      const atV = camera.getViewPlaneNormal();\n      const upV = camera.getViewUp();\n      const rightV = [];\n      cross(upV, atV, rightV);\n      normalize(rightV);\n\n      //\n      // The following two tests try to prevent chaotic camera movement\n      // that results from rotating over the poles defined by the\n      // \"WorldUpVector\".  The problem is the constraint to keep the\n      // camera's up vector in line w/ the WorldUpVector is at odds with\n      // the action of rotating over the top of the virtual sphere used\n      // for rotation.  The solution here is to prevent the user from\n      // rotating the last bit required to \"go over the top\"-- as a\n      // consequence, you can never look directly down on the poles.\n      //\n      // The \"0.99\" value is somewhat arbitrary, but seems to produce\n      // reasonable results.  (Theoretically, some sort of clamping\n      // function could probably be used rather than a hard cutoff, but\n      // time constraints prevent figuring that out right now.)\n      //\n      if (model.useWorldUpVec) {\n        const OVER_THE_TOP_THRESHOLD = 0.99;\n        if (dot(upVec, atV) > OVER_THE_TOP_THRESHOLD && rDist < 0) {\n          rDist = 0;\n        }\n        if (dot(upVec, atV) < -OVER_THE_TOP_THRESHOLD && rDist > 0) {\n          rDist = 0;\n        }\n      }\n      rotateCamera(camera, ...center, ...rightV, rDist);\n      if (model.useWorldUpVec && !areEquals(upVec, camera.getViewPlaneNormal())) {\n        camera.setViewUp(...upVec);\n      }\n      model.previousPosition = position;\n      renderer.resetCameraClippingRange();\n      updateAndRender(interactor);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  const placeFocusSphere = interactor => {\n    const renderer = interactor.findPokedRenderer();\n    model.focusSphere.setPosition(...model.downPoint);\n    const camera = renderer.getActiveCamera();\n    const cameraPosition = camera.getPosition();\n    const cameraToPointVec = [];\n    subtract(model.downPoint, cameraPosition, cameraToPointVec);\n    if (camera.getParallelProjection()) {\n      multiplyScalar(cameraToPointVec, camera.getParallelScale());\n    }\n    const atV = camera.getDirectionOfProjection();\n    normalize(atV);\n\n    // Scales the focus dot so it always appears the same size\n    const scale = 0.02 * dot(atV, cameraToPointVec) * model.focusSphereRadiusFactor;\n    model.focusSphere.setScale(scale, scale, scale);\n  };\n  const placeAndDisplayFocusSphere = interactor => {\n    placeFocusSphere(interactor);\n    interactor.findPokedRenderer().addActor(model.focusSphere);\n    model.isDot = true;\n  };\n  const hideFocusSphere = interactor => {\n    interactor.findPokedRenderer().removeActor(model.focusSphere);\n    model.isDot = false;\n  };\n\n  //----------------------------------------------------------------------------\n  const pickWithPointPicker = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    model.picker.pick([position.x, position.y, position.z], renderer);\n    const pickedPositions = model.picker.getPickedPositions();\n    if (pickedPositions.length === 0) {\n      return model.picker.getPickPosition();\n    }\n    const cameraPosition = renderer.getActiveCamera().getPosition();\n    pickedPositions.sort((pointA, pointB) => distance2BetweenPoints(pointA, cameraPosition) - distance2BetweenPoints(pointB, cameraPosition));\n    return pickedPositions[0];\n  };\n\n  //----------------------------------------------------------------------------\n  const pickPoint = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    // Finds the point under the cursor.\n    // Note: If no object has been rendered to the pixel (X, Y), then\n    // vtkPicker will return a z-value with depth equal\n    // to the distance from the camera's position to the focal point.\n    // This seems like an arbitrary, but perhaps reasonable, default value.\n    let selections = null;\n    if (model.useHardwareSelector) {\n      const selector = interactor.getView().getSelector();\n      selector.setCaptureZValues(true);\n      selector.setFieldAssociation(FieldAssociations.FIELD_ASSOCIATION_POINTS);\n      selector.attach(interactor.getView(), renderer);\n      selector.setArea(position.x, position.y, position.x, position.y);\n      selections = selector.select();\n    }\n    if (selections && selections.length !== 0) {\n      // convert Float64Array to regular array\n      return Array.from(selections[0].getProperties().worldPosition);\n    }\n    return pickWithPointPicker(interactor, position);\n  };\n\n  //----------------------------------------------------------------------------\n  // Public API methods\n  //----------------------------------------------------------------------------\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.buttonPressed = true;\n    model.startPosition = position;\n    model.previousPosition = position;\n    const normalizedPosition = normalize$1(position, interactor);\n    // borderRatio defines the percentage of the screen size that is considered to be\n    // the border of the screen on each side\n    const borderRatio = 0.1;\n    // If the user is clicking on the perimeter of the screen,\n    // then we want to go into rotation mode, and there is no need to determine the downPoint\n    if (Math.abs(normalizedPosition.x) > 1 - borderRatio || Math.abs(normalizedPosition.y) > 1 - borderRatio) {\n      model.state = States.IS_ROTATE;\n      placeAndDisplayFocusSphere(interactor);\n      return;\n    }\n    model.downPoint = pickPoint(interactor, position);\n    if (model.isDot) {\n      model.state = States.IS_ROTATE;\n    } else {\n      model.state = States.IS_NONE;\n      if (model.displayFocusSphereOnButtonDown) {\n        placeAndDisplayFocusSphere(interactor);\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!model.buttonPressed) {\n      return;\n    }\n    model.state = States.IS_ROTATE;\n    rotate(interactor, position);\n    model.previousPosition = position;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.onButtonUp = interactor => {\n    const renderer = interactor.findPokedRenderer();\n    model.buttonPressed = false;\n\n    // If rotation without a focus sphere, nothing to do\n    if (model.state === States.IS_ROTATE && !model.isDot) {\n      return;\n    }\n    if (model.state === States.IS_ROTATE) {\n      hideFocusSphere(interactor);\n    } else if (model.state === States.IS_NONE) {\n      placeAndDisplayFocusSphere(interactor);\n    }\n    renderer.resetCameraClippingRange();\n    updateAndRender(interactor);\n  };\n  publicAPI.getFocusSphereColor = () => {\n    model.focusSphere.getProperty().getColor();\n  };\n  publicAPI.setFocusSphereColor = (r, g, b) => {\n    model.focusSphere.getProperty().setColor(r, g, b);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  focusSphereRadiusFactor: 1,\n  displayFocusSphereOnButtonDown: true,\n  useHardwareSelector: true,\n  useWorldUpVec: true,\n  // set WorldUpVector to be z-axis by default\n  worldUpVec: [0, 0, 1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['focusSphereRadiusFactor', 'displayFocusSphereOnButtonDown', 'useHardwareSelector', 'useWorldUpVec']);\n  macro.get(publicAPI, model, ['state']);\n  macro.getArray(publicAPI, model, ['downPoint'], 3);\n  macro.setGetArray(publicAPI, model, ['worldUpVec'], 3);\n\n  // Object specific methods\n  vtkMouseCameraUnicamRotateManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraUnicamRotateManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraUnicamRotateManipulator$1 = {\n  newInstance,\n  extend\n};\nexport { vtkMouseCameraUnicamRotateManipulator$1 as default, extend, newInstance };","map":{"version":3,"names":["vtkActor","vtkCompositeCameraManipulator","vtkCompositeMouseManipulator","vtkInteractorStyleConstants","vtkMapper","vtkPointPicker","vtkSphereSource","FieldAssociations","mat4","vec3","m","macro","B","areEquals","l","normalize","d","dot","C","clampValue","s","subtract","j","cross","w","multiplyScalar","e","distance2BetweenPoints","States","vtkMouseCameraUnicamRotateManipulator","publicAPI","model","classHierarchy","push","picker","newInstance","downPoint","isDot","state","IS_NONE","sphereSource","setThetaResolution","setPhiResolution","sphereMapper","setInputConnection","getOutputPort","focusSphere","setMapper","getProperty","setColor","setAmbient","setDiffuse","setRepresentationToWireframe","updateAndRender","interactor","useWorldUpVec","camera","findPokedRenderer","getActiveCamera","worldUpVec","getViewPlaneNormal","setViewUp","render","normalize$1","position","renderer","width","height","getView","getViewportSize","nx","x","ny","y","rotateCamera","cx","cy","cz","ax","ay","az","angle","cameraPosition","getPosition","cameraFocalPoint","getFocalPoint","cameraViewUp","getViewUp","transform","identity","Float64Array","translate","rotate","newCameraPosition","newCameraFocalPoint","transformMat4","newCameraViewUp","setPosition","setFocalPoint","normalizedPosition","normalizedPreviousPosition","previousPosition","center","normalizedCenter","worldToDisplay","radsq","Math","abs","op","oe","opsq","oesq","lop","sqrt","loe","nop","noe","dot$1","acos","sign","getRotationFactor","upVec","dVec","rDist","atV","upV","rightV","OVER_THE_TOP_THRESHOLD","resetCameraClippingRange","placeFocusSphere","cameraToPointVec","getParallelProjection","getParallelScale","getDirectionOfProjection","scale","focusSphereRadiusFactor","setScale","placeAndDisplayFocusSphere","addActor","hideFocusSphere","removeActor","pickWithPointPicker","pick","z","pickedPositions","getPickedPositions","length","getPickPosition","sort","pointA","pointB","pickPoint","selections","useHardwareSelector","selector","getSelector","setCaptureZValues","setFieldAssociation","FIELD_ASSOCIATION_POINTS","attach","setArea","select","Array","from","getProperties","worldPosition","onButtonDown","buttonPressed","startPosition","borderRatio","IS_ROTATE","displayFocusSphereOnButtonDown","onMouseMove","onButtonUp","getFocusSphereColor","getColor","setFocusSphereColor","r","g","b","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","obj","setGet","get","getArray","setGetArray","vtkMouseCameraUnicamRotateManipulator$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraUnicamRotateManipulator.js"],"sourcesContent":["import vtkActor from '../../Rendering/Core/Actor.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\nimport vtkInteractorStyleConstants from '../../Rendering/Core/InteractorStyle/Constants.js';\nimport vtkMapper from '../../Rendering/Core/Mapper.js';\nimport vtkPointPicker from '../../Rendering/Core/PointPicker.js';\nimport vtkSphereSource from '../../Filters/Sources/SphereSource.js';\nimport { FieldAssociations } from '../../Common/DataModel/DataSet/Constants.js';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport { B as areEquals, l as normalize, d as dot, C as clampValue, s as subtract, j as cross, w as multiplyScalar, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\n\nconst {\n  States\n} = vtkInteractorStyleConstants;\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraUnicamRotateManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraUnicamRotateManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraUnicamRotateManipulator');\n\n  // Setup Picker to pick points\n  model.picker = vtkPointPicker.newInstance();\n  model.downPoint = [0, 0, 0];\n  model.isDot = false;\n  model.state = States.IS_NONE;\n\n  // Setup focus dot\n  const sphereSource = vtkSphereSource.newInstance();\n  sphereSource.setThetaResolution(6);\n  sphereSource.setPhiResolution(6);\n  const sphereMapper = vtkMapper.newInstance();\n  sphereMapper.setInputConnection(sphereSource.getOutputPort());\n  model.focusSphere = vtkActor.newInstance();\n  model.focusSphere.setMapper(sphereMapper);\n  model.focusSphere.getProperty().setColor(0.89, 0.66, 0.41);\n  model.focusSphere.getProperty().setAmbient(1);\n  model.focusSphere.getProperty().setDiffuse(0);\n  model.focusSphere.getProperty().setRepresentationToWireframe();\n\n  //----------------------------------------------------------------------------\n  const updateAndRender = interactor => {\n    if (!interactor) {\n      return;\n    }\n    if (model.useWorldUpVec) {\n      const camera = interactor.findPokedRenderer().getActiveCamera();\n      if (!areEquals(model.worldUpVec, camera.getViewPlaneNormal())) {\n        camera.setViewUp(model.worldUpVec);\n      }\n    }\n    interactor.render();\n  };\n\n  //----------------------------------------------------------------------------\n  const normalize$1 = (position, interactor) => {\n    const renderer = interactor.findPokedRenderer();\n    const [width, height] = interactor.getView().getViewportSize(renderer);\n    const nx = -1.0 + 2.0 * position.x / width;\n    const ny = -1.0 + 2.0 * position.y / height;\n    return {\n      x: nx,\n      y: ny\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  // Rotate the camera by 'angle' degrees about the point <cx, cy, cz>\n  // and around the vector/axis <ax, ay, az>.\n  const rotateCamera = (camera, cx, cy, cz, ax, ay, az, angle) => {\n    const cameraPosition = camera.getPosition();\n    const cameraFocalPoint = camera.getFocalPoint();\n    const cameraViewUp = camera.getViewUp();\n    cameraPosition[3] = 1.0;\n    cameraFocalPoint[3] = 1.0;\n    cameraViewUp[3] = 0.0;\n    const transform = mat4.identity(new Float64Array(16));\n    mat4.translate(transform, transform, [cx, cy, cz]);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\n    const newCameraPosition = [];\n    const newCameraFocalPoint = [];\n    vec3.transformMat4(newCameraPosition, cameraPosition, transform);\n    vec3.transformMat4(newCameraFocalPoint, cameraFocalPoint, transform);\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    const newCameraViewUp = [];\n    vec3.transformMat4(newCameraViewUp, cameraViewUp, transform);\n    camera.setPosition(...newCameraPosition);\n    camera.setFocalPoint(...newCameraFocalPoint);\n    camera.setViewUp(...newCameraViewUp);\n  };\n\n  //----------------------------------------------------------------------------\n  const rotate = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    const normalizedPosition = normalize$1(position, interactor);\n    const normalizedPreviousPosition = normalize$1(model.previousPosition, interactor);\n    const center = model.focusSphere.getPosition();\n    let normalizedCenter = interactor.getView().worldToDisplay(...center, renderer);\n    // let normalizedCenter = publicAPI.computeWorldToDisplay(renderer, ...center);\n    normalizedCenter = normalize$1({\n      x: center[0],\n      y: center[1]\n    }, interactor);\n    normalizedCenter = [normalizedCenter.x, normalizedCenter.y, center[2]];\n\n    // Squared rad of virtual cylinder\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n    const op = [normalizedPreviousPosition.x, 0, 0];\n    const oe = [normalizedPosition.x, 0, 0];\n    const opsq = op[0] ** 2;\n    const oesq = oe[0] ** 2;\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n    const nop = [op[0], 0, lop];\n    normalize(nop);\n    const noe = [oe[0], 0, loe];\n    normalize(noe);\n    const dot$1 = dot(nop, noe);\n    if (Math.abs(dot$1) > 0.0001) {\n      const angle = -2 * Math.acos(clampValue(dot$1, -1.0, 1.0)) * Math.sign(normalizedPosition.x - normalizedPreviousPosition.x) * publicAPI.getRotationFactor();\n      const camera = renderer.getActiveCamera();\n      const upVec = model.useWorldUpVec ? model.worldUpVec : camera.getViewUp();\n      normalize(upVec);\n      rotateCamera(camera, ...center, ...upVec, angle);\n      const dVec = [];\n      const cameraPosition = camera.getPosition();\n      subtract(cameraPosition, position, dVec);\n      let rDist = (normalizedPosition.y - normalizedPreviousPosition.y) * publicAPI.getRotationFactor();\n      normalize(dVec);\n      const atV = camera.getViewPlaneNormal();\n      const upV = camera.getViewUp();\n      const rightV = [];\n      cross(upV, atV, rightV);\n      normalize(rightV);\n\n      //\n      // The following two tests try to prevent chaotic camera movement\n      // that results from rotating over the poles defined by the\n      // \"WorldUpVector\".  The problem is the constraint to keep the\n      // camera's up vector in line w/ the WorldUpVector is at odds with\n      // the action of rotating over the top of the virtual sphere used\n      // for rotation.  The solution here is to prevent the user from\n      // rotating the last bit required to \"go over the top\"-- as a\n      // consequence, you can never look directly down on the poles.\n      //\n      // The \"0.99\" value is somewhat arbitrary, but seems to produce\n      // reasonable results.  (Theoretically, some sort of clamping\n      // function could probably be used rather than a hard cutoff, but\n      // time constraints prevent figuring that out right now.)\n      //\n      if (model.useWorldUpVec) {\n        const OVER_THE_TOP_THRESHOLD = 0.99;\n        if (dot(upVec, atV) > OVER_THE_TOP_THRESHOLD && rDist < 0) {\n          rDist = 0;\n        }\n        if (dot(upVec, atV) < -OVER_THE_TOP_THRESHOLD && rDist > 0) {\n          rDist = 0;\n        }\n      }\n      rotateCamera(camera, ...center, ...rightV, rDist);\n      if (model.useWorldUpVec && !areEquals(upVec, camera.getViewPlaneNormal())) {\n        camera.setViewUp(...upVec);\n      }\n      model.previousPosition = position;\n      renderer.resetCameraClippingRange();\n      updateAndRender(interactor);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  const placeFocusSphere = interactor => {\n    const renderer = interactor.findPokedRenderer();\n    model.focusSphere.setPosition(...model.downPoint);\n    const camera = renderer.getActiveCamera();\n    const cameraPosition = camera.getPosition();\n    const cameraToPointVec = [];\n    subtract(model.downPoint, cameraPosition, cameraToPointVec);\n    if (camera.getParallelProjection()) {\n      multiplyScalar(cameraToPointVec, camera.getParallelScale());\n    }\n    const atV = camera.getDirectionOfProjection();\n    normalize(atV);\n\n    // Scales the focus dot so it always appears the same size\n    const scale = 0.02 * dot(atV, cameraToPointVec) * model.focusSphereRadiusFactor;\n    model.focusSphere.setScale(scale, scale, scale);\n  };\n  const placeAndDisplayFocusSphere = interactor => {\n    placeFocusSphere(interactor);\n    interactor.findPokedRenderer().addActor(model.focusSphere);\n    model.isDot = true;\n  };\n  const hideFocusSphere = interactor => {\n    interactor.findPokedRenderer().removeActor(model.focusSphere);\n    model.isDot = false;\n  };\n\n  //----------------------------------------------------------------------------\n  const pickWithPointPicker = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    model.picker.pick([position.x, position.y, position.z], renderer);\n    const pickedPositions = model.picker.getPickedPositions();\n    if (pickedPositions.length === 0) {\n      return model.picker.getPickPosition();\n    }\n    const cameraPosition = renderer.getActiveCamera().getPosition();\n    pickedPositions.sort((pointA, pointB) => distance2BetweenPoints(pointA, cameraPosition) - distance2BetweenPoints(pointB, cameraPosition));\n    return pickedPositions[0];\n  };\n\n  //----------------------------------------------------------------------------\n  const pickPoint = (interactor, position) => {\n    const renderer = interactor.findPokedRenderer();\n    // Finds the point under the cursor.\n    // Note: If no object has been rendered to the pixel (X, Y), then\n    // vtkPicker will return a z-value with depth equal\n    // to the distance from the camera's position to the focal point.\n    // This seems like an arbitrary, but perhaps reasonable, default value.\n    let selections = null;\n    if (model.useHardwareSelector) {\n      const selector = interactor.getView().getSelector();\n      selector.setCaptureZValues(true);\n      selector.setFieldAssociation(FieldAssociations.FIELD_ASSOCIATION_POINTS);\n      selector.attach(interactor.getView(), renderer);\n      selector.setArea(position.x, position.y, position.x, position.y);\n      selections = selector.select();\n    }\n    if (selections && selections.length !== 0) {\n      // convert Float64Array to regular array\n      return Array.from(selections[0].getProperties().worldPosition);\n    }\n    return pickWithPointPicker(interactor, position);\n  };\n\n  //----------------------------------------------------------------------------\n  // Public API methods\n  //----------------------------------------------------------------------------\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.buttonPressed = true;\n    model.startPosition = position;\n    model.previousPosition = position;\n    const normalizedPosition = normalize$1(position, interactor);\n    // borderRatio defines the percentage of the screen size that is considered to be\n    // the border of the screen on each side\n    const borderRatio = 0.1;\n    // If the user is clicking on the perimeter of the screen,\n    // then we want to go into rotation mode, and there is no need to determine the downPoint\n    if (Math.abs(normalizedPosition.x) > 1 - borderRatio || Math.abs(normalizedPosition.y) > 1 - borderRatio) {\n      model.state = States.IS_ROTATE;\n      placeAndDisplayFocusSphere(interactor);\n      return;\n    }\n    model.downPoint = pickPoint(interactor, position);\n    if (model.isDot) {\n      model.state = States.IS_ROTATE;\n    } else {\n      model.state = States.IS_NONE;\n      if (model.displayFocusSphereOnButtonDown) {\n        placeAndDisplayFocusSphere(interactor);\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!model.buttonPressed) {\n      return;\n    }\n    model.state = States.IS_ROTATE;\n    rotate(interactor, position);\n    model.previousPosition = position;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.onButtonUp = interactor => {\n    const renderer = interactor.findPokedRenderer();\n    model.buttonPressed = false;\n\n    // If rotation without a focus sphere, nothing to do\n    if (model.state === States.IS_ROTATE && !model.isDot) {\n      return;\n    }\n    if (model.state === States.IS_ROTATE) {\n      hideFocusSphere(interactor);\n    } else if (model.state === States.IS_NONE) {\n      placeAndDisplayFocusSphere(interactor);\n    }\n    renderer.resetCameraClippingRange();\n    updateAndRender(interactor);\n  };\n  publicAPI.getFocusSphereColor = () => {\n    model.focusSphere.getProperty().getColor();\n  };\n  publicAPI.setFocusSphereColor = (r, g, b) => {\n    model.focusSphere.getProperty().setColor(r, g, b);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  focusSphereRadiusFactor: 1,\n  displayFocusSphereOnButtonDown: true,\n  useHardwareSelector: true,\n  useWorldUpVec: true,\n  // set WorldUpVector to be z-axis by default\n  worldUpVec: [0, 0, 1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['focusSphereRadiusFactor', 'displayFocusSphereOnButtonDown', 'useHardwareSelector', 'useWorldUpVec']);\n  macro.get(publicAPI, model, ['state']);\n  macro.getArray(publicAPI, model, ['downPoint'], 3);\n  macro.setGetArray(publicAPI, model, ['worldUpVec'], 3);\n\n  // Object specific methods\n  vtkMouseCameraUnicamRotateManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraUnicamRotateManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraUnicamRotateManipulator$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkMouseCameraUnicamRotateManipulator$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}