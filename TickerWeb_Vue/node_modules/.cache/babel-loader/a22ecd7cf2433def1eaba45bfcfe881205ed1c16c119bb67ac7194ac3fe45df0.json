{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { n as newInstance$1, c as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\nconst vtkWebGPUSphereMapperVS = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::Color::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);\n\n  //VTK::Color::Impl\n\n  // compute the projected vertex position\n  output.centerVC = vertexVC.xyz;\n  output.radiusVC = length(offsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (rendererUBO.cameraParallel == 0u)\n    {\n    var dir: vec3<f32> = normalize(-vertexVC.xyz);\n    var base2: vec3<f32> = normalize(cross(dir,vec3<f32>(1.0,0.0,0.0)));\n    var base1: vec3<f32> = cross(base2,dir);\n    dir = vertexVC.xyz + offsetMC.x*base1 + offsetMC.y*base2;\n    vertexVC = vec4<f32>(dir, 1.0);\n    }\n  else\n    {\n    // add in the offset\n    var tmp2: vec2<f32> = vertexVC.xy + offsetMC;\n    vertexVC = vec4<f32>(tmp2, vertexVC.zw);\n    }\n\n  output.vertexVC = vec4<f32>(vertexVC.xyz, 0.0);\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSphereMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSphereMapper');\n  const cellMapperBuildPass = publicAPI.buildPass;\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n      const poly = model.renderable.getInputData();\n      publicAPI.setCellArray(poly.getVerts());\n      publicAPI.setCurrentInput(poly);\n    }\n    cellMapperBuildPass(prepass);\n  };\n  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    vDesc.addOutput('vec3<f32>', 'centerVC');\n    vDesc.addOutput('f32', 'radiusVC');\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinOutput('f32', '@builtin(frag_depth) fragDepth');\n    const sphereFrag = `\n    // compute the eye position and unit direction\n    var vertexVC: vec4<f32>;\n    var EyePos: vec3<f32>;\n    var EyeDir: vec3<f32>;\n    var invertedDepth: f32 = 1.0;\n    if (rendererUBO.cameraParallel != 0u) {\n      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);\n      EyeDir = vec3<f32>(0.0, 0.0, -1.0);\n    }\n    else {\n      EyeDir = input.vertexVC.xyz;\n      EyePos = vec3<f32>(0.0,0.0,0.0);\n      var lengthED: f32 = length(EyeDir);\n      EyeDir = normalize(EyeDir);\n      // we adjust the EyePos to be closer if it is too far away\n      // to prevent floating point precision noise\n      if (lengthED > input.radiusVC*3.0) {\n        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;\n      }\n    }\n\n    // translate to Sphere center\n    EyePos = EyePos - input.centerVC;\n    // scale to radius 1.0\n    EyePos = EyePos * (1.0 / input.radiusVC);\n    // find the intersection\n    var b: f32 = 2.0*dot(EyePos,EyeDir);\n    var c: f32 = dot(EyePos,EyePos) - 1.0;\n    var d: f32 = b*b - 4.0*c;\n    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\n    if (d < 0.0) { discard; }\n    else {\n      var t: f32 = (-b - invertedDepth*sqrt(d))*0.5;\n\n      // compute the normal, for unit sphere this is just\n      // the intersection point\n      normal = invertedDepth*normalize(EyePos + t*EyeDir);\n      // compute the intersection point in VC\n      vertexVC = vec4<f32>(normal * input.radiusVC + input.centerVC, 1.0);\n    }\n    // compute the pixel's depth\n    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;\n    output.fragDepth = pos.z / pos.w;\n    `;\n    let code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', [sphereFrag]).result;\n    fDesc.setCode(code);\n  };\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['  output.Position = rendererUBO.VCPCMatrix*vertexVC;']).result;\n    vDesc.setCode(code);\n  };\n\n  // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n  publicAPI.computePipelineHash = () => {\n    model.pipelineHash = 'spm';\n    if (model.vertexInput.hasAttribute(`colorVI`)) {\n      model.pipelineHash += `c`;\n    }\n    model.pipelineHash += model.renderEncoder.getPipelineHash();\n  };\n  publicAPI.updateBuffers = () => {\n    const poly = model.currentInput;\n    model.renderable.mapScalars(poly, 1.0);\n    const points = poly.getPoints();\n    const numPoints = points.getNumberOfPoints();\n    const pointArray = points.getData();\n\n    // default to one instance and computed number of verts\n    publicAPI.setNumberOfInstances(1);\n    publicAPI.setNumberOfVertices(3 * numPoints);\n    const vertexInput = model.vertexInput;\n    let hash = `spm${points.getMTime()}float32x3`;\n    if (!model.device.getBufferManager().hasBuffer(hash)) {\n      const buffRequest = {\n        hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      };\n      // xyz v1 v2 v3\n      const tmpVBO = new Float32Array(3 * numPoints * 3);\n      let pointIdx = 0;\n      let vboIdx = 0;\n      for (let id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n      }\n      buffRequest.nativeArray = tmpVBO;\n      const buff = model.device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC']);\n    }\n\n    // compute offset VBO\n    const pointData = poly.getPointData();\n    let scales = null;\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    const defaultRadius = model.renderable.getRadius();\n    if (scales || defaultRadius !== model._lastRadius) {\n      hash = `spm${scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius}float32x2`;\n      if (!model.device.getBufferManager().hasBuffer(hash)) {\n        const buffRequest = {\n          hash,\n          usage: BufferUsage.RawVertex,\n          format: 'float32x2'\n        };\n        const tmpVBO = new Float32Array(3 * numPoints * 2);\n        const cos30 = Math.cos(radiansFromDegrees(30.0));\n        let vboIdx = 0;\n        for (let id = 0; id < numPoints; ++id) {\n          let radius = model.renderable.getRadius();\n          if (scales) {\n            radius = scales[id] * model.renderable.getScaleFactor();\n          }\n          tmpVBO[vboIdx++] = -2.0 * radius * cos30;\n          tmpVBO[vboIdx++] = -radius;\n          tmpVBO[vboIdx++] = 2.0 * radius * cos30;\n          tmpVBO[vboIdx++] = -radius;\n          tmpVBO[vboIdx++] = 0.0;\n          tmpVBO[vboIdx++] = 2.0 * radius;\n        }\n        buffRequest.nativeArray = tmpVBO;\n        const buff = model.device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['offsetMC']);\n      }\n      model._lastRadius = defaultRadius;\n    }\n\n    // deal with colors but only if modified\n    let haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      const c = model.renderable.getColorMapColors();\n      if (c) {\n        hash = `spm${c.getMTime()}unorm8x4`;\n        if (!model.device.getBufferManager().hasBuffer(hash)) {\n          const buffRequest = {\n            hash,\n            usage: BufferUsage.RawVertex,\n            format: 'unorm8x4'\n          };\n          const colorComponents = c.getNumberOfComponents();\n          if (colorComponents !== 4) {\n            vtkErrorMacro('this should be 4');\n          }\n          const tmpVBO = new Uint8ClampedArray(3 * numPoints * 4);\n          let vboIdx = 0;\n          const colorData = c.getData();\n          for (let id = 0; id < numPoints; ++id) {\n            const colorIdx = id * colorComponents;\n            for (let v = 0; v < 3; v++) {\n              tmpVBO[vboIdx++] = colorData[colorIdx];\n              tmpVBO[vboIdx++] = colorData[colorIdx + 1];\n              tmpVBO[vboIdx++] = colorData[colorIdx + 2];\n              tmpVBO[vboIdx++] = colorData[colorIdx + 3];\n            }\n          }\n          buffRequest.nativeArray = tmpVBO;\n          const buff = model.device.getBufferManager().getBuffer(buffRequest);\n          vertexInput.addBuffer(buff, ['colorVI']);\n        }\n        haveColors = true;\n      }\n    }\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n    publicAPI.setTopology('triangle-list');\n    publicAPI.updateUBO();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUCellArrayMapper.extend(publicAPI, model, initialValues);\n  publicAPI.setVertexShaderTemplate(vtkWebGPUSphereMapperVS);\n\n  // Object methods\n  vtkWebGPUSphereMapper(publicAPI, model);\n  const sr = model.shaderReplacements;\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  sr.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUSphereMapper');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkSphereMapper', newInstance);\nexport { index as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","c","macro","r","radiansFromDegrees","vtkWebGPUCellArrayMapper","vtkWebGPUBufferManager","vtkWebGPUShaderCache","registerOverride","BufferUsage","vtkErrorMacro","vtkWebGPUSphereMapperVS","vtkWebGPUSphereMapper","publicAPI","model","classHierarchy","push","cellMapperBuildPass","buildPass","prepass","renderable","getStatic","update","poly","getInputData","setCellArray","getVerts","setCurrentInput","replaceShaderNormal","hash","pipeline","vertexInput","vDesc","getShaderDescription","hasOutput","addOutput","fDesc","addBuiltinOutput","sphereFrag","code","getCode","substitute","result","setCode","replaceShaderPosition","computePipelineHash","pipelineHash","hasAttribute","renderEncoder","getPipelineHash","updateBuffers","currentInput","mapScalars","points","getPoints","numPoints","getNumberOfPoints","pointArray","getData","setNumberOfInstances","setNumberOfVertices","getMTime","device","getBufferManager","hasBuffer","buffRequest","usage","RawVertex","format","tmpVBO","Float32Array","pointIdx","vboIdx","id","nativeArray","buff","getBuffer","addBuffer","pointData","getPointData","scales","getScaleArray","hasArray","getArray","defaultRadius","getRadius","_lastRadius","cos30","Math","cos","radius","getScaleFactor","haveColors","getScalarVisibility","getColorMapColors","colorComponents","getNumberOfComponents","Uint8ClampedArray","colorData","colorIdx","v","removeBufferIfPresent","setTopology","updateUBO","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","setVertexShaderTemplate","sr","shaderReplacements","set","newInstance","index","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/WebGPU/SphereMapper.js"],"sourcesContent":["import { n as newInstance$1, c as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\nconst vtkWebGPUSphereMapperVS = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::Color::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);\n\n  //VTK::Color::Impl\n\n  // compute the projected vertex position\n  output.centerVC = vertexVC.xyz;\n  output.radiusVC = length(offsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (rendererUBO.cameraParallel == 0u)\n    {\n    var dir: vec3<f32> = normalize(-vertexVC.xyz);\n    var base2: vec3<f32> = normalize(cross(dir,vec3<f32>(1.0,0.0,0.0)));\n    var base1: vec3<f32> = cross(base2,dir);\n    dir = vertexVC.xyz + offsetMC.x*base1 + offsetMC.y*base2;\n    vertexVC = vec4<f32>(dir, 1.0);\n    }\n  else\n    {\n    // add in the offset\n    var tmp2: vec2<f32> = vertexVC.xy + offsetMC;\n    vertexVC = vec4<f32>(tmp2, vertexVC.zw);\n    }\n\n  output.vertexVC = vec4<f32>(vertexVC.xyz, 0.0);\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUSphereMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUSphereMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUSphereMapper');\n  const cellMapperBuildPass = publicAPI.buildPass;\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n      const poly = model.renderable.getInputData();\n      publicAPI.setCellArray(poly.getVerts());\n      publicAPI.setCurrentInput(poly);\n    }\n    cellMapperBuildPass(prepass);\n  };\n  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    vDesc.addOutput('vec3<f32>', 'centerVC');\n    vDesc.addOutput('f32', 'radiusVC');\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinOutput('f32', '@builtin(frag_depth) fragDepth');\n    const sphereFrag = `\n    // compute the eye position and unit direction\n    var vertexVC: vec4<f32>;\n    var EyePos: vec3<f32>;\n    var EyeDir: vec3<f32>;\n    var invertedDepth: f32 = 1.0;\n    if (rendererUBO.cameraParallel != 0u) {\n      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);\n      EyeDir = vec3<f32>(0.0, 0.0, -1.0);\n    }\n    else {\n      EyeDir = input.vertexVC.xyz;\n      EyePos = vec3<f32>(0.0,0.0,0.0);\n      var lengthED: f32 = length(EyeDir);\n      EyeDir = normalize(EyeDir);\n      // we adjust the EyePos to be closer if it is too far away\n      // to prevent floating point precision noise\n      if (lengthED > input.radiusVC*3.0) {\n        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;\n      }\n    }\n\n    // translate to Sphere center\n    EyePos = EyePos - input.centerVC;\n    // scale to radius 1.0\n    EyePos = EyePos * (1.0 / input.radiusVC);\n    // find the intersection\n    var b: f32 = 2.0*dot(EyePos,EyeDir);\n    var c: f32 = dot(EyePos,EyePos) - 1.0;\n    var d: f32 = b*b - 4.0*c;\n    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\n    if (d < 0.0) { discard; }\n    else {\n      var t: f32 = (-b - invertedDepth*sqrt(d))*0.5;\n\n      // compute the normal, for unit sphere this is just\n      // the intersection point\n      normal = invertedDepth*normalize(EyePos + t*EyeDir);\n      // compute the intersection point in VC\n      vertexVC = vec4<f32>(normal * input.radiusVC + input.centerVC, 1.0);\n    }\n    // compute the pixel's depth\n    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;\n    output.fragDepth = pos.z / pos.w;\n    `;\n    let code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', [sphereFrag]).result;\n    fDesc.setCode(code);\n  };\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['  output.Position = rendererUBO.VCPCMatrix*vertexVC;']).result;\n    vDesc.setCode(code);\n  };\n\n  // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n  publicAPI.computePipelineHash = () => {\n    model.pipelineHash = 'spm';\n    if (model.vertexInput.hasAttribute(`colorVI`)) {\n      model.pipelineHash += `c`;\n    }\n    model.pipelineHash += model.renderEncoder.getPipelineHash();\n  };\n  publicAPI.updateBuffers = () => {\n    const poly = model.currentInput;\n    model.renderable.mapScalars(poly, 1.0);\n    const points = poly.getPoints();\n    const numPoints = points.getNumberOfPoints();\n    const pointArray = points.getData();\n\n    // default to one instance and computed number of verts\n    publicAPI.setNumberOfInstances(1);\n    publicAPI.setNumberOfVertices(3 * numPoints);\n    const vertexInput = model.vertexInput;\n    let hash = `spm${points.getMTime()}float32x3`;\n    if (!model.device.getBufferManager().hasBuffer(hash)) {\n      const buffRequest = {\n        hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      };\n      // xyz v1 v2 v3\n      const tmpVBO = new Float32Array(3 * numPoints * 3);\n      let pointIdx = 0;\n      let vboIdx = 0;\n      for (let id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n      }\n      buffRequest.nativeArray = tmpVBO;\n      const buff = model.device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC']);\n    }\n\n    // compute offset VBO\n    const pointData = poly.getPointData();\n    let scales = null;\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    const defaultRadius = model.renderable.getRadius();\n    if (scales || defaultRadius !== model._lastRadius) {\n      hash = `spm${scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius}float32x2`;\n      if (!model.device.getBufferManager().hasBuffer(hash)) {\n        const buffRequest = {\n          hash,\n          usage: BufferUsage.RawVertex,\n          format: 'float32x2'\n        };\n        const tmpVBO = new Float32Array(3 * numPoints * 2);\n        const cos30 = Math.cos(radiansFromDegrees(30.0));\n        let vboIdx = 0;\n        for (let id = 0; id < numPoints; ++id) {\n          let radius = model.renderable.getRadius();\n          if (scales) {\n            radius = scales[id] * model.renderable.getScaleFactor();\n          }\n          tmpVBO[vboIdx++] = -2.0 * radius * cos30;\n          tmpVBO[vboIdx++] = -radius;\n          tmpVBO[vboIdx++] = 2.0 * radius * cos30;\n          tmpVBO[vboIdx++] = -radius;\n          tmpVBO[vboIdx++] = 0.0;\n          tmpVBO[vboIdx++] = 2.0 * radius;\n        }\n        buffRequest.nativeArray = tmpVBO;\n        const buff = model.device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['offsetMC']);\n      }\n      model._lastRadius = defaultRadius;\n    }\n\n    // deal with colors but only if modified\n    let haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      const c = model.renderable.getColorMapColors();\n      if (c) {\n        hash = `spm${c.getMTime()}unorm8x4`;\n        if (!model.device.getBufferManager().hasBuffer(hash)) {\n          const buffRequest = {\n            hash,\n            usage: BufferUsage.RawVertex,\n            format: 'unorm8x4'\n          };\n          const colorComponents = c.getNumberOfComponents();\n          if (colorComponents !== 4) {\n            vtkErrorMacro('this should be 4');\n          }\n          const tmpVBO = new Uint8ClampedArray(3 * numPoints * 4);\n          let vboIdx = 0;\n          const colorData = c.getData();\n          for (let id = 0; id < numPoints; ++id) {\n            const colorIdx = id * colorComponents;\n            for (let v = 0; v < 3; v++) {\n              tmpVBO[vboIdx++] = colorData[colorIdx];\n              tmpVBO[vboIdx++] = colorData[colorIdx + 1];\n              tmpVBO[vboIdx++] = colorData[colorIdx + 2];\n              tmpVBO[vboIdx++] = colorData[colorIdx + 3];\n            }\n          }\n          buffRequest.nativeArray = tmpVBO;\n          const buff = model.device.getBufferManager().getBuffer(buffRequest);\n          vertexInput.addBuffer(buff, ['colorVI']);\n        }\n        haveColors = true;\n      }\n    }\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n    publicAPI.setTopology('triangle-list');\n    publicAPI.updateUBO();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUCellArrayMapper.extend(publicAPI, model, initialValues);\n  publicAPI.setVertexShaderTemplate(vtkWebGPUSphereMapperVS);\n\n  // Object methods\n  vtkWebGPUSphereMapper(publicAPI, model);\n  const sr = model.shaderReplacements;\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  sr.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUSphereMapper');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkSphereMapper', newInstance);\n\nexport { index as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}