{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { mat4, vec3 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\nimport { r as radiansFromDegrees, A as degreesFromRadians } from '../../Common/Core/Math/index.js';\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraTrackballRollManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraTrackballRollManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraTrackballRollManipulator');\n  const axis = new Float64Array(3);\n  const direction = new Float64Array(3);\n  const centerNeg = new Float64Array(3);\n  const transform = new Float64Array(16);\n  const newCamPos = new Float64Array(3);\n  const newFp = new Float64Array(3);\n  const newViewUp = new Float64Array(3);\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.previousPosition = position;\n  };\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!position) {\n      return;\n    }\n    const camera = renderer.getActiveCamera();\n\n    // compute view vector (rotation axis)\n    const cameraPos = camera.getPosition();\n    const cameraFp = camera.getFocalPoint();\n    const viewUp = camera.getViewUp();\n    axis[0] = cameraFp[0] - cameraPos[0];\n    axis[1] = cameraFp[1] - cameraPos[1];\n    axis[2] = cameraFp[2] - cameraPos[2];\n\n    // compute the angle of rotation\n    // - first compute the two vectors (center to mouse)\n    publicAPI.computeDisplayCenter(interactor.getInteractorStyle(), renderer);\n    const x1 = model.previousPosition.x - model.displayCenter[0];\n    const x2 = position.x - model.displayCenter[0];\n    const y1 = model.previousPosition.y - model.displayCenter[1];\n    const y2 = position.y - model.displayCenter[1];\n    if (x2 === 0 && y2 === 0 || x1 === 0 && y1 === 0) {\n      // don't ever want to divide by zero\n      return;\n    }\n\n    // - divide by magnitudes to get angle\n    const angle = degreesFromRadians((x1 * y2 - y1 * x2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n    const {\n      center\n    } = model;\n    mat4.identity(transform);\n    centerNeg[0] = -center[0];\n    centerNeg[1] = -center[1];\n    centerNeg[2] = -center[2];\n\n    // Translate to center\n    mat4.translate(transform, transform, center);\n\n    // roll\n    mat4.rotate(transform, transform, radiansFromDegrees(angle), axis);\n\n    // Translate back\n    mat4.translate(transform, transform, centerNeg);\n\n    // Apply transformation to camera position, focal point, and view up\n    vec3.transformMat4(newCamPos, cameraPos, transform);\n    vec3.transformMat4(newFp, cameraFp, transform);\n    direction[0] = viewUp[0] + cameraPos[0];\n    direction[1] = viewUp[1] + cameraPos[1];\n    direction[2] = viewUp[2] + cameraPos[2];\n    vec3.transformMat4(newViewUp, direction, transform);\n    camera.setPosition(newCamPos[0], newCamPos[1], newCamPos[2]);\n    camera.setFocalPoint(newFp[0], newFp[1], newFp[2]);\n    camera.setViewUp(newViewUp[0] - newCamPos[0], newViewUp[1] - newCamPos[1], newViewUp[2] - newCamPos[2]);\n    camera.orthogonalizeViewUp();\n    renderer.resetCameraClippingRange();\n    if (interactor.getLightFollowCamera()) {\n      renderer.updateLightsGeometryToFollowCamera();\n    }\n    model.previousPosition = position;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Object specific methods\n  vtkMouseCameraTrackballRollManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraTrackballRollManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraTrackballRollManipulator$1 = {\n  newInstance,\n  extend\n};\nexport { vtkMouseCameraTrackballRollManipulator$1 as default, extend, newInstance };","map":{"version":3,"names":["mat4","vec3","m","macro","vtkCompositeCameraManipulator","vtkCompositeMouseManipulator","r","radiansFromDegrees","A","degreesFromRadians","vtkMouseCameraTrackballRollManipulator","publicAPI","model","classHierarchy","push","axis","Float64Array","direction","centerNeg","transform","newCamPos","newFp","newViewUp","onButtonDown","interactor","renderer","position","previousPosition","onMouseMove","camera","getActiveCamera","cameraPos","getPosition","cameraFp","getFocalPoint","viewUp","getViewUp","computeDisplayCenter","getInteractorStyle","x1","x","displayCenter","x2","y1","y","y2","angle","Math","sqrt","center","identity","translate","rotate","transformMat4","setPosition","setFocalPoint","setViewUp","orthogonalizeViewUp","resetCameraClippingRange","getLightFollowCamera","updateLightsGeometryToFollowCamera","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","obj","newInstance","vtkMouseCameraTrackballRollManipulator$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraTrackballRollManipulator.js"],"sourcesContent":["import { mat4, vec3 } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\nimport { r as radiansFromDegrees, A as degreesFromRadians } from '../../Common/Core/Math/index.js';\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraTrackballRollManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraTrackballRollManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraTrackballRollManipulator');\n  const axis = new Float64Array(3);\n  const direction = new Float64Array(3);\n  const centerNeg = new Float64Array(3);\n  const transform = new Float64Array(16);\n  const newCamPos = new Float64Array(3);\n  const newFp = new Float64Array(3);\n  const newViewUp = new Float64Array(3);\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    model.previousPosition = position;\n  };\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    if (!position) {\n      return;\n    }\n    const camera = renderer.getActiveCamera();\n\n    // compute view vector (rotation axis)\n    const cameraPos = camera.getPosition();\n    const cameraFp = camera.getFocalPoint();\n    const viewUp = camera.getViewUp();\n    axis[0] = cameraFp[0] - cameraPos[0];\n    axis[1] = cameraFp[1] - cameraPos[1];\n    axis[2] = cameraFp[2] - cameraPos[2];\n\n    // compute the angle of rotation\n    // - first compute the two vectors (center to mouse)\n    publicAPI.computeDisplayCenter(interactor.getInteractorStyle(), renderer);\n    const x1 = model.previousPosition.x - model.displayCenter[0];\n    const x2 = position.x - model.displayCenter[0];\n    const y1 = model.previousPosition.y - model.displayCenter[1];\n    const y2 = position.y - model.displayCenter[1];\n    if (x2 === 0 && y2 === 0 || x1 === 0 && y1 === 0) {\n      // don't ever want to divide by zero\n      return;\n    }\n\n    // - divide by magnitudes to get angle\n    const angle = degreesFromRadians((x1 * y2 - y1 * x2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n    const {\n      center\n    } = model;\n    mat4.identity(transform);\n    centerNeg[0] = -center[0];\n    centerNeg[1] = -center[1];\n    centerNeg[2] = -center[2];\n\n    // Translate to center\n    mat4.translate(transform, transform, center);\n\n    // roll\n    mat4.rotate(transform, transform, radiansFromDegrees(angle), axis);\n\n    // Translate back\n    mat4.translate(transform, transform, centerNeg);\n\n    // Apply transformation to camera position, focal point, and view up\n    vec3.transformMat4(newCamPos, cameraPos, transform);\n    vec3.transformMat4(newFp, cameraFp, transform);\n    direction[0] = viewUp[0] + cameraPos[0];\n    direction[1] = viewUp[1] + cameraPos[1];\n    direction[2] = viewUp[2] + cameraPos[2];\n    vec3.transformMat4(newViewUp, direction, transform);\n    camera.setPosition(newCamPos[0], newCamPos[1], newCamPos[2]);\n    camera.setFocalPoint(newFp[0], newFp[1], newFp[2]);\n    camera.setViewUp(newViewUp[0] - newCamPos[0], newViewUp[1] - newCamPos[1], newViewUp[2] - newCamPos[2]);\n    camera.orthogonalizeViewUp();\n    renderer.resetCameraClippingRange();\n    if (interactor.getLightFollowCamera()) {\n      renderer.updateLightsGeometryToFollowCamera();\n    }\n    model.previousPosition = position;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Object specific methods\n  vtkMouseCameraTrackballRollManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraTrackballRollManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraTrackballRollManipulator$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkMouseCameraTrackballRollManipulator$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}