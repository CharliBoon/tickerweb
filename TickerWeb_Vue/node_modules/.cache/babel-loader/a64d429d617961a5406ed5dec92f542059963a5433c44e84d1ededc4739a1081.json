{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkHardwareSelector from '../Core/HardwareSelector.js';\nimport vtkWebGPUBuffer from './Buffer.js';\nimport vtkWebGPUHardwareSelectionPass from './HardwareSelectionPass.js';\nimport vtkSelectionNode from '../../Common/DataModel/SelectionNode.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\nconst {\n  SelectionContent,\n  SelectionField\n} = vtkSelectionNode;\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  vtkErrorMacro\n} = macro;\nfunction getInfoHash(info) {\n  return `${info.propID} ${info.compositeID}`;\n}\nfunction convert(xx, yy, buffdata, channel) {\n  const offset = ((buffdata.height - yy - 1) * buffdata.colorBufferWidth + xx) * 4 + channel;\n  return buffdata.colorValues[offset];\n}\nfunction getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {\n  // Base case\n  const maxDist = maxDistance < 0 ? 0 : maxDistance;\n  if (maxDist === 0) {\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    if (inDisplayPosition[0] < 0 || inDisplayPosition[0] >= buffdata.width || inDisplayPosition[1] < 0 || inDisplayPosition[1] >= buffdata.height) {\n      return null;\n    }\n    const actorid = convert(inDisplayPosition[0], inDisplayPosition[1], buffdata, 0);\n    if (actorid <= 0) {\n      // the pixel did not hit any actor.\n      return null;\n    }\n    const info = {};\n    info.propID = actorid;\n    let compositeID = convert(inDisplayPosition[0], inDisplayPosition[1], buffdata, 1);\n    if (compositeID < 0 || compositeID > 0xffffff) {\n      compositeID = 0;\n    }\n    info.compositeID = compositeID;\n    if (buffdata.captureZValues) {\n      const offset = (buffdata.height - inDisplayPosition[1] - 1) * buffdata.zbufferBufferWidth + inDisplayPosition[0];\n      info.zValue = buffdata.depthValues[offset];\n      info.zValue = buffdata.webGPURenderer.convertToOpenGLDepth(info.zValue);\n      info.displayPosition = inDisplayPosition;\n    }\n    return info;\n  }\n\n  // Iterate over successively growing boxes.\n  // They recursively call the base case to handle single pixels.\n  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n  const curPos = [0, 0];\n  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);\n  if (info) {\n    return info;\n  }\n  for (let dist = 1; dist < maxDist; ++dist) {\n    // Vertical sides of box.\n    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {\n      curPos[1] = y;\n      if (dispPos[0] >= dist) {\n        curPos[0] = dispPos[0] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n        if (info) {\n          return info;\n        }\n      }\n      curPos[0] = dispPos[0] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n      if (info) {\n        return info;\n      }\n    }\n    // Horizontal sides of box.\n    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {\n      curPos[0] = x;\n      if (dispPos[1] >= dist) {\n        curPos[1] = dispPos[1] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n        if (info) {\n          return info;\n        }\n      }\n      curPos[1] = dispPos[1] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n      if (info) {\n        return info;\n      }\n    }\n  }\n\n  // nothing hit.\n  outSelectedPosition[0] = inDisplayPosition[0];\n  outSelectedPosition[1] = inDisplayPosition[1];\n  return null;\n}\n\n//-----------------------------------------------------------------------------\nfunction convertSelection(fieldassociation, dataMap, buffdata) {\n  const sel = [];\n  let count = 0;\n  dataMap.forEach((value, key) => {\n    const child = vtkSelectionNode.newInstance();\n    child.setContentType(SelectionContent.INDICES);\n    switch (fieldassociation) {\n      case FieldAssociations.FIELD_ASSOCIATION_CELLS:\n        child.setFieldType(SelectionField.CELL);\n        break;\n      case FieldAssociations.FIELD_ASSOCIATION_POINTS:\n        child.setFieldType(SelectionField.POINT);\n        break;\n      default:\n        vtkErrorMacro('Unknown field association');\n    }\n    child.getProperties().propID = value.info.propID;\n    const wprop = buffdata.webGPURenderer.getPropFromID(value.info.propID);\n    child.getProperties().prop = wprop.getRenderable();\n    child.getProperties().compositeID = value.info.compositeID;\n    child.getProperties().pixelCount = value.pixelCount;\n    if (buffdata.captureZValues) {\n      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];\n      child.getProperties().worldPosition = buffdata.webGPURenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, buffdata.renderer);\n    }\n    child.setSelectionList(value.attributeIDs);\n    sel[count] = child;\n    count++;\n  });\n  return sel;\n}\n\n//----------------------------------------------------------------------------\nfunction generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {\n  const x1 = Math.floor(fx1);\n  const y1 = Math.floor(fy1);\n  const x2 = Math.floor(fx2);\n  const y2 = Math.floor(fy2);\n  const dataMap = new Map();\n  const outSelectedPosition = [0, 0];\n  for (let yy = y1; yy <= y2; yy++) {\n    for (let xx = x1; xx <= x2; xx++) {\n      const pos = [xx, yy];\n      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);\n      if (info) {\n        const hash = getInfoHash(info);\n        if (!dataMap.has(hash)) {\n          dataMap.set(hash, {\n            info,\n            pixelCount: 1,\n            attributeIDs: [info.attributeID]\n          });\n        } else {\n          const dmv = dataMap.get(hash);\n          dmv.pixelCount++;\n          if (buffdata.captureZValues) {\n            if (info.zValue < dmv.info.zValue) {\n              dmv.info = info;\n            }\n          }\n          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n            dmv.attributeIDs.push(info.attributeID);\n          }\n        }\n      }\n    }\n  }\n  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata);\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUHardwareSelector methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUHardwareSelector(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUHardwareSelector');\n\n  //----------------------------------------------------------------------------\n  publicAPI.endSelection = () => {\n    model.WebGPURenderer.setSelector(null);\n  };\n\n  //----------------------------------------------------------------------------\n  // note we ignore the x,y arguments as WebGPU has to do buffer copies\n  // of the entire depth bufer. We could realloc hardware selection textures\n  // based on the passed in size etc but it gets messy so for now we always\n  // render the full size window and copy it to the buffers.\n  publicAPI.getSourceDataAsync = async renderer => {\n    if (!renderer || !model._WebGPURenderWindow) {\n      vtkErrorMacro('Renderer and view must be set before calling Select.');\n      return false;\n    }\n\n    // todo revisit making selection part of core\n    // then we can do this in core\n    model._WebGPURenderWindow.getRenderable().preRender();\n    if (!model._WebGPURenderWindow.getInitialized()) {\n      model._WebGPURenderWindow.initialize();\n      await new Promise(resolve => {\n        model._WebGPURenderWindow.onInitialized(resolve);\n      });\n    }\n    const webGPURenderer = model._WebGPURenderWindow.getViewNodeFor(renderer);\n    if (!webGPURenderer) {\n      return false;\n    }\n\n    // Initialize renderer for selection.\n    // change the renderer's background to black, which will indicate a miss\n    const originalSuppress = webGPURenderer.getSuppressClear();\n    webGPURenderer.setSuppressClear(true);\n    model._selectionPass.traverse(model._WebGPURenderWindow, webGPURenderer);\n\n    // restore original background\n    webGPURenderer.setSuppressClear(originalSuppress);\n    const device = model._WebGPURenderWindow.getDevice();\n    const texture = model._selectionPass.getColorTexture();\n    const depthTexture = model._selectionPass.getDepthTexture();\n\n    // as this is async we really don't want to store things in\n    // the class as multiple calls may start before resolving\n    // so anything specific to this request gets put into the\n    // result object (by value in most cases)\n    const result = {\n      area: [0, 0, texture.getWidth() - 1, texture.getHeight() - 1],\n      captureZValues: model.captureZValues,\n      fieldAssociation: model.fieldAssociation,\n      renderer,\n      webGPURenderer,\n      webGPURenderWindow: model._WebGPURenderWindow,\n      width: texture.getWidth(),\n      height: texture.getHeight()\n    };\n\n    // must be a multiple of 256 bytes, so 16 texels with rgba32uint\n    result.colorBufferWidth = 16 * Math.floor((result.width + 15) / 16);\n    result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 4 * 4;\n    const colorBuffer = vtkWebGPUBuffer.newInstance({\n      label: 'hardwareSelectColorBuffer'\n    });\n    colorBuffer.setDevice(device);\n    /* eslint-disable no-bitwise */\n    /* eslint-disable no-undef */\n    colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n    /* eslint-enable no-bitwise */\n    /* eslint-enable no-undef */\n\n    const cmdEnc = model._WebGPURenderWindow.getCommandEncoder();\n    cmdEnc.copyTextureToBuffer({\n      texture: texture.getHandle()\n    }, {\n      buffer: colorBuffer.getHandle(),\n      bytesPerRow: 16 * result.colorBufferWidth,\n      rowsPerImage: result.height\n    }, {\n      width: result.width,\n      height: result.height,\n      depthOrArrayLayers: 1\n    });\n    let zbuffer;\n    if (model.captureZValues) {\n      result.zbufferBufferWidth = 64 * Math.floor((result.width + 63) / 64);\n      zbuffer = vtkWebGPUBuffer.newInstance({\n        label: 'hardwareSelectDepthBuffer'\n      });\n      zbuffer.setDevice(device);\n      result.zbufferSizeInBytes = result.height * result.zbufferBufferWidth * 4;\n      /* eslint-disable no-bitwise */\n      /* eslint-disable no-undef */\n      zbuffer.create(result.zbufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n      /* eslint-enable no-bitwise */\n      /* eslint-enable no-undef */\n\n      cmdEnc.copyTextureToBuffer({\n        texture: depthTexture.getHandle(),\n        aspect: 'depth-only'\n      }, {\n        buffer: zbuffer.getHandle(),\n        bytesPerRow: 4 * result.zbufferBufferWidth,\n        rowsPerImage: result.height\n      }, {\n        width: result.width,\n        height: result.height,\n        depthOrArrayLayers: 1\n      });\n    }\n    device.submitCommandEncoder(cmdEnc);\n\n    /* eslint-disable no-undef */\n    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);\n    if (model.captureZValues) {\n      const zLoad = zbuffer.mapAsync(GPUMapMode.READ);\n      await Promise.all([cLoad, zLoad]);\n      result.depthValues = new Float32Array(zbuffer.getMappedRange().slice());\n      zbuffer.unmap();\n    } else {\n      await cLoad;\n    }\n    /* eslint-enable no-undef */\n\n    result.colorValues = new Uint32Array(colorBuffer.getMappedRange().slice());\n    colorBuffer.unmap();\n    result.generateSelection = (fx1, fy1, fx2, fy2) => generateSelectionWithData(result, fx1, fy1, fx2, fy2);\n    return result;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // WebGPURenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkHardwareSelector.extend(publicAPI, model, initialValues);\n  model._selectionPass = vtkWebGPUHardwareSelectionPass.newInstance();\n  macro.setGet(publicAPI, model, ['_WebGPURenderWindow']);\n  macro.moveToProtected(publicAPI, model, ['WebGPURenderWindow']);\n\n  // Object methods\n  vtkWebGPUHardwareSelector(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUHardwareSelector');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUHardwareSelector$1 = {\n  newInstance,\n  extend\n};\nexport { vtkWebGPUHardwareSelector$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkHardwareSelector","vtkWebGPUBuffer","vtkWebGPUHardwareSelectionPass","vtkSelectionNode","vtkDataSet","SelectionContent","SelectionField","FieldAssociations","vtkErrorMacro","getInfoHash","info","propID","compositeID","convert","xx","yy","buffdata","channel","offset","height","colorBufferWidth","colorValues","getPixelInformationWithData","inDisplayPosition","maxDistance","outSelectedPosition","maxDist","width","actorid","captureZValues","zbufferBufferWidth","zValue","depthValues","webGPURenderer","convertToOpenGLDepth","displayPosition","dispPos","curPos","dist","y","x","convertSelection","fieldassociation","dataMap","sel","count","forEach","value","key","child","newInstance","setContentType","INDICES","FIELD_ASSOCIATION_CELLS","setFieldType","CELL","FIELD_ASSOCIATION_POINTS","POINT","getProperties","wprop","getPropFromID","prop","getRenderable","pixelCount","worldPosition","webGPURenderWindow","displayToWorld","renderer","setSelectionList","attributeIDs","generateSelectionWithData","fx1","fy1","fx2","fy2","x1","Math","floor","y1","x2","y2","Map","pos","hash","has","set","attributeID","dmv","get","indexOf","push","fieldAssociation","vtkWebGPUHardwareSelector","publicAPI","model","classHierarchy","endSelection","WebGPURenderer","setSelector","getSourceDataAsync","_WebGPURenderWindow","preRender","getInitialized","initialize","Promise","resolve","onInitialized","getViewNodeFor","originalSuppress","getSuppressClear","setSuppressClear","_selectionPass","traverse","device","getDevice","texture","getColorTexture","depthTexture","getDepthTexture","result","area","getWidth","getHeight","colorBufferSizeInBytes","colorBuffer","label","setDevice","create","GPUBufferUsage","MAP_READ","COPY_DST","cmdEnc","getCommandEncoder","copyTextureToBuffer","getHandle","buffer","bytesPerRow","rowsPerImage","depthOrArrayLayers","zbuffer","zbufferSizeInBytes","aspect","submitCommandEncoder","cLoad","mapAsync","GPUMapMode","READ","zLoad","all","Float32Array","getMappedRange","slice","unmap","Uint32Array","generateSelection","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","setGet","moveToProtected","vtkWebGPUHardwareSelector$1","default"],"sources":["C:/Users/Malcolm/Projects/Web/my-vtkjs-app/node_modules/@kitware/vtk.js/Rendering/WebGPU/HardwareSelector.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkHardwareSelector from '../Core/HardwareSelector.js';\nimport vtkWebGPUBuffer from './Buffer.js';\nimport vtkWebGPUHardwareSelectionPass from './HardwareSelectionPass.js';\nimport vtkSelectionNode from '../../Common/DataModel/SelectionNode.js';\nimport vtkDataSet from '../../Common/DataModel/DataSet.js';\n\nconst {\n  SelectionContent,\n  SelectionField\n} = vtkSelectionNode;\nconst {\n  FieldAssociations\n} = vtkDataSet;\nconst {\n  vtkErrorMacro\n} = macro;\nfunction getInfoHash(info) {\n  return `${info.propID} ${info.compositeID}`;\n}\nfunction convert(xx, yy, buffdata, channel) {\n  const offset = ((buffdata.height - yy - 1) * buffdata.colorBufferWidth + xx) * 4 + channel;\n  return buffdata.colorValues[offset];\n}\nfunction getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {\n  // Base case\n  const maxDist = maxDistance < 0 ? 0 : maxDistance;\n  if (maxDist === 0) {\n    outSelectedPosition[0] = inDisplayPosition[0];\n    outSelectedPosition[1] = inDisplayPosition[1];\n    if (inDisplayPosition[0] < 0 || inDisplayPosition[0] >= buffdata.width || inDisplayPosition[1] < 0 || inDisplayPosition[1] >= buffdata.height) {\n      return null;\n    }\n    const actorid = convert(inDisplayPosition[0], inDisplayPosition[1], buffdata, 0);\n    if (actorid <= 0) {\n      // the pixel did not hit any actor.\n      return null;\n    }\n    const info = {};\n    info.propID = actorid;\n    let compositeID = convert(inDisplayPosition[0], inDisplayPosition[1], buffdata, 1);\n    if (compositeID < 0 || compositeID > 0xffffff) {\n      compositeID = 0;\n    }\n    info.compositeID = compositeID;\n    if (buffdata.captureZValues) {\n      const offset = (buffdata.height - inDisplayPosition[1] - 1) * buffdata.zbufferBufferWidth + inDisplayPosition[0];\n      info.zValue = buffdata.depthValues[offset];\n      info.zValue = buffdata.webGPURenderer.convertToOpenGLDepth(info.zValue);\n      info.displayPosition = inDisplayPosition;\n    }\n    return info;\n  }\n\n  // Iterate over successively growing boxes.\n  // They recursively call the base case to handle single pixels.\n  const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];\n  const curPos = [0, 0];\n  let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);\n  if (info) {\n    return info;\n  }\n  for (let dist = 1; dist < maxDist; ++dist) {\n    // Vertical sides of box.\n    for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {\n      curPos[1] = y;\n      if (dispPos[0] >= dist) {\n        curPos[0] = dispPos[0] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n        if (info) {\n          return info;\n        }\n      }\n      curPos[0] = dispPos[0] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n      if (info) {\n        return info;\n      }\n    }\n    // Horizontal sides of box.\n    for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {\n      curPos[0] = x;\n      if (dispPos[1] >= dist) {\n        curPos[1] = dispPos[1] - dist;\n        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n        if (info) {\n          return info;\n        }\n      }\n      curPos[1] = dispPos[1] + dist;\n      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);\n      if (info) {\n        return info;\n      }\n    }\n  }\n\n  // nothing hit.\n  outSelectedPosition[0] = inDisplayPosition[0];\n  outSelectedPosition[1] = inDisplayPosition[1];\n  return null;\n}\n\n//-----------------------------------------------------------------------------\nfunction convertSelection(fieldassociation, dataMap, buffdata) {\n  const sel = [];\n  let count = 0;\n  dataMap.forEach((value, key) => {\n    const child = vtkSelectionNode.newInstance();\n    child.setContentType(SelectionContent.INDICES);\n    switch (fieldassociation) {\n      case FieldAssociations.FIELD_ASSOCIATION_CELLS:\n        child.setFieldType(SelectionField.CELL);\n        break;\n      case FieldAssociations.FIELD_ASSOCIATION_POINTS:\n        child.setFieldType(SelectionField.POINT);\n        break;\n      default:\n        vtkErrorMacro('Unknown field association');\n    }\n    child.getProperties().propID = value.info.propID;\n    const wprop = buffdata.webGPURenderer.getPropFromID(value.info.propID);\n    child.getProperties().prop = wprop.getRenderable();\n    child.getProperties().compositeID = value.info.compositeID;\n    child.getProperties().pixelCount = value.pixelCount;\n    if (buffdata.captureZValues) {\n      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];\n      child.getProperties().worldPosition = buffdata.webGPURenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, buffdata.renderer);\n    }\n    child.setSelectionList(value.attributeIDs);\n    sel[count] = child;\n    count++;\n  });\n  return sel;\n}\n\n//----------------------------------------------------------------------------\nfunction generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {\n  const x1 = Math.floor(fx1);\n  const y1 = Math.floor(fy1);\n  const x2 = Math.floor(fx2);\n  const y2 = Math.floor(fy2);\n  const dataMap = new Map();\n  const outSelectedPosition = [0, 0];\n  for (let yy = y1; yy <= y2; yy++) {\n    for (let xx = x1; xx <= x2; xx++) {\n      const pos = [xx, yy];\n      const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);\n      if (info) {\n        const hash = getInfoHash(info);\n        if (!dataMap.has(hash)) {\n          dataMap.set(hash, {\n            info,\n            pixelCount: 1,\n            attributeIDs: [info.attributeID]\n          });\n        } else {\n          const dmv = dataMap.get(hash);\n          dmv.pixelCount++;\n          if (buffdata.captureZValues) {\n            if (info.zValue < dmv.info.zValue) {\n              dmv.info = info;\n            }\n          }\n          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {\n            dmv.attributeIDs.push(info.attributeID);\n          }\n        }\n      }\n    }\n  }\n  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata);\n}\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUHardwareSelector methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUHardwareSelector(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUHardwareSelector');\n\n  //----------------------------------------------------------------------------\n  publicAPI.endSelection = () => {\n    model.WebGPURenderer.setSelector(null);\n  };\n\n  //----------------------------------------------------------------------------\n  // note we ignore the x,y arguments as WebGPU has to do buffer copies\n  // of the entire depth bufer. We could realloc hardware selection textures\n  // based on the passed in size etc but it gets messy so for now we always\n  // render the full size window and copy it to the buffers.\n  publicAPI.getSourceDataAsync = async renderer => {\n    if (!renderer || !model._WebGPURenderWindow) {\n      vtkErrorMacro('Renderer and view must be set before calling Select.');\n      return false;\n    }\n\n    // todo revisit making selection part of core\n    // then we can do this in core\n    model._WebGPURenderWindow.getRenderable().preRender();\n    if (!model._WebGPURenderWindow.getInitialized()) {\n      model._WebGPURenderWindow.initialize();\n      await new Promise(resolve => {\n        model._WebGPURenderWindow.onInitialized(resolve);\n      });\n    }\n    const webGPURenderer = model._WebGPURenderWindow.getViewNodeFor(renderer);\n    if (!webGPURenderer) {\n      return false;\n    }\n\n    // Initialize renderer for selection.\n    // change the renderer's background to black, which will indicate a miss\n    const originalSuppress = webGPURenderer.getSuppressClear();\n    webGPURenderer.setSuppressClear(true);\n    model._selectionPass.traverse(model._WebGPURenderWindow, webGPURenderer);\n\n    // restore original background\n    webGPURenderer.setSuppressClear(originalSuppress);\n    const device = model._WebGPURenderWindow.getDevice();\n    const texture = model._selectionPass.getColorTexture();\n    const depthTexture = model._selectionPass.getDepthTexture();\n\n    // as this is async we really don't want to store things in\n    // the class as multiple calls may start before resolving\n    // so anything specific to this request gets put into the\n    // result object (by value in most cases)\n    const result = {\n      area: [0, 0, texture.getWidth() - 1, texture.getHeight() - 1],\n      captureZValues: model.captureZValues,\n      fieldAssociation: model.fieldAssociation,\n      renderer,\n      webGPURenderer,\n      webGPURenderWindow: model._WebGPURenderWindow,\n      width: texture.getWidth(),\n      height: texture.getHeight()\n    };\n\n    // must be a multiple of 256 bytes, so 16 texels with rgba32uint\n    result.colorBufferWidth = 16 * Math.floor((result.width + 15) / 16);\n    result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 4 * 4;\n    const colorBuffer = vtkWebGPUBuffer.newInstance({\n      label: 'hardwareSelectColorBuffer'\n    });\n    colorBuffer.setDevice(device);\n    /* eslint-disable no-bitwise */\n    /* eslint-disable no-undef */\n    colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n    /* eslint-enable no-bitwise */\n    /* eslint-enable no-undef */\n\n    const cmdEnc = model._WebGPURenderWindow.getCommandEncoder();\n    cmdEnc.copyTextureToBuffer({\n      texture: texture.getHandle()\n    }, {\n      buffer: colorBuffer.getHandle(),\n      bytesPerRow: 16 * result.colorBufferWidth,\n      rowsPerImage: result.height\n    }, {\n      width: result.width,\n      height: result.height,\n      depthOrArrayLayers: 1\n    });\n    let zbuffer;\n    if (model.captureZValues) {\n      result.zbufferBufferWidth = 64 * Math.floor((result.width + 63) / 64);\n      zbuffer = vtkWebGPUBuffer.newInstance({\n        label: 'hardwareSelectDepthBuffer'\n      });\n      zbuffer.setDevice(device);\n      result.zbufferSizeInBytes = result.height * result.zbufferBufferWidth * 4;\n      /* eslint-disable no-bitwise */\n      /* eslint-disable no-undef */\n      zbuffer.create(result.zbufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n      /* eslint-enable no-bitwise */\n      /* eslint-enable no-undef */\n\n      cmdEnc.copyTextureToBuffer({\n        texture: depthTexture.getHandle(),\n        aspect: 'depth-only'\n      }, {\n        buffer: zbuffer.getHandle(),\n        bytesPerRow: 4 * result.zbufferBufferWidth,\n        rowsPerImage: result.height\n      }, {\n        width: result.width,\n        height: result.height,\n        depthOrArrayLayers: 1\n      });\n    }\n    device.submitCommandEncoder(cmdEnc);\n\n    /* eslint-disable no-undef */\n    const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);\n    if (model.captureZValues) {\n      const zLoad = zbuffer.mapAsync(GPUMapMode.READ);\n      await Promise.all([cLoad, zLoad]);\n      result.depthValues = new Float32Array(zbuffer.getMappedRange().slice());\n      zbuffer.unmap();\n    } else {\n      await cLoad;\n    }\n    /* eslint-enable no-undef */\n\n    result.colorValues = new Uint32Array(colorBuffer.getMappedRange().slice());\n    colorBuffer.unmap();\n    result.generateSelection = (fx1, fy1, fx2, fy2) => generateSelectionWithData(result, fx1, fy1, fx2, fy2);\n    return result;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // WebGPURenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  vtkHardwareSelector.extend(publicAPI, model, initialValues);\n  model._selectionPass = vtkWebGPUHardwareSelectionPass.newInstance();\n  macro.setGet(publicAPI, model, ['_WebGPURenderWindow']);\n  macro.moveToProtected(publicAPI, model, ['WebGPURenderWindow']);\n\n  // Object methods\n  vtkWebGPUHardwareSelector(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkWebGPUHardwareSelector');\n\n// ----------------------------------------------------------------------------\n\nvar vtkWebGPUHardwareSelector$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkWebGPUHardwareSelector$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}