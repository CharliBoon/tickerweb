{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { vec3, mat4, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  const inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n  const matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(matrix, quat.create(), coordShift, inverseScale);\n  return matrix;\n}\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n  return !(vec3.exactEquals(coordShift, [0, 0, 0]) && vec3.exactEquals(coordScale, [1, 1, 1]));\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {\n    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    }\n\n    // Figure out how big each block will be, currently 6 or 7 floats.\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n    const pointData = options.points.getData();\n    let normalData = null;\n    let tcoordData = null;\n    let colorData = null;\n    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;\n    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;\n\n    // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n    if (options.customAttributes) {\n      options.customAttributes.forEach(a => {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName()\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n    model.stride = 4 * model.blockSize;\n    let pointIdx = 0;\n    let normalIdx = 0;\n    let tcoordIdx = 0;\n    let colorIdx = 0;\n    let custIdx = 0;\n    let cellCount = 0;\n    let addAPoint;\n    const cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts, offset, cellId) {\n        for (let i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i], cellId);\n        }\n      },\n      linesToWireframe(numPoints, cellPts, offset, cellIdx) {\n        // for lines we add a bunch of segments\n        for (let i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i], cellIdx);\n          addAPoint(cellPts[offset + i + 1], cellIdx);\n        }\n      },\n      polysToWireframe(numPoints, cellPts, offset, cellIdx) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (let i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + (i + 1) % numPoints], cellIdx);\n          }\n        }\n      },\n      stripsToWireframe(numPoints, cellPts, offset, cellIdx) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (let i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + i + 1], cellIdx);\n          }\n          for (let i = 0; i < numPoints - 2; i++) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + i + 2], cellIdx);\n          }\n        }\n      },\n      polysToSurface(npts, cellPts, offset, cellIdx) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0], cellIdx);\n          addAPoint(cellPts[offset + i + 1], cellIdx);\n          addAPoint(cellPts[offset + i + 2], cellIdx);\n        }\n      },\n      stripsToSurface(npts, cellPts, offset, cellIdx) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i], cellIdx);\n          addAPoint(cellPts[offset + i + 1 + i % 2], cellIdx);\n          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellIdx);\n        }\n      }\n    };\n    const cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n      linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n        return 0;\n      },\n      polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n        return 0;\n      },\n      stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n        return 0;\n      },\n      polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      }\n    };\n    let func = null;\n    let countFunc = null;\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[`${inRep}ToWireframe`];\n      countFunc = cellCounters[`${inRep}ToWireframe`];\n    } else {\n      func = cellBuilders[`${inRep}ToSurface`];\n      countFunc = cellCounters[`${inRep}ToSurface`];\n    }\n    const array = cellArray.getData();\n    const size = array.length;\n    let caboCount = 0;\n    for (let index = 0; index < size;) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n    let packedUCVBO = null;\n    const packedVBO = new Float32Array(caboCount * model.blockSize);\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n    let vboidx = 0;\n    let ucidx = 0;\n\n    // Find out if shift scale should be used\n    // Compute squares of diagonal size and distance from the origin\n    let diagSq = 0.0;\n    let distSq = 0.0;\n    for (let i = 0; i < 3; ++i) {\n      const range = options.points.getRange(i);\n      const delta = range[1] - range[0];\n      diagSq += delta * delta;\n      const distShift = 0.5 * (range[1] + range[0]);\n      distSq += distShift * distShift;\n    }\n    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||\n    // If data is far from the origin relative to its size\n    Math.abs(Math.log10(diagSq)) > 3.0 ||\n    // If the size is huge when not far from the origin\n    diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin\n\n    if (useShiftAndScale) {\n      // Compute shift and scale vectors\n      const coordShift = new Float64Array(3);\n      const coordScale = new Float64Array(3);\n      for (let i = 0; i < 3; ++i) {\n        const range = options.points.getRange(i);\n        const delta = range[1] - range[0];\n        coordShift[i] = 0.5 * (range[1] + range[0]);\n        coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;\n      }\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    }\n\n    // Initialize the structures used to keep track of point ids and cell ids for selectors\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n    let pointCount = options.vertexOffset;\n    addAPoint = function addAPointFunc(pointId, cellId) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = pointId;\n        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;\n      }\n      ++pointCount;\n\n      // Vertices\n      pointIdx = pointId * 3;\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = pointId * 3;\n        }\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n      model.customData.forEach(attr => {\n        custIdx = pointId * attr.components;\n        for (let j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n      if (tcoordData !== null) {\n        if (options.useTCoordsPerCell) {\n          tcoordIdx = cellId * textureComponents;\n        } else {\n          tcoordIdx = pointId * textureComponents;\n        }\n        for (let j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = pointId * colorComponents;\n        }\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n\n    // Browse the cell array: the index is at the beginning of a cell\n    // The value of 'array' at the position 'index' is the number of points in the cell\n    for (let index = 0; index < size; index += array[index] + 1, cellCount++) {\n      func(array[index], array, index + 1, cellCount + options.cellOffset);\n    }\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    return cellCount;\n  };\n  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {\n    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n    if (model.coordShift === null || coordShift === null || !vec3.equals(coordShift, model.coordShift)) {\n      model.coordShift = coordShift;\n    }\n    if (model.coordScale === null || coordScale === null || !vec3.equals(coordScale, model.coordScale)) {\n      model.coordScale = coordScale;\n    }\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);\n  macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']);\n\n  // Object specific methods\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArrayBufferObject = {\n  newInstance,\n  extend\n};\nexport { vtkCellArrayBufferObject as default, extend, newInstance };","map":{"version":3,"names":["vec3","mat4","quat","m","macro","vtkBufferObject","ObjectType","Representation","vtkErrorMacro","computeInverseShiftAndScaleMatrix","coordShift","coordScale","inverseScale","Float64Array","inverse","matrix","fromRotationTranslationScale","create","shouldApplyCoordShiftAndScale","exactEquals","vtkOpenGLCellArrayBufferObject","publicAPI","model","classHierarchy","push","setType","ARRAY_BUFFER","createVBO","cellArray","inRep","outRep","options","selectionMaps","arguments","length","undefined","getData","elementCount","blockSize","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorComponents","colorOffset","customData","pointData","points","normalData","tcoordData","colorData","colors","getNumberOfComponents","textureComponents","tcoords","normals","customAttributes","forEach","a","data","offset","components","name","getName","colorBO","newInstance","setOpenGLRenderWindow","_openGLRenderWindow","stride","pointIdx","normalIdx","tcoordIdx","colorIdx","custIdx","cellCount","addAPoint","cellBuilders","anythingToPoints","numPoints","cellPts","cellId","i","linesToWireframe","cellIdx","polysToWireframe","stripsToWireframe","polysToSurface","npts","stripsToSurface","cellCounters","func","countFunc","POINTS","WIREFRAME","array","size","caboCount","index","packedUCVBO","packedVBO","Float32Array","Uint8Array","vboidx","ucidx","diagSq","distSq","range","getRange","delta","distShift","useShiftAndScale","Math","abs","log10","setCoordShiftAndScale","coordShiftAndScaleEnabled","cells","Int32Array","newPoints","set","newCells","pointCount","addAPointFunc","pointId","cellOffset","haveCellNormals","attr","j","useTCoordsPerCell","haveCellScalars","upload","colorBOStride","constructor","equals","inverseShiftAndScaleMatrix","DEFAULT_VALUES","tcoordBO","extend","initialValues","Object","assign","setGet","get","vtkCellArrayBufferObject","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js"],"sourcesContent":["import { vec3, mat4, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  const inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n  const matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(matrix, quat.create(), coordShift, inverseScale);\n  return matrix;\n}\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n  return !(vec3.exactEquals(coordShift, [0, 0, 0]) && vec3.exactEquals(coordScale, [1, 1, 1]));\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {\n    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    }\n\n    // Figure out how big each block will be, currently 6 or 7 floats.\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n    const pointData = options.points.getData();\n    let normalData = null;\n    let tcoordData = null;\n    let colorData = null;\n    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;\n    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;\n\n    // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n    if (options.customAttributes) {\n      options.customAttributes.forEach(a => {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName()\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n    model.stride = 4 * model.blockSize;\n    let pointIdx = 0;\n    let normalIdx = 0;\n    let tcoordIdx = 0;\n    let colorIdx = 0;\n    let custIdx = 0;\n    let cellCount = 0;\n    let addAPoint;\n    const cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts, offset, cellId) {\n        for (let i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i], cellId);\n        }\n      },\n      linesToWireframe(numPoints, cellPts, offset, cellIdx) {\n        // for lines we add a bunch of segments\n        for (let i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i], cellIdx);\n          addAPoint(cellPts[offset + i + 1], cellIdx);\n        }\n      },\n      polysToWireframe(numPoints, cellPts, offset, cellIdx) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (let i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + (i + 1) % numPoints], cellIdx);\n          }\n        }\n      },\n      stripsToWireframe(numPoints, cellPts, offset, cellIdx) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (let i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + i + 1], cellIdx);\n          }\n          for (let i = 0; i < numPoints - 2; i++) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + i + 2], cellIdx);\n          }\n        }\n      },\n      polysToSurface(npts, cellPts, offset, cellIdx) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0], cellIdx);\n          addAPoint(cellPts[offset + i + 1], cellIdx);\n          addAPoint(cellPts[offset + i + 2], cellIdx);\n        }\n      },\n      stripsToSurface(npts, cellPts, offset, cellIdx) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i], cellIdx);\n          addAPoint(cellPts[offset + i + 1 + i % 2], cellIdx);\n          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellIdx);\n        }\n      }\n    };\n    const cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n      linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n        return 0;\n      },\n      polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n        return 0;\n      },\n      stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n        return 0;\n      },\n      polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      }\n    };\n    let func = null;\n    let countFunc = null;\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[`${inRep}ToWireframe`];\n      countFunc = cellCounters[`${inRep}ToWireframe`];\n    } else {\n      func = cellBuilders[`${inRep}ToSurface`];\n      countFunc = cellCounters[`${inRep}ToSurface`];\n    }\n    const array = cellArray.getData();\n    const size = array.length;\n    let caboCount = 0;\n    for (let index = 0; index < size;) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n    let packedUCVBO = null;\n    const packedVBO = new Float32Array(caboCount * model.blockSize);\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n    let vboidx = 0;\n    let ucidx = 0;\n\n    // Find out if shift scale should be used\n    // Compute squares of diagonal size and distance from the origin\n    let diagSq = 0.0;\n    let distSq = 0.0;\n    for (let i = 0; i < 3; ++i) {\n      const range = options.points.getRange(i);\n      const delta = range[1] - range[0];\n      diagSq += delta * delta;\n      const distShift = 0.5 * (range[1] + range[0]);\n      distSq += distShift * distShift;\n    }\n    const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||\n    // If data is far from the origin relative to its size\n    Math.abs(Math.log10(diagSq)) > 3.0 ||\n    // If the size is huge when not far from the origin\n    diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin\n\n    if (useShiftAndScale) {\n      // Compute shift and scale vectors\n      const coordShift = new Float64Array(3);\n      const coordScale = new Float64Array(3);\n      for (let i = 0; i < 3; ++i) {\n        const range = options.points.getRange(i);\n        const delta = range[1] - range[0];\n        coordShift[i] = 0.5 * (range[1] + range[0]);\n        coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;\n      }\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    }\n\n    // Initialize the structures used to keep track of point ids and cell ids for selectors\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n    let pointCount = options.vertexOffset;\n    addAPoint = function addAPointFunc(pointId, cellId) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = pointId;\n        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;\n      }\n      ++pointCount;\n\n      // Vertices\n      pointIdx = pointId * 3;\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = pointId * 3;\n        }\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n      model.customData.forEach(attr => {\n        custIdx = pointId * attr.components;\n        for (let j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n      if (tcoordData !== null) {\n        if (options.useTCoordsPerCell) {\n          tcoordIdx = cellId * textureComponents;\n        } else {\n          tcoordIdx = pointId * textureComponents;\n        }\n        for (let j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = pointId * colorComponents;\n        }\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n\n    // Browse the cell array: the index is at the beginning of a cell\n    // The value of 'array' at the position 'index' is the number of points in the cell\n    for (let index = 0; index < size; index += array[index] + 1, cellCount++) {\n      func(array[index], array, index + 1, cellCount + options.cellOffset);\n    }\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    return cellCount;\n  };\n  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {\n    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n    if (model.coordShift === null || coordShift === null || !vec3.equals(coordShift, model.coordShift)) {\n      model.coordShift = coordShift;\n    }\n    if (model.coordScale === null || coordScale === null || !vec3.equals(coordScale, model.coordScale)) {\n      model.coordScale = coordScale;\n    }\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);\n  macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']);\n\n  // Object specific methods\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArrayBufferObject = {\n  newInstance,\n  extend\n};\n\nexport { vtkCellArrayBufferObject as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}