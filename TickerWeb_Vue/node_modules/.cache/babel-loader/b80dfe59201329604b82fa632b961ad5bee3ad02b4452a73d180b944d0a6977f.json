{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\n\n// ----------------------------------------------------------------------------\n// vtkSphereSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkSphereSource(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkSphereSource');\n  publicAPI.requestData = (inData, outData) => {\n    if (model.deleted) {\n      return;\n    }\n    let dataset = outData[0];\n    const pointDataType = dataset ? dataset.getPoints().getDataType() : model.pointType;\n    dataset = vtkPolyData.newInstance();\n\n    // ----------------------------------------------------------------------\n    let numPoles = 0;\n\n    // Check data, determine increments, and convert to radians\n    let {\n      thetaResolution\n    } = model;\n    let startTheta = model.startTheta < model.endTheta ? model.startTheta : model.endTheta;\n    startTheta *= Math.PI / 180.0;\n    let endTheta = model.endTheta > model.startTheta ? model.endTheta : model.startTheta;\n    endTheta *= Math.PI / 180.0;\n    let startPhi = model.startPhi < model.endPhi ? model.startPhi : model.endPhi;\n    startPhi *= Math.PI / 180.0;\n    let endPhi = model.endPhi > model.startPhi ? model.endPhi : model.startPhi;\n    endPhi *= Math.PI / 180.0;\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      ++thetaResolution;\n    }\n    const deltaTheta = (endTheta - startTheta) / model.thetaResolution;\n    const jStart = model.startPhi <= 0.0 ? 1 : 0;\n    const jEnd = model.phiResolution + (model.endPhi >= 180.0 ? -1 : 0);\n    const numPts = model.phiResolution * thetaResolution + 2;\n    const numPolys = model.phiResolution * 2 * model.thetaResolution;\n\n    // Points\n    let pointIdx = 0;\n    let points = macro.newTypedArray(pointDataType, numPts * 3);\n\n    // Normals\n    let normals = new Float32Array(numPts * 3);\n\n    // Cells\n    let cellLocation = 0;\n    let polys = new Uint32Array(numPolys * 5);\n\n    // Create north pole if needed\n    if (model.startPhi <= 0.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] + model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = 1;\n      pointIdx++;\n      numPoles++;\n    }\n\n    // Create south pole if needed\n    if (model.endPhi >= 180.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] - model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = -1;\n      pointIdx++;\n      numPoles++;\n    }\n    const phiResolution = model.phiResolution - numPoles;\n    const deltaPhi = (endPhi - startPhi) / (model.phiResolution - 1);\n\n    // Create intermediate points\n    for (let i = 0; i < thetaResolution; i++) {\n      const theta = startTheta + i * deltaTheta;\n      for (let j = jStart; j < jEnd; j++) {\n        const phi = startPhi + j * deltaPhi;\n        const radius = model.radius * Math.sin(phi);\n        normals[pointIdx * 3 + 0] = radius * Math.cos(theta);\n        normals[pointIdx * 3 + 1] = radius * Math.sin(theta);\n        normals[pointIdx * 3 + 2] = model.radius * Math.cos(phi);\n        points[pointIdx * 3 + 0] = normals[pointIdx * 3 + 0] + model.center[0];\n        points[pointIdx * 3 + 1] = normals[pointIdx * 3 + 1] + model.center[1];\n        points[pointIdx * 3 + 2] = normals[pointIdx * 3 + 2] + model.center[2];\n        let norm = Math.sqrt(normals[pointIdx * 3 + 0] * normals[pointIdx * 3 + 0] + normals[pointIdx * 3 + 1] * normals[pointIdx * 3 + 1] + normals[pointIdx * 3 + 2] * normals[pointIdx * 3 + 2]);\n        norm = norm === 0 ? 1 : norm;\n        normals[pointIdx * 3 + 0] /= norm;\n        normals[pointIdx * 3 + 1] /= norm;\n        normals[pointIdx * 3 + 2] /= norm;\n        pointIdx++;\n      }\n    }\n\n    // Generate mesh connectivity\n    const base = phiResolution * thetaResolution;\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      --thetaResolution;\n    }\n\n    // around north pole\n    if (model.startPhi <= 0.0) {\n      for (let i = 0; i < thetaResolution; i++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * i + numPoles;\n        polys[cellLocation++] = phiResolution * (i + 1) % base + numPoles;\n        polys[cellLocation++] = 0;\n      }\n    }\n\n    // around south pole\n    if (model.endPhi >= 180.0) {\n      const numOffset = phiResolution - 1 + numPoles;\n      for (let i = 0; i < thetaResolution; i++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * i + numOffset;\n        polys[cellLocation++] = numPoles - 1;\n        polys[cellLocation++] = phiResolution * (i + 1) % base + numOffset;\n      }\n    }\n\n    // bands in-between poles\n    for (let i = 0; i < thetaResolution; i++) {\n      for (let j = 0; j < phiResolution - 1; j++) {\n        const a = phiResolution * i + j + numPoles;\n        const b = a + 1;\n        const c = (phiResolution * (i + 1) + j) % base + numPoles + 1;\n        if (!model.latLongTessellation) {\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        } else {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        }\n      }\n    }\n\n    // Squeeze\n    points = points.subarray(0, pointIdx * 3);\n    dataset.getPoints().setData(points, 3);\n    normals = normals.subarray(0, pointIdx * 3);\n    const normalArray = vtkDataArray.newInstance({\n      name: 'Normals',\n      values: normals,\n      numberOfComponents: 3\n    });\n    dataset.getPointData().setNormals(normalArray);\n    polys = polys.subarray(0, cellLocation);\n    dataset.getPolys().setData(polys, 1);\n\n    // Update output\n    outData[0] = dataset;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  radius: 0.5,\n  latLongTessellation: false,\n  thetaResolution: 8,\n  startTheta: 0.0,\n  endTheta: 360.0,\n  phiResolution: 8,\n  startPhi: 0.0,\n  endPhi: 180.0,\n  center: [0, 0, 0],\n  pointType: 'Float64Array'\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['radius', 'latLongTessellation', 'thetaResolution', 'startTheta', 'endTheta', 'phiResolution', 'startPhi', 'endPhi']);\n  macro.setGetArray(publicAPI, model, ['center'], 3);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkSphereSource(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkSphereSource');\n\n// ----------------------------------------------------------------------------\n\nvar vtkSphereSource$1 = {\n  newInstance,\n  extend\n};\nexport { vtkSphereSource$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkPolyData","vtkDataArray","vtkSphereSource","publicAPI","model","classHierarchy","push","requestData","inData","outData","deleted","dataset","pointDataType","getPoints","getDataType","pointType","newInstance","numPoles","thetaResolution","startTheta","endTheta","Math","PI","startPhi","endPhi","abs","deltaTheta","jStart","jEnd","phiResolution","numPts","numPolys","pointIdx","points","newTypedArray","normals","Float32Array","cellLocation","polys","Uint32Array","center","radius","deltaPhi","i","theta","j","phi","sin","cos","norm","sqrt","base","numOffset","a","b","c","latLongTessellation","subarray","setData","normalArray","name","values","numberOfComponents","getPointData","setNormals","getPolys","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","Object","assign","obj","setGet","setGetArray","algo","vtkSphereSource$1","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Filters/Sources/SphereSource.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\n\n// ----------------------------------------------------------------------------\n// vtkSphereSource methods\n// ----------------------------------------------------------------------------\n\nfunction vtkSphereSource(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkSphereSource');\n  publicAPI.requestData = (inData, outData) => {\n    if (model.deleted) {\n      return;\n    }\n    let dataset = outData[0];\n    const pointDataType = dataset ? dataset.getPoints().getDataType() : model.pointType;\n    dataset = vtkPolyData.newInstance();\n\n    // ----------------------------------------------------------------------\n    let numPoles = 0;\n\n    // Check data, determine increments, and convert to radians\n    let {\n      thetaResolution\n    } = model;\n    let startTheta = model.startTheta < model.endTheta ? model.startTheta : model.endTheta;\n    startTheta *= Math.PI / 180.0;\n    let endTheta = model.endTheta > model.startTheta ? model.endTheta : model.startTheta;\n    endTheta *= Math.PI / 180.0;\n    let startPhi = model.startPhi < model.endPhi ? model.startPhi : model.endPhi;\n    startPhi *= Math.PI / 180.0;\n    let endPhi = model.endPhi > model.startPhi ? model.endPhi : model.startPhi;\n    endPhi *= Math.PI / 180.0;\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      ++thetaResolution;\n    }\n    const deltaTheta = (endTheta - startTheta) / model.thetaResolution;\n    const jStart = model.startPhi <= 0.0 ? 1 : 0;\n    const jEnd = model.phiResolution + (model.endPhi >= 180.0 ? -1 : 0);\n    const numPts = model.phiResolution * thetaResolution + 2;\n    const numPolys = model.phiResolution * 2 * model.thetaResolution;\n\n    // Points\n    let pointIdx = 0;\n    let points = macro.newTypedArray(pointDataType, numPts * 3);\n\n    // Normals\n    let normals = new Float32Array(numPts * 3);\n\n    // Cells\n    let cellLocation = 0;\n    let polys = new Uint32Array(numPolys * 5);\n\n    // Create north pole if needed\n    if (model.startPhi <= 0.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] + model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = 1;\n      pointIdx++;\n      numPoles++;\n    }\n\n    // Create south pole if needed\n    if (model.endPhi >= 180.0) {\n      points[pointIdx * 3 + 0] = model.center[0];\n      points[pointIdx * 3 + 1] = model.center[1];\n      points[pointIdx * 3 + 2] = model.center[2] - model.radius;\n      normals[pointIdx * 3 + 0] = 0;\n      normals[pointIdx * 3 + 1] = 0;\n      normals[pointIdx * 3 + 2] = -1;\n      pointIdx++;\n      numPoles++;\n    }\n    const phiResolution = model.phiResolution - numPoles;\n    const deltaPhi = (endPhi - startPhi) / (model.phiResolution - 1);\n\n    // Create intermediate points\n    for (let i = 0; i < thetaResolution; i++) {\n      const theta = startTheta + i * deltaTheta;\n      for (let j = jStart; j < jEnd; j++) {\n        const phi = startPhi + j * deltaPhi;\n        const radius = model.radius * Math.sin(phi);\n        normals[pointIdx * 3 + 0] = radius * Math.cos(theta);\n        normals[pointIdx * 3 + 1] = radius * Math.sin(theta);\n        normals[pointIdx * 3 + 2] = model.radius * Math.cos(phi);\n        points[pointIdx * 3 + 0] = normals[pointIdx * 3 + 0] + model.center[0];\n        points[pointIdx * 3 + 1] = normals[pointIdx * 3 + 1] + model.center[1];\n        points[pointIdx * 3 + 2] = normals[pointIdx * 3 + 2] + model.center[2];\n        let norm = Math.sqrt(normals[pointIdx * 3 + 0] * normals[pointIdx * 3 + 0] + normals[pointIdx * 3 + 1] * normals[pointIdx * 3 + 1] + normals[pointIdx * 3 + 2] * normals[pointIdx * 3 + 2]);\n        norm = norm === 0 ? 1 : norm;\n        normals[pointIdx * 3 + 0] /= norm;\n        normals[pointIdx * 3 + 1] /= norm;\n        normals[pointIdx * 3 + 2] /= norm;\n        pointIdx++;\n      }\n    }\n\n    // Generate mesh connectivity\n    const base = phiResolution * thetaResolution;\n    if (Math.abs(startTheta - endTheta) < 2.0 * Math.PI) {\n      --thetaResolution;\n    }\n\n    // around north pole\n    if (model.startPhi <= 0.0) {\n      for (let i = 0; i < thetaResolution; i++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * i + numPoles;\n        polys[cellLocation++] = phiResolution * (i + 1) % base + numPoles;\n        polys[cellLocation++] = 0;\n      }\n    }\n\n    // around south pole\n    if (model.endPhi >= 180.0) {\n      const numOffset = phiResolution - 1 + numPoles;\n      for (let i = 0; i < thetaResolution; i++) {\n        polys[cellLocation++] = 3;\n        polys[cellLocation++] = phiResolution * i + numOffset;\n        polys[cellLocation++] = numPoles - 1;\n        polys[cellLocation++] = phiResolution * (i + 1) % base + numOffset;\n      }\n    }\n\n    // bands in-between poles\n    for (let i = 0; i < thetaResolution; i++) {\n      for (let j = 0; j < phiResolution - 1; j++) {\n        const a = phiResolution * i + j + numPoles;\n        const b = a + 1;\n        const c = (phiResolution * (i + 1) + j) % base + numPoles + 1;\n        if (!model.latLongTessellation) {\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = 3;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        } else {\n          polys[cellLocation++] = 4;\n          polys[cellLocation++] = a;\n          polys[cellLocation++] = b;\n          polys[cellLocation++] = c;\n          polys[cellLocation++] = c - 1;\n        }\n      }\n    }\n\n    // Squeeze\n    points = points.subarray(0, pointIdx * 3);\n    dataset.getPoints().setData(points, 3);\n    normals = normals.subarray(0, pointIdx * 3);\n    const normalArray = vtkDataArray.newInstance({\n      name: 'Normals',\n      values: normals,\n      numberOfComponents: 3\n    });\n    dataset.getPointData().setNormals(normalArray);\n    polys = polys.subarray(0, cellLocation);\n    dataset.getPolys().setData(polys, 1);\n\n    // Update output\n    outData[0] = dataset;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  radius: 0.5,\n  latLongTessellation: false,\n  thetaResolution: 8,\n  startTheta: 0.0,\n  endTheta: 360.0,\n  phiResolution: 8,\n  startPhi: 0.0,\n  endPhi: 180.0,\n  center: [0, 0, 0],\n  pointType: 'Float64Array'\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['radius', 'latLongTessellation', 'thetaResolution', 'startTheta', 'endTheta', 'phiResolution', 'startPhi', 'endPhi']);\n  macro.setGetArray(publicAPI, model, ['center'], 3);\n  macro.algo(publicAPI, model, 0, 1);\n  vtkSphereSource(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkSphereSource');\n\n// ----------------------------------------------------------------------------\n\nvar vtkSphereSource$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkSphereSource$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}