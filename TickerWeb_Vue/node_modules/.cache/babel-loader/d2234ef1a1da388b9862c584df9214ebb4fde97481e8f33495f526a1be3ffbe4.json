{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { n as newInstance$1, o as obj, e as setGet, g as get } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUTextureManager from './TextureManager.js';\n\n/**\n * provide a simple WeakRefMap class to share device objects based on\n * hash values so that buffers/textures etc can be shared betwen mappers.\n * This is roughly based on WeakLRUCache but without the actual caching\n * behavior. This is just a map of key -> WeakRef(value)\n */\n\n/* eslint-disable no-undef */\nclass WeakRefMap extends Map {\n  constructor() {\n    super();\n    this.registry = new FinalizationRegistry(key => {\n      const entry = super.get(key);\n      if (entry && entry.deref && entry.deref() === undefined) super.delete(key);\n    });\n  }\n  getValue(key) {\n    const entry = super.get(key);\n    if (entry) {\n      const value = entry.deref();\n      if (value !== undefined) return value;\n      super.delete(key);\n    }\n    return undefined;\n  }\n  setValue(key, value) {\n    let entry;\n    if (value && typeof value === 'object') {\n      entry = new WeakRef(value);\n      this.registry.register(value, key);\n      super.set(key, entry);\n    }\n    // else entry is undefined\n    return entry;\n  }\n}\n/* eslint-enable no-undef */\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUDevice methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPUDevice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUDevice');\n  publicAPI.initialize = handle => {\n    model.handle = handle;\n  };\n  publicAPI.createCommandEncoder = () => model.handle.createCommandEncoder();\n  publicAPI.submitCommandEncoder = commandEncoder => {\n    model.handle.queue.submit([commandEncoder.finish()]);\n  };\n  publicAPI.getShaderModule = sd => model.shaderCache.getShaderModule(sd);\n\n  /* eslint-disable no-bitwise */\n  /* eslint-disable no-undef */\n  publicAPI.getBindGroupLayout = val => {\n    if (!val.entries) {\n      return null;\n    }\n\n    // add in basic required values if missing\n    for (let i = 0; i < val.entries.length; i++) {\n      const ent = val.entries[i];\n      ent.binding = ent.binding || 0;\n      ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;\n    }\n\n    // do we already have one?\n    const sval = JSON.stringify(val);\n    for (let i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].sval === sval) {\n        return model.bindGroupLayouts[i].layout;\n      }\n    }\n\n    // create one and store it\n    const layout = model.handle.createBindGroupLayout(val);\n\n    // we actually only store the stringified version\n    // as that is what we always compare against\n    model.bindGroupLayouts.push({\n      sval,\n      layout\n    });\n    return layout;\n  };\n  publicAPI.getBindGroupLayoutDescription = layout => {\n    for (let i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].layout === layout) {\n        return model.bindGroupLayouts[i].sval;\n      }\n    }\n    vtkErrorMacro('layout not found');\n    console.trace();\n    return null;\n  };\n  publicAPI.getPipeline = hash => {\n    if (hash in model.pipelines) {\n      return model.pipelines[hash];\n    }\n    return null;\n  };\n  publicAPI.createPipeline = (hash, pipeline) => {\n    pipeline.initialize(publicAPI, hash);\n    model.pipelines[hash] = pipeline;\n  };\n  publicAPI.onSubmittedWorkDone = () => model.handle.queue.onSubmittedWorkDone();\n\n  // The Device has an object cache that can be used to cache buffers,\n  // textures and other objects that can be shared. The basic approach is to\n  // call getCachedObject with a request and a create function. The request\n  // is based on a hash. The cache lookup just returns any entry that has a\n  // matching hash. If a match isn't found then the create function is\n  // called with any extra arguments.\n\n  // is the object already cached?\n  publicAPI.hasCachedObject = hash => model.objectCache.getValue(hash);\n  publicAPI.getCachedObject = function (hash, creator) {\n    if (!hash) {\n      vtkErrorMacro('attempt to cache an object without a hash');\n      return null;\n    }\n    const existingValue = model.objectCache.getValue(hash);\n    if (existingValue) {\n      return existingValue;\n    }\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    const createdObject = creator(...args);\n    model.objectCache.setValue(hash, createdObject);\n    return createdObject;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  handle: null,\n  pipelines: null,\n  shaderCache: null,\n  bindGroupLayouts: null,\n  bufferManager: null,\n  textureManager: null\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  obj(publicAPI, model);\n  setGet(publicAPI, model, ['handle']);\n  get(publicAPI, model, ['bufferManager', 'shaderCache', 'textureManager']);\n\n  // this is a weak ref cache implementation, we create it without\n  // an expirer (so it is strictly based on garbage collection and\n  // objects are not held if there are no external references)\n  // model.objectCache = new WeakLRUCache({ expirer: false });\n  model.objectCache = new WeakRefMap();\n  model.shaderCache = vtkWebGPUShaderCache.newInstance();\n  model.shaderCache.setDevice(publicAPI);\n  model.bindGroupLayouts = [];\n  model.bufferManager = vtkWebGPUBufferManager.newInstance();\n  model.bufferManager.setDevice(publicAPI);\n  model.textureManager = vtkWebGPUTextureManager.newInstance();\n  model.textureManager.setDevice(publicAPI);\n  model.pipelines = {};\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPUDevice(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nconst newInstance = newInstance$1(extend, 'vtkWebGPUDevice');\n\n// ----------------------------------------------------------------------------\nvar vtkWebGPUDevice$1 = {\n  newInstance,\n  extend\n};\nexport { WeakRefMap, vtkWebGPUDevice$1 as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","o","obj","e","setGet","g","get","vtkWebGPUBufferManager","vtkWebGPUShaderCache","vtkWebGPUTextureManager","WeakRefMap","Map","constructor","registry","FinalizationRegistry","key","entry","deref","undefined","delete","getValue","value","setValue","WeakRef","register","set","vtkWebGPUDevice","publicAPI","model","classHierarchy","push","initialize","handle","createCommandEncoder","submitCommandEncoder","commandEncoder","queue","submit","finish","getShaderModule","sd","shaderCache","getBindGroupLayout","val","entries","i","length","ent","binding","visibility","GPUShaderStage","VERTEX","FRAGMENT","sval","JSON","stringify","bindGroupLayouts","layout","createBindGroupLayout","getBindGroupLayoutDescription","vtkErrorMacro","console","trace","getPipeline","hash","pipelines","createPipeline","pipeline","onSubmittedWorkDone","hasCachedObject","objectCache","getCachedObject","creator","existingValue","_len","arguments","args","Array","_key","createdObject","DEFAULT_VALUES","bufferManager","textureManager","extend","initialValues","Object","assign","newInstance","setDevice","vtkWebGPUDevice$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/WebGPU/Device.js"],"sourcesContent":["import { n as newInstance$1, o as obj, e as setGet, g as get } from '../../macros2.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport vtkWebGPUTextureManager from './TextureManager.js';\n\n/**\n * provide a simple WeakRefMap class to share device objects based on\n * hash values so that buffers/textures etc can be shared betwen mappers.\n * This is roughly based on WeakLRUCache but without the actual caching\n * behavior. This is just a map of key -> WeakRef(value)\n */\n\n/* eslint-disable no-undef */\nclass WeakRefMap extends Map {\n  constructor() {\n    super();\n    this.registry = new FinalizationRegistry(key => {\n      const entry = super.get(key);\n      if (entry && entry.deref && entry.deref() === undefined) super.delete(key);\n    });\n  }\n  getValue(key) {\n    const entry = super.get(key);\n    if (entry) {\n      const value = entry.deref();\n      if (value !== undefined) return value;\n      super.delete(key);\n    }\n    return undefined;\n  }\n  setValue(key, value) {\n    let entry;\n    if (value && typeof value === 'object') {\n      entry = new WeakRef(value);\n      this.registry.register(value, key);\n      super.set(key, entry);\n    }\n    // else entry is undefined\n    return entry;\n  }\n}\n/* eslint-enable no-undef */\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUDevice methods\n// ----------------------------------------------------------------------------\nfunction vtkWebGPUDevice(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUDevice');\n  publicAPI.initialize = handle => {\n    model.handle = handle;\n  };\n  publicAPI.createCommandEncoder = () => model.handle.createCommandEncoder();\n  publicAPI.submitCommandEncoder = commandEncoder => {\n    model.handle.queue.submit([commandEncoder.finish()]);\n  };\n  publicAPI.getShaderModule = sd => model.shaderCache.getShaderModule(sd);\n\n  /* eslint-disable no-bitwise */\n  /* eslint-disable no-undef */\n  publicAPI.getBindGroupLayout = val => {\n    if (!val.entries) {\n      return null;\n    }\n\n    // add in basic required values if missing\n    for (let i = 0; i < val.entries.length; i++) {\n      const ent = val.entries[i];\n      ent.binding = ent.binding || 0;\n      ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;\n    }\n\n    // do we already have one?\n    const sval = JSON.stringify(val);\n    for (let i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].sval === sval) {\n        return model.bindGroupLayouts[i].layout;\n      }\n    }\n\n    // create one and store it\n    const layout = model.handle.createBindGroupLayout(val);\n\n    // we actually only store the stringified version\n    // as that is what we always compare against\n    model.bindGroupLayouts.push({\n      sval,\n      layout\n    });\n    return layout;\n  };\n  publicAPI.getBindGroupLayoutDescription = layout => {\n    for (let i = 0; i < model.bindGroupLayouts.length; i++) {\n      if (model.bindGroupLayouts[i].layout === layout) {\n        return model.bindGroupLayouts[i].sval;\n      }\n    }\n    vtkErrorMacro('layout not found');\n    console.trace();\n    return null;\n  };\n  publicAPI.getPipeline = hash => {\n    if (hash in model.pipelines) {\n      return model.pipelines[hash];\n    }\n    return null;\n  };\n  publicAPI.createPipeline = (hash, pipeline) => {\n    pipeline.initialize(publicAPI, hash);\n    model.pipelines[hash] = pipeline;\n  };\n  publicAPI.onSubmittedWorkDone = () => model.handle.queue.onSubmittedWorkDone();\n\n  // The Device has an object cache that can be used to cache buffers,\n  // textures and other objects that can be shared. The basic approach is to\n  // call getCachedObject with a request and a create function. The request\n  // is based on a hash. The cache lookup just returns any entry that has a\n  // matching hash. If a match isn't found then the create function is\n  // called with any extra arguments.\n\n  // is the object already cached?\n  publicAPI.hasCachedObject = hash => model.objectCache.getValue(hash);\n  publicAPI.getCachedObject = function (hash, creator) {\n    if (!hash) {\n      vtkErrorMacro('attempt to cache an object without a hash');\n      return null;\n    }\n    const existingValue = model.objectCache.getValue(hash);\n    if (existingValue) {\n      return existingValue;\n    }\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    const createdObject = creator(...args);\n    model.objectCache.setValue(hash, createdObject);\n    return createdObject;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\nconst DEFAULT_VALUES = {\n  handle: null,\n  pipelines: null,\n  shaderCache: null,\n  bindGroupLayouts: null,\n  bufferManager: null,\n  textureManager: null\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  obj(publicAPI, model);\n  setGet(publicAPI, model, ['handle']);\n  get(publicAPI, model, ['bufferManager', 'shaderCache', 'textureManager']);\n\n  // this is a weak ref cache implementation, we create it without\n  // an expirer (so it is strictly based on garbage collection and\n  // objects are not held if there are no external references)\n  // model.objectCache = new WeakLRUCache({ expirer: false });\n  model.objectCache = new WeakRefMap();\n  model.shaderCache = vtkWebGPUShaderCache.newInstance();\n  model.shaderCache.setDevice(publicAPI);\n  model.bindGroupLayouts = [];\n  model.bufferManager = vtkWebGPUBufferManager.newInstance();\n  model.bufferManager.setDevice(publicAPI);\n  model.textureManager = vtkWebGPUTextureManager.newInstance();\n  model.textureManager.setDevice(publicAPI);\n  model.pipelines = {};\n\n  // For more macro methods, see \"Sources/macros.js\"\n  // Object specific methods\n  vtkWebGPUDevice(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\nconst newInstance = newInstance$1(extend, 'vtkWebGPUDevice');\n\n// ----------------------------------------------------------------------------\nvar vtkWebGPUDevice$1 = {\n  newInstance,\n  extend\n};\n\nexport { WeakRefMap, vtkWebGPUDevice$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}