{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { n as newInstance$1, e as setGet, g as get } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLActor2D(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLActor2D');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model.context = model._openGLRenderWindow.getContext();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNodes(model.renderable.getTextures());\n      publicAPI.addMissingNode(model.renderable.getMapper());\n      publicAPI.removeUnusedNodes();\n\n      // we store textures and mapper\n      model.ogltextures = null;\n      model.activeTextures = null;\n      for (let index = 0; index < model.children.length; index++) {\n        const child = model.children[index];\n        if (child.isA('vtkOpenGLTexture')) {\n          if (!model.ogltextures) {\n            model.ogltextures = [];\n          }\n          model.ogltextures.push(child);\n        } else {\n          model.oglmapper = child;\n        }\n      }\n    }\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      renderPass.incrementOverlayActorCount();\n    }\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseOpaquePass = renderPass => {\n    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseTranslucentPass = renderPass => {\n    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.traverseOverlayPass = renderPass => {\n    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.activateTextures = () => {\n    // always traverse textures first, then mapper\n    if (!model.ogltextures) {\n      return;\n    }\n    model.activeTextures = [];\n    for (let index = 0; index < model.ogltextures.length; index++) {\n      const child = model.ogltextures[index];\n      child.render();\n      if (child.getHandle()) {\n        model.activeTextures.push(child);\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(true);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      // deactivate textures\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(false);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.overlayPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(true);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      // deactivate textures\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  activeTextures: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  get(publicAPI, model, ['activeTextures']);\n\n  // Object methods\n  vtkOpenGLActor2D(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkActor2D = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkActor2D', newInstance);\nexport { vtkActor2D as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","e","setGet","g","get","vtkViewNode","registerOverride","vtkOpenGLActor2D","publicAPI","model","classHierarchy","push","buildPass","prepass","renderable","_openGLRenderWindow","getLastAncestorOfType","_openGLRenderer","getFirstAncestorOfType","context","getContext","prepareNodes","addMissingNodes","getTextures","addMissingNode","getMapper","removeUnusedNodes","ogltextures","activeTextures","index","children","length","child","isA","oglmapper","queryPass","renderPass","getVisibility","incrementOverlayActorCount","traverseOpaquePass","getNestedVisibility","getIsOpaque","getSelector","getNestedPickable","apply","traverse","traverseTranslucentPass","traverseOverlayPass","activateTextures","render","getHandle","opaquePass","depthMask","deactivate","translucentPass","overlayPass","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","newInstance","vtkActor2D","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js"],"sourcesContent":["import { n as newInstance$1, e as setGet, g as get } from '../../macros2.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLActor methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLActor2D(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLActor2D');\n\n  // Builds myself.\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable) {\n        return;\n      }\n      model._openGLRenderWindow = publicAPI.getLastAncestorOfType('vtkOpenGLRenderWindow');\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      model.context = model._openGLRenderWindow.getContext();\n      publicAPI.prepareNodes();\n      publicAPI.addMissingNodes(model.renderable.getTextures());\n      publicAPI.addMissingNode(model.renderable.getMapper());\n      publicAPI.removeUnusedNodes();\n\n      // we store textures and mapper\n      model.ogltextures = null;\n      model.activeTextures = null;\n      for (let index = 0; index < model.children.length; index++) {\n        const child = model.children[index];\n        if (child.isA('vtkOpenGLTexture')) {\n          if (!model.ogltextures) {\n            model.ogltextures = [];\n          }\n          model.ogltextures.push(child);\n        } else {\n          model.oglmapper = child;\n        }\n      }\n    }\n  };\n  publicAPI.queryPass = (prepass, renderPass) => {\n    if (prepass) {\n      if (!model.renderable || !model.renderable.getVisibility()) {\n        return;\n      }\n      renderPass.incrementOverlayActorCount();\n    }\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseOpaquePass = renderPass => {\n    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n\n  // we draw textures, then mapper, then post pass textures\n  publicAPI.traverseTranslucentPass = renderPass => {\n    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.traverseOverlayPass = renderPass => {\n    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {\n      return;\n    }\n    publicAPI.apply(renderPass, true);\n    model.oglmapper.traverse(renderPass);\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.activateTextures = () => {\n    // always traverse textures first, then mapper\n    if (!model.ogltextures) {\n      return;\n    }\n    model.activeTextures = [];\n    for (let index = 0; index < model.ogltextures.length; index++) {\n      const child = model.ogltextures[index];\n      child.render();\n      if (child.getHandle()) {\n        model.activeTextures.push(child);\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.opaquePass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(true);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      // deactivate textures\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.translucentPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(false);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n\n  // Renders myself\n  publicAPI.overlayPass = (prepass, renderPass) => {\n    if (prepass) {\n      model.context.depthMask(true);\n      publicAPI.activateTextures();\n    } else if (model.activeTextures) {\n      // deactivate textures\n      for (let index = 0; index < model.activeTextures.length; index++) {\n        model.activeTextures[index].deactivate();\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  activeTextures: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n\n  // Build VTK API\n  setGet(publicAPI, model, ['context']);\n  get(publicAPI, model, ['activeTextures']);\n\n  // Object methods\n  vtkOpenGLActor2D(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkActor2D = {\n  newInstance,\n  extend\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkActor2D', newInstance);\n\nexport { vtkActor2D as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}