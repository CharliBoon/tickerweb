{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\nconst ANIMATION_REQUESTER = 'vtkMouseCameraTrackballFirstPersonManipulator';\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraTrackballFirstPersonManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraTrackballFirstPersonManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraTrackballFirstPersonManipulator');\n  const internal = {\n    interactor: null,\n    renderer: null,\n    previousPosition: null\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    internal.previousPosition = position;\n    if (model.usePointerLock && !interactor.isPointerLocked()) {\n      Object.assign(internal, {\n        interactor,\n        renderer\n      });\n      interactor.requestPointerLock();\n      publicAPI.startPointerLockInteraction();\n    }\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.startPointerLockInteraction = () => {\n    const {\n      interactor\n    } = internal;\n\n    // TODO: at some point, this should perhaps be done in\n    // RenderWindowInteractor instead of here.\n    // We need to hook into mousemove directly for two reasons:\n    // 1. We need to keep receiving mouse move events after the mouse button\n    //    is released. This is currently not possible with\n    //    vtkInteractorStyleManipulator.\n    // 2. Since the mouse is stationary in pointer lock mode, we need the\n    //    event.movementX and event.movementY info, which are not currently\n    //    passed via interactor.onMouseMove.\n    document.addEventListener('mousemove', publicAPI.onPointerLockMove);\n    let subscription = null;\n    const endInteraction = () => {\n      document.removeEventListener('mousemove', publicAPI.onPointerLockMove);\n      subscription.unsubscribe();\n    };\n    subscription = interactor.onEndPointerLock(endInteraction);\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onPointerLockMove = e => {\n    const sensitivity = model.sensitivity;\n    const yaw = -1 * e.movementX * sensitivity;\n    const pitch = -1 * e.movementY * sensitivity;\n    publicAPI.moveCamera(yaw, pitch);\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    // This is currently only being called for non pointer lock mode\n    if (!position) {\n      return;\n    }\n    const {\n      previousPosition\n    } = internal;\n    const sensitivity = model.sensitivity;\n    const yaw = (previousPosition.x - position.x) * sensitivity;\n    const pitch = (position.y - previousPosition.y) * sensitivity;\n    Object.assign(internal, {\n      interactor,\n      renderer\n    });\n    publicAPI.moveCamera(yaw, pitch);\n    internal.previousPosition = position;\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.moveCamera = (yaw, pitch) => {\n    const {\n      renderer,\n      interactor\n    } = internal;\n    const camera = renderer.getActiveCamera();\n\n    // We need to pick a number of steps here that is not too few\n    // (or the camera will be jittery) and not too many (or the\n    // animations will take too long).\n    // Perhaps this should be calculated?\n    const numSteps = model.numAnimationSteps;\n    const yawStep = yaw / numSteps;\n    const pitchStep = pitch / numSteps;\n    const now = performance.now().toString();\n    const animationRequester = `${ANIMATION_REQUESTER}.${now}`;\n    let curStep = 0;\n    let animationSub = null;\n    const performStep = () => {\n      camera.yaw(yawStep);\n      camera.pitch(pitchStep);\n      camera.orthogonalizeViewUp();\n      curStep += 1;\n      if (curStep === numSteps) {\n        animationSub.unsubscribe();\n        renderer.resetCameraClippingRange();\n        if (interactor.getLightFollowCamera()) {\n          renderer.updateLightsGeometryToFollowCamera();\n        }\n\n        // This needs to be posted to the event loop so it isn't called\n        // in the `handleAnimation` stack, or else the animation will\n        // not be canceled.\n        const cancelRequest = () => {\n          internal.interactor.cancelAnimation(animationRequester);\n        };\n        setTimeout(cancelRequest, 0);\n      }\n    };\n    interactor.requestAnimation(animationRequester);\n    animationSub = interactor.onAnimation(() => performStep());\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  numAnimationSteps: 5,\n  sensitivity: 0.05,\n  usePointerLock: true\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['numAnimationSteps', 'sensitivity', 'usePointerLock']);\n\n  // Object specific methods\n  vtkMouseCameraTrackballFirstPersonManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraTrackballFirstPersonManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraTrackballFirstPersonManipulator$1 = {\n  newInstance,\n  extend\n};\nexport { vtkMouseCameraTrackballFirstPersonManipulator$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkCompositeCameraManipulator","vtkCompositeMouseManipulator","ANIMATION_REQUESTER","vtkMouseCameraTrackballFirstPersonManipulator","publicAPI","model","classHierarchy","push","internal","interactor","renderer","previousPosition","onButtonDown","position","usePointerLock","isPointerLocked","Object","assign","requestPointerLock","startPointerLockInteraction","document","addEventListener","onPointerLockMove","subscription","endInteraction","removeEventListener","unsubscribe","onEndPointerLock","e","sensitivity","yaw","movementX","pitch","movementY","moveCamera","onMouseMove","x","y","camera","getActiveCamera","numSteps","numAnimationSteps","yawStep","pitchStep","now","performance","toString","animationRequester","curStep","animationSub","performStep","orthogonalizeViewUp","resetCameraClippingRange","getLightFollowCamera","updateLightsGeometryToFollowCamera","cancelRequest","cancelAnimation","setTimeout","requestAnimation","onAnimation","DEFAULT_VALUES","extend","initialValues","arguments","length","undefined","obj","setGet","newInstance","vtkMouseCameraTrackballFirstPersonManipulator$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Interaction/Manipulators/MouseCameraTrackballFirstPersonManipulator.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkCompositeCameraManipulator from './CompositeCameraManipulator.js';\nimport vtkCompositeMouseManipulator from './CompositeMouseManipulator.js';\n\nconst ANIMATION_REQUESTER = 'vtkMouseCameraTrackballFirstPersonManipulator';\n\n// ----------------------------------------------------------------------------\n// vtkMouseCameraTrackballFirstPersonManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkMouseCameraTrackballFirstPersonManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkMouseCameraTrackballFirstPersonManipulator');\n  const internal = {\n    interactor: null,\n    renderer: null,\n    previousPosition: null\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onButtonDown = (interactor, renderer, position) => {\n    internal.previousPosition = position;\n    if (model.usePointerLock && !interactor.isPointerLocked()) {\n      Object.assign(internal, {\n        interactor,\n        renderer\n      });\n      interactor.requestPointerLock();\n      publicAPI.startPointerLockInteraction();\n    }\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.startPointerLockInteraction = () => {\n    const {\n      interactor\n    } = internal;\n\n    // TODO: at some point, this should perhaps be done in\n    // RenderWindowInteractor instead of here.\n    // We need to hook into mousemove directly for two reasons:\n    // 1. We need to keep receiving mouse move events after the mouse button\n    //    is released. This is currently not possible with\n    //    vtkInteractorStyleManipulator.\n    // 2. Since the mouse is stationary in pointer lock mode, we need the\n    //    event.movementX and event.movementY info, which are not currently\n    //    passed via interactor.onMouseMove.\n    document.addEventListener('mousemove', publicAPI.onPointerLockMove);\n    let subscription = null;\n    const endInteraction = () => {\n      document.removeEventListener('mousemove', publicAPI.onPointerLockMove);\n      subscription.unsubscribe();\n    };\n    subscription = interactor.onEndPointerLock(endInteraction);\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onPointerLockMove = e => {\n    const sensitivity = model.sensitivity;\n    const yaw = -1 * e.movementX * sensitivity;\n    const pitch = -1 * e.movementY * sensitivity;\n    publicAPI.moveCamera(yaw, pitch);\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onMouseMove = (interactor, renderer, position) => {\n    // This is currently only being called for non pointer lock mode\n    if (!position) {\n      return;\n    }\n    const {\n      previousPosition\n    } = internal;\n    const sensitivity = model.sensitivity;\n    const yaw = (previousPosition.x - position.x) * sensitivity;\n    const pitch = (position.y - previousPosition.y) * sensitivity;\n    Object.assign(internal, {\n      interactor,\n      renderer\n    });\n    publicAPI.moveCamera(yaw, pitch);\n    internal.previousPosition = position;\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.moveCamera = (yaw, pitch) => {\n    const {\n      renderer,\n      interactor\n    } = internal;\n    const camera = renderer.getActiveCamera();\n\n    // We need to pick a number of steps here that is not too few\n    // (or the camera will be jittery) and not too many (or the\n    // animations will take too long).\n    // Perhaps this should be calculated?\n    const numSteps = model.numAnimationSteps;\n    const yawStep = yaw / numSteps;\n    const pitchStep = pitch / numSteps;\n    const now = performance.now().toString();\n    const animationRequester = `${ANIMATION_REQUESTER}.${now}`;\n    let curStep = 0;\n    let animationSub = null;\n    const performStep = () => {\n      camera.yaw(yawStep);\n      camera.pitch(pitchStep);\n      camera.orthogonalizeViewUp();\n      curStep += 1;\n      if (curStep === numSteps) {\n        animationSub.unsubscribe();\n        renderer.resetCameraClippingRange();\n        if (interactor.getLightFollowCamera()) {\n          renderer.updateLightsGeometryToFollowCamera();\n        }\n\n        // This needs to be posted to the event loop so it isn't called\n        // in the `handleAnimation` stack, or else the animation will\n        // not be canceled.\n        const cancelRequest = () => {\n          internal.interactor.cancelAnimation(animationRequester);\n        };\n        setTimeout(cancelRequest, 0);\n      }\n    };\n    interactor.requestAnimation(animationRequester);\n    animationSub = interactor.onAnimation(() => performStep());\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  numAnimationSteps: 5,\n  sensitivity: 0.05,\n  usePointerLock: true\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeCameraManipulator.extend(publicAPI, model, initialValues);\n  vtkCompositeMouseManipulator.extend(publicAPI, model, initialValues);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['numAnimationSteps', 'sensitivity', 'usePointerLock']);\n\n  // Object specific methods\n  vtkMouseCameraTrackballFirstPersonManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkMouseCameraTrackballFirstPersonManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkMouseCameraTrackballFirstPersonManipulator$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkMouseCameraTrackballFirstPersonManipulator$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}