{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { n as newInstance$1, c as macro } from '../../macros2.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// Vertices\n// 013 - 032 - 324 - 453\n//\n//       _.4---_.5\n//    .-*   .-*\n//   2-----3\n//   |    /|\n//   |   / |\n//   |  /  |\n//   | /   |\n//   |/    |\n//   0-----1\n//\n// coord for each points\n// 0: 000\n// 1: 100\n// 2: 001\n// 3: 101\n// 4: 011\n// 5: 111\n\nconst vtkWebGPUStickMapperVS = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::Color::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var offsetsArray: array<vec3<f32>, 12> = array<vec3<f32>, 12>(\n    vec3<f32>(-1.0, -1.0, -1.0),\n    vec3<f32>(1.0, -1.0, -1.0),\n    vec3<f32>(1.0, -1.0, 1.0),\n\n    vec3<f32>(-1.0, -1.0, -1.0),\n    vec3<f32>(1.0, -1.0, 1.0),\n    vec3<f32>(-1.0, -1.0, 1.0),\n\n    vec3<f32>(-1.0, -1.0, 1.0),\n    vec3<f32>(1.0, -1.0, 1.0),\n    vec3<f32>(1.0, 1.0, 1.0),\n\n    vec3<f32>(-1.0, -1.0, 1.0),\n    vec3<f32>(1.0, 1.0, 1.0),\n    vec3<f32>(-1.0, 1.0, 1.0)\n  );\n\n  var output : vertexOutput;\n\n  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);\n\n  //VTK::Color::Impl\n\n  // compute the projected vertex position\n  output.centerVC = vertexVC.xyz;\n  output.radiusVC = radiusMC;\n  output.lengthVC = length(orientMC);\n  output.orientVC = (rendererUBO.WCVCNormals * vec4<f32>(normalize(orientMC), 0.0)).xyz;\n\n  // make sure it is pointing out of the screen\n  if (output.orientVC.z < 0.0)\n    {\n    output.orientVC = -output.orientVC;\n    }\n\n  // make the basis\n  var xbase: vec3<f32>;\n  var ybase: vec3<f32>;\n  var dir: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\n  if (rendererUBO.cameraParallel == 0u)\n    {\n    dir = normalize(-vertexVC.xyz);\n    }\n  if (abs(dot(dir,output.orientVC)) == 1.0)\n    {\n    xbase = normalize(cross(vec3<f32>(0.0,1.0,0.0),output.orientVC));\n    ybase = cross(xbase,output.orientVC);\n    }\n  else\n    {\n    xbase = normalize(cross(output.orientVC,dir));\n    ybase = cross(output.orientVC,xbase);\n    }\n\n\n  var vertIdx: u32 = input.vertexIndex % 12u;\n  var offsets: vec3<f32> = offsetsArray[vertIdx];\n\n  vertexVC = vec4<f32>(vertexVC.xyz +\n    output.radiusVC * offsets.x * xbase +\n    output.radiusVC * offsets.y * ybase +\n    0.5 * output.lengthVC * offsets.z * output.orientVC, 1.0);\n\n  output.vertexVC = vertexVC;\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStickMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUStickMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUStickMapper');\n  const cellMapperBuildPass = publicAPI.buildPass;\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n      const poly = model.renderable.getInputData();\n      publicAPI.setCellArray(poly.getVerts());\n      publicAPI.setCurrentInput(poly);\n    }\n    cellMapperBuildPass(prepass);\n  };\n  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    vDesc.addOutput('vec3<f32>', 'centerVC');\n    vDesc.addOutput('vec3<f32>', 'orientVC');\n    vDesc.addOutput('f32', 'radiusVC');\n    vDesc.addOutput('f32', 'lengthVC');\n    vDesc.addBuiltinInput('u32', '@builtin(vertex_index) vertexIndex');\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinOutput('f32', '@builtin(frag_depth) fragDepth');\n    const stickFrag = `\n    // compute the eye position and unit direction\n    var vertexVC: vec4<f32>;\n    var EyePos: vec3<f32>;\n    var EyeDir: vec3<f32>;\n\n    if (rendererUBO.cameraParallel != 0u)\n    {\n      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);\n      EyeDir = vec3<f32>(0.0, 0.0, -1.0);\n    }\n    else\n    {\n      EyeDir = input.vertexVC.xyz;\n      EyePos = vec3<f32>(0.0,0.0,0.0);\n      var lengthED: f32 = length(EyeDir);\n      EyeDir = normalize(EyeDir);\n      // we adjust the EyePos to be closer if it is too far away\n      // to prevent floating point precision noise\n      if (lengthED > input.radiusVC*3.0)\n      {\n        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;\n      }\n    }\n    // translate to Sphere center\n    EyePos = EyePos - input.centerVC;\n\n    // rotate to new basis\n    // base1, base2, orientVC\n    var base1: vec3<f32>;\n    if (abs(input.orientVC.z) < 0.99)\n    {\n      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,0.0,1.0)));\n    }\n    else\n    {\n      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,1.0,0.0)));\n    }\n    var base2: vec3<f32> = cross(input.orientVC,base1);\n    EyePos = vec3<f32>(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,input.orientVC));\n    EyeDir = vec3<f32>(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,input.orientVC));\n\n    // scale to radius 1.0\n    EyePos = EyePos * (1.0 / input.radiusVC);\n\n    // find the intersection\n    var a: f32 = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n    var b: f32 = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n    var c: f32 = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n    var d: f32 = b*b - 4.0*a*c;\n    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\n    if (d < 0.0) { discard; }\n    else\n    {\n      var t: f32 = (-b - sqrt(d))*(0.5 / a);\n      var tz: f32 = EyePos.z + t*EyeDir.z;\n      var iPoint: vec3<f32> = EyePos + t*EyeDir;\n      if (abs(iPoint.z)*input.radiusVC > input.lengthVC*0.5)\n      {\n        // test for end cap\n        var t2: f32 = (-b + sqrt(d))*(0.5 / a);\n        var tz2: f32 = EyePos.z + t2*EyeDir.z;\n        if (tz2*input.radiusVC > input.lengthVC*0.5 || tz*input.radiusVC < -0.5*input.lengthVC) { discard; }\n        else\n        {\n          normal = input.orientVC;\n          var t3: f32 = (input.lengthVC*0.5/input.radiusVC - EyePos.z)/EyeDir.z;\n          iPoint = EyePos + t3*EyeDir;\n          vertexVC = vec4<f32>(input.radiusVC*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*input.orientVC) + input.centerVC, 1.0);\n        }\n      }\n      else\n      {\n        // The normal is the iPoint.xy rotated back into VC\n        normal = iPoint.x*base1 + iPoint.y*base2;\n        // rescale rerotate and translate\n        vertexVC = vec4<f32>(input.radiusVC*(normal + iPoint.z*input.orientVC) + input.centerVC, 1.0);\n      }\n    }\n    // compute the pixel's depth\n    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;\n    output.fragDepth = pos.z / pos.w;\n  `;\n    let code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', [stickFrag]).result;\n    fDesc.setCode(code);\n  };\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['  output.Position = rendererUBO.VCPCMatrix*vertexVC;']).result;\n    vDesc.setCode(code);\n  };\n\n  // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n  publicAPI.computePipelineHash = () => {\n    model.pipelineHash = 'stm';\n    if (model.vertexInput.hasAttribute(`colorVI`)) {\n      model.pipelineHash += `c`;\n    }\n    model.pipelineHash += model.renderEncoder.getPipelineHash();\n  };\n  publicAPI.updateBuffers = () => {\n    const poly = model.currentInput;\n    model.renderable.mapScalars(poly, 1.0);\n    const device = model.device;\n    const points = poly.getPoints();\n    const pointData = poly.getPointData();\n    const numPoints = points.getNumberOfPoints();\n    const pointArray = points.getData();\n    publicAPI.setNumberOfInstances(numPoints);\n    publicAPI.setNumberOfVertices(12);\n    const vertexInput = model.vertexInput;\n    let hash = `stm${points.getMTime()}float32x3`;\n    if (!device.getBufferManager().hasBuffer(hash)) {\n      const buffRequest = {\n        hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      };\n      // xyz v1 v2 v3\n      const tmpVBO = new Float32Array(numPoints * 3);\n      let pointIdx = 0;\n      let vboIdx = 0;\n      for (let id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n      }\n      buffRequest.nativeArray = tmpVBO;\n      const buff = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC'], 'instance');\n    }\n\n    // compute offset VBO\n    let scales = null;\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    const defaultRadius = model.renderable.getRadius();\n    if (scales || defaultRadius !== model._lastRadius) {\n      hash = `stm${scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius}float32`;\n      if (!device.getBufferManager().hasBuffer(hash)) {\n        const buffRequest = {\n          hash,\n          usage: BufferUsage.RawVertex,\n          format: 'float32'\n        };\n        const tmpVBO = new Float32Array(numPoints);\n        let vboIdx = 0;\n        for (let id = 0; id < numPoints; ++id) {\n          let radius = model.renderable.getRadius();\n          if (scales) {\n            radius = scales[id * 2 + 1];\n          }\n          tmpVBO[vboIdx++] = radius;\n        }\n        buffRequest.nativeArray = tmpVBO;\n        const buff = device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['radiusMC'], 'instance');\n      }\n      model._lastRadius = defaultRadius;\n    }\n    let orientationArray = null;\n    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {\n      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();\n    } else {\n      vtkErrorMacro(['Error setting orientationArray.\\n', 'You have to specify the stick orientation']);\n    }\n    hash = `stm${pointData.getArray(model.renderable.getOrientationArray()).getMTime()}float32x3`;\n    if (!device.getBufferManager().hasBuffer(hash)) {\n      const buffRequest = {\n        hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      };\n      // xyz v1 v2 v3\n      const tmpVBO = new Float32Array(numPoints * 3);\n      let pointIdx = 0;\n      let vboIdx = 0;\n      for (let id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        let length = model.renderable.getLength();\n        if (scales) {\n          length = scales[id * 2];\n        }\n        tmpVBO[vboIdx++] = orientationArray[pointIdx] * length;\n        tmpVBO[vboIdx++] = orientationArray[pointIdx + 1] * length;\n        tmpVBO[vboIdx++] = orientationArray[pointIdx + 2] * length;\n      }\n      buffRequest.nativeArray = tmpVBO;\n      const buff = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['orientMC'], 'instance');\n    }\n\n    // deal with colors but only if modified\n    let haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      const c = model.renderable.getColorMapColors();\n      if (c) {\n        hash = `stm${c.getMTime()}unorm8x4`;\n        if (!device.getBufferManager().hasBuffer(hash)) {\n          const buffRequest = {\n            usage: BufferUsage.RawVertex,\n            format: 'unorm8x4'\n          };\n          const colorComponents = c.getNumberOfComponents();\n          if (colorComponents !== 4) {\n            vtkErrorMacro('this should be 4');\n          }\n          const tmpVBO = new Uint8ClampedArray(numPoints * 4);\n          let vboIdx = 0;\n          const colorData = c.getData();\n          for (let id = 0; id < numPoints; ++id) {\n            const colorIdx = id * colorComponents;\n            tmpVBO[vboIdx++] = colorData[colorIdx];\n            tmpVBO[vboIdx++] = colorData[colorIdx + 1];\n            tmpVBO[vboIdx++] = colorData[colorIdx + 2];\n            tmpVBO[vboIdx++] = colorData[colorIdx + 3];\n          }\n          buffRequest.nativeArray = tmpVBO;\n          const buff = device.getBufferManager().getBuffer(buffRequest);\n          vertexInput.addBuffer(buff, ['colorVI'], 'instance');\n        }\n        haveColors = true;\n      }\n    }\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n    publicAPI.setTopology('triangle-list');\n    publicAPI.updateUBO();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUCellArrayMapper.extend(publicAPI, model, initialValues);\n  publicAPI.setVertexShaderTemplate(vtkWebGPUStickMapperVS);\n\n  // Object methods\n  vtkWebGPUStickMapper(publicAPI, model);\n  const sr = model.shaderReplacements;\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  sr.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUStickMapper');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkStickMapper', newInstance);\nexport { index as default, extend, newInstance };","map":{"version":3,"names":["n","newInstance$1","c","macro","vtkWebGPUCellArrayMapper","vtkWebGPUBufferManager","vtkWebGPUShaderCache","registerOverride","BufferUsage","vtkErrorMacro","vtkWebGPUStickMapperVS","vtkWebGPUStickMapper","publicAPI","model","classHierarchy","push","cellMapperBuildPass","buildPass","prepass","renderable","getStatic","update","poly","getInputData","setCellArray","getVerts","setCurrentInput","replaceShaderNormal","hash","pipeline","vertexInput","vDesc","getShaderDescription","hasOutput","addOutput","addBuiltinInput","fDesc","addBuiltinOutput","stickFrag","code","getCode","substitute","result","setCode","replaceShaderPosition","computePipelineHash","pipelineHash","hasAttribute","renderEncoder","getPipelineHash","updateBuffers","currentInput","mapScalars","device","points","getPoints","pointData","getPointData","numPoints","getNumberOfPoints","pointArray","getData","setNumberOfInstances","setNumberOfVertices","getMTime","getBufferManager","hasBuffer","buffRequest","usage","RawVertex","format","tmpVBO","Float32Array","pointIdx","vboIdx","id","nativeArray","buff","getBuffer","addBuffer","scales","getScaleArray","hasArray","getArray","defaultRadius","getRadius","_lastRadius","radius","orientationArray","getOrientationArray","length","getLength","haveColors","getScalarVisibility","getColorMapColors","colorComponents","getNumberOfComponents","Uint8ClampedArray","colorData","colorIdx","removeBufferIfPresent","setTopology","updateUBO","DEFAULT_VALUES","extend","initialValues","arguments","undefined","Object","assign","setVertexShaderTemplate","sr","shaderReplacements","set","newInstance","index","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Rendering/WebGPU/StickMapper.js"],"sourcesContent":["import { n as newInstance$1, c as macro } from '../../macros2.js';\nimport vtkWebGPUCellArrayMapper from './CellArrayMapper.js';\nimport vtkWebGPUBufferManager from './BufferManager.js';\nimport vtkWebGPUShaderCache from './ShaderCache.js';\nimport { registerOverride } from './ViewNodeFactory.js';\n\nconst {\n  BufferUsage\n} = vtkWebGPUBufferManager;\nconst {\n  vtkErrorMacro\n} = macro;\n\n// Vertices\n// 013 - 032 - 324 - 453\n//\n//       _.4---_.5\n//    .-*   .-*\n//   2-----3\n//   |    /|\n//   |   / |\n//   |  /  |\n//   | /   |\n//   |/    |\n//   0-----1\n//\n// coord for each points\n// 0: 000\n// 1: 100\n// 2: 001\n// 3: 101\n// 4: 011\n// 5: 111\n\nconst vtkWebGPUStickMapperVS = `\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::Color::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var offsetsArray: array<vec3<f32>, 12> = array<vec3<f32>, 12>(\n    vec3<f32>(-1.0, -1.0, -1.0),\n    vec3<f32>(1.0, -1.0, -1.0),\n    vec3<f32>(1.0, -1.0, 1.0),\n\n    vec3<f32>(-1.0, -1.0, -1.0),\n    vec3<f32>(1.0, -1.0, 1.0),\n    vec3<f32>(-1.0, -1.0, 1.0),\n\n    vec3<f32>(-1.0, -1.0, 1.0),\n    vec3<f32>(1.0, -1.0, 1.0),\n    vec3<f32>(1.0, 1.0, 1.0),\n\n    vec3<f32>(-1.0, -1.0, 1.0),\n    vec3<f32>(1.0, 1.0, 1.0),\n    vec3<f32>(-1.0, 1.0, 1.0)\n  );\n\n  var output : vertexOutput;\n\n  var vertexVC: vec4<f32> = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);\n\n  //VTK::Color::Impl\n\n  // compute the projected vertex position\n  output.centerVC = vertexVC.xyz;\n  output.radiusVC = radiusMC;\n  output.lengthVC = length(orientMC);\n  output.orientVC = (rendererUBO.WCVCNormals * vec4<f32>(normalize(orientMC), 0.0)).xyz;\n\n  // make sure it is pointing out of the screen\n  if (output.orientVC.z < 0.0)\n    {\n    output.orientVC = -output.orientVC;\n    }\n\n  // make the basis\n  var xbase: vec3<f32>;\n  var ybase: vec3<f32>;\n  var dir: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\n  if (rendererUBO.cameraParallel == 0u)\n    {\n    dir = normalize(-vertexVC.xyz);\n    }\n  if (abs(dot(dir,output.orientVC)) == 1.0)\n    {\n    xbase = normalize(cross(vec3<f32>(0.0,1.0,0.0),output.orientVC));\n    ybase = cross(xbase,output.orientVC);\n    }\n  else\n    {\n    xbase = normalize(cross(output.orientVC,dir));\n    ybase = cross(output.orientVC,xbase);\n    }\n\n\n  var vertIdx: u32 = input.vertexIndex % 12u;\n  var offsets: vec3<f32> = offsetsArray[vertIdx];\n\n  vertexVC = vec4<f32>(vertexVC.xyz +\n    output.radiusVC * offsets.x * xbase +\n    output.radiusVC * offsets.y * ybase +\n    0.5 * output.lengthVC * offsets.z * output.orientVC, 1.0);\n\n  output.vertexVC = vertexVC;\n\n  //VTK::Position::Impl\n\n  return output;\n}\n`;\n\n// ----------------------------------------------------------------------------\n// vtkWebGPUStickMapper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkWebGPUStickMapper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkWebGPUStickMapper');\n  const cellMapperBuildPass = publicAPI.buildPass;\n  publicAPI.buildPass = prepass => {\n    if (prepass) {\n      if (!model.renderable.getStatic()) {\n        model.renderable.update();\n      }\n      const poly = model.renderable.getInputData();\n      publicAPI.setCellArray(poly.getVerts());\n      publicAPI.setCurrentInput(poly);\n    }\n    cellMapperBuildPass(prepass);\n  };\n  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');\n    vDesc.addOutput('vec3<f32>', 'centerVC');\n    vDesc.addOutput('vec3<f32>', 'orientVC');\n    vDesc.addOutput('f32', 'radiusVC');\n    vDesc.addOutput('f32', 'lengthVC');\n    vDesc.addBuiltinInput('u32', '@builtin(vertex_index) vertexIndex');\n    const fDesc = pipeline.getShaderDescription('fragment');\n    fDesc.addBuiltinOutput('f32', '@builtin(frag_depth) fragDepth');\n    const stickFrag = `\n    // compute the eye position and unit direction\n    var vertexVC: vec4<f32>;\n    var EyePos: vec3<f32>;\n    var EyeDir: vec3<f32>;\n\n    if (rendererUBO.cameraParallel != 0u)\n    {\n      EyePos = vec3<f32>(input.vertexVC.x, input.vertexVC.y, input.vertexVC.z + 3.0*input.radiusVC);\n      EyeDir = vec3<f32>(0.0, 0.0, -1.0);\n    }\n    else\n    {\n      EyeDir = input.vertexVC.xyz;\n      EyePos = vec3<f32>(0.0,0.0,0.0);\n      var lengthED: f32 = length(EyeDir);\n      EyeDir = normalize(EyeDir);\n      // we adjust the EyePos to be closer if it is too far away\n      // to prevent floating point precision noise\n      if (lengthED > input.radiusVC*3.0)\n      {\n        EyePos = input.vertexVC.xyz - EyeDir*3.0*input.radiusVC;\n      }\n    }\n    // translate to Sphere center\n    EyePos = EyePos - input.centerVC;\n\n    // rotate to new basis\n    // base1, base2, orientVC\n    var base1: vec3<f32>;\n    if (abs(input.orientVC.z) < 0.99)\n    {\n      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,0.0,1.0)));\n    }\n    else\n    {\n      base1 = normalize(cross(input.orientVC,vec3<f32>(0.0,1.0,0.0)));\n    }\n    var base2: vec3<f32> = cross(input.orientVC,base1);\n    EyePos = vec3<f32>(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,input.orientVC));\n    EyeDir = vec3<f32>(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,input.orientVC));\n\n    // scale to radius 1.0\n    EyePos = EyePos * (1.0 / input.radiusVC);\n\n    // find the intersection\n    var a: f32 = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n    var b: f32 = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n    var c: f32 = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n    var d: f32 = b*b - 4.0*a*c;\n    var normal: vec3<f32> = vec3<f32>(0.0,0.0,1.0);\n    if (d < 0.0) { discard; }\n    else\n    {\n      var t: f32 = (-b - sqrt(d))*(0.5 / a);\n      var tz: f32 = EyePos.z + t*EyeDir.z;\n      var iPoint: vec3<f32> = EyePos + t*EyeDir;\n      if (abs(iPoint.z)*input.radiusVC > input.lengthVC*0.5)\n      {\n        // test for end cap\n        var t2: f32 = (-b + sqrt(d))*(0.5 / a);\n        var tz2: f32 = EyePos.z + t2*EyeDir.z;\n        if (tz2*input.radiusVC > input.lengthVC*0.5 || tz*input.radiusVC < -0.5*input.lengthVC) { discard; }\n        else\n        {\n          normal = input.orientVC;\n          var t3: f32 = (input.lengthVC*0.5/input.radiusVC - EyePos.z)/EyeDir.z;\n          iPoint = EyePos + t3*EyeDir;\n          vertexVC = vec4<f32>(input.radiusVC*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*input.orientVC) + input.centerVC, 1.0);\n        }\n      }\n      else\n      {\n        // The normal is the iPoint.xy rotated back into VC\n        normal = iPoint.x*base1 + iPoint.y*base2;\n        // rescale rerotate and translate\n        vertexVC = vec4<f32>(input.radiusVC*(normal + iPoint.z*input.orientVC) + input.centerVC, 1.0);\n      }\n    }\n    // compute the pixel's depth\n    var pos: vec4<f32> = rendererUBO.VCPCMatrix * vertexVC;\n    output.fragDepth = pos.z / pos.w;\n  `;\n    let code = fDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', [stickFrag]).result;\n    fDesc.setCode(code);\n  };\n  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {\n    const vDesc = pipeline.getShaderDescription('vertex');\n    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');\n    let code = vDesc.getCode();\n    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['  output.Position = rendererUBO.VCPCMatrix*vertexVC;']).result;\n    vDesc.setCode(code);\n  };\n\n  // compute a unique hash for a pipeline, this needs to be unique enough to\n  // capture any pipeline code changes (which includes shader changes)\n  // or vertex input changes/ bind groups/ etc\n  publicAPI.computePipelineHash = () => {\n    model.pipelineHash = 'stm';\n    if (model.vertexInput.hasAttribute(`colorVI`)) {\n      model.pipelineHash += `c`;\n    }\n    model.pipelineHash += model.renderEncoder.getPipelineHash();\n  };\n  publicAPI.updateBuffers = () => {\n    const poly = model.currentInput;\n    model.renderable.mapScalars(poly, 1.0);\n    const device = model.device;\n    const points = poly.getPoints();\n    const pointData = poly.getPointData();\n    const numPoints = points.getNumberOfPoints();\n    const pointArray = points.getData();\n    publicAPI.setNumberOfInstances(numPoints);\n    publicAPI.setNumberOfVertices(12);\n    const vertexInput = model.vertexInput;\n    let hash = `stm${points.getMTime()}float32x3`;\n    if (!device.getBufferManager().hasBuffer(hash)) {\n      const buffRequest = {\n        hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      };\n      // xyz v1 v2 v3\n      const tmpVBO = new Float32Array(numPoints * 3);\n      let pointIdx = 0;\n      let vboIdx = 0;\n      for (let id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        tmpVBO[vboIdx++] = pointArray[pointIdx];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 1];\n        tmpVBO[vboIdx++] = pointArray[pointIdx + 2];\n      }\n      buffRequest.nativeArray = tmpVBO;\n      const buff = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['vertexBC'], 'instance');\n    }\n\n    // compute offset VBO\n    let scales = null;\n    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {\n      scales = pointData.getArray(model.renderable.getScaleArray()).getData();\n    }\n    const defaultRadius = model.renderable.getRadius();\n    if (scales || defaultRadius !== model._lastRadius) {\n      hash = `stm${scales ? pointData.getArray(model.renderable.getScaleArray()).getMTime() : defaultRadius}float32`;\n      if (!device.getBufferManager().hasBuffer(hash)) {\n        const buffRequest = {\n          hash,\n          usage: BufferUsage.RawVertex,\n          format: 'float32'\n        };\n        const tmpVBO = new Float32Array(numPoints);\n        let vboIdx = 0;\n        for (let id = 0; id < numPoints; ++id) {\n          let radius = model.renderable.getRadius();\n          if (scales) {\n            radius = scales[id * 2 + 1];\n          }\n          tmpVBO[vboIdx++] = radius;\n        }\n        buffRequest.nativeArray = tmpVBO;\n        const buff = device.getBufferManager().getBuffer(buffRequest);\n        vertexInput.addBuffer(buff, ['radiusMC'], 'instance');\n      }\n      model._lastRadius = defaultRadius;\n    }\n    let orientationArray = null;\n    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {\n      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();\n    } else {\n      vtkErrorMacro(['Error setting orientationArray.\\n', 'You have to specify the stick orientation']);\n    }\n    hash = `stm${pointData.getArray(model.renderable.getOrientationArray()).getMTime()}float32x3`;\n    if (!device.getBufferManager().hasBuffer(hash)) {\n      const buffRequest = {\n        hash,\n        usage: BufferUsage.RawVertex,\n        format: 'float32x3'\n      };\n      // xyz v1 v2 v3\n      const tmpVBO = new Float32Array(numPoints * 3);\n      let pointIdx = 0;\n      let vboIdx = 0;\n      for (let id = 0; id < numPoints; ++id) {\n        pointIdx = id * 3;\n        let length = model.renderable.getLength();\n        if (scales) {\n          length = scales[id * 2];\n        }\n        tmpVBO[vboIdx++] = orientationArray[pointIdx] * length;\n        tmpVBO[vboIdx++] = orientationArray[pointIdx + 1] * length;\n        tmpVBO[vboIdx++] = orientationArray[pointIdx + 2] * length;\n      }\n      buffRequest.nativeArray = tmpVBO;\n      const buff = device.getBufferManager().getBuffer(buffRequest);\n      vertexInput.addBuffer(buff, ['orientMC'], 'instance');\n    }\n\n    // deal with colors but only if modified\n    let haveColors = false;\n    if (model.renderable.getScalarVisibility()) {\n      const c = model.renderable.getColorMapColors();\n      if (c) {\n        hash = `stm${c.getMTime()}unorm8x4`;\n        if (!device.getBufferManager().hasBuffer(hash)) {\n          const buffRequest = {\n            usage: BufferUsage.RawVertex,\n            format: 'unorm8x4'\n          };\n          const colorComponents = c.getNumberOfComponents();\n          if (colorComponents !== 4) {\n            vtkErrorMacro('this should be 4');\n          }\n          const tmpVBO = new Uint8ClampedArray(numPoints * 4);\n          let vboIdx = 0;\n          const colorData = c.getData();\n          for (let id = 0; id < numPoints; ++id) {\n            const colorIdx = id * colorComponents;\n            tmpVBO[vboIdx++] = colorData[colorIdx];\n            tmpVBO[vboIdx++] = colorData[colorIdx + 1];\n            tmpVBO[vboIdx++] = colorData[colorIdx + 2];\n            tmpVBO[vboIdx++] = colorData[colorIdx + 3];\n          }\n          buffRequest.nativeArray = tmpVBO;\n          const buff = device.getBufferManager().getBuffer(buffRequest);\n          vertexInput.addBuffer(buff, ['colorVI'], 'instance');\n        }\n        haveColors = true;\n      }\n    }\n    if (!haveColors) {\n      vertexInput.removeBufferIfPresent('colorVI');\n    }\n    publicAPI.setTopology('triangle-list');\n    publicAPI.updateUBO();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkWebGPUCellArrayMapper.extend(publicAPI, model, initialValues);\n  publicAPI.setVertexShaderTemplate(vtkWebGPUStickMapperVS);\n\n  // Object methods\n  vtkWebGPUStickMapper(publicAPI, model);\n  const sr = model.shaderReplacements;\n  sr.set('replaceShaderPosition', publicAPI.replaceShaderPosition);\n  sr.set('replaceShaderNormal', publicAPI.replaceShaderNormal);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkWebGPUStickMapper');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\n// Register ourself to WebGPU backend if imported\nregisterOverride('vtkStickMapper', newInstance);\n\nexport { index as default, extend, newInstance };\n"],"mappings":";;;;;;;AAAA,SAASA,CAAC,IAAIC,aAAa,EAAEC,CAAC,IAAIC,KAAK,QAAQ,kBAAkB;AACjE,OAAOC,wBAAwB,MAAM,sBAAsB;AAC3D,OAAOC,sBAAsB,MAAM,oBAAoB;AACvD,OAAOC,oBAAoB,MAAM,kBAAkB;AACnD,SAASC,gBAAgB,QAAQ,sBAAsB;AAEvD,MAAM;EACJC;AACF,CAAC,GAAGH,sBAAsB;AAC1B,MAAM;EACJI;AACF,CAAC,GAAGN,KAAK;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMO,sBAAsB,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,SAASC,oBAAoBA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAC9C;EACAA,KAAK,CAACC,cAAc,CAACC,IAAI,CAAC,sBAAsB,CAAC;EACjD,MAAMC,mBAAmB,GAAGJ,SAAS,CAACK,SAAS;EAC/CL,SAAS,CAACK,SAAS,GAAGC,OAAO,IAAI;IAC/B,IAAIA,OAAO,EAAE;MACX,IAAI,CAACL,KAAK,CAACM,UAAU,CAACC,SAAS,CAAC,CAAC,EAAE;QACjCP,KAAK,CAACM,UAAU,CAACE,MAAM,CAAC,CAAC;MAC3B;MACA,MAAMC,IAAI,GAAGT,KAAK,CAACM,UAAU,CAACI,Y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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}