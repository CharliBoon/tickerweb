{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkCompositeKeyboardManipulator from './CompositeKeyboardManipulator.js';\nimport { k as add, l as normalize, j as cross } from '../../Common/Core/Math/index.js';\nconst {\n  vtkErrorMacro\n} = macro;\nconst ANIMATION_REQUESTER = 'vtkKeyboardCameraManipulator';\n\n// ----------------------------------------------------------------------------\n// vtkKeyboardCameraManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkKeyboardCameraManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkKeyboardCameraManipulator');\n  const internal = {\n    keysDown: [],\n    direction: [0, 0, 0],\n    skipUpdateDirection: false,\n    animationSub: null,\n    cameraModifiedSub: null\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.inMotion = () => internal.animationSub !== null;\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.resetMovementSpeed = () => {\n    // Reset the movement speed to be proportional to the longest length\n    // of the renderer's bounds.\n    const {\n      renderer\n    } = model;\n    const bounds = renderer.computeVisiblePropBounds();\n\n    // Just a number that seems to work okay for our examples...\n    const divisor = 500;\n    model.movementSpeed = vtkBoundingBox.getMaxLength(bounds) / divisor;\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.startMovement = () => {\n    if (publicAPI.inMotion()) {\n      vtkErrorMacro('Camera is already in motion!');\n      return;\n    }\n    if (model.movementSpeed === null) {\n      publicAPI.resetMovementSpeed();\n    }\n    const {\n      interactor,\n      renderer\n    } = model;\n    const move = () => {\n      if (internal.keysDown.length === 0) {\n        return;\n      }\n\n      // No need to update the direction when we move the camera here...\n      internal.skipUpdateDirection = true;\n      publicAPI.moveCamera(renderer.getActiveCamera(), internal.direction, model.movementSpeed);\n      renderer.resetCameraClippingRange();\n      if (interactor.getLightFollowCamera()) {\n        renderer.updateLightsGeometryToFollowCamera();\n      }\n      internal.skipUpdateDirection = false;\n    };\n    publicAPI.calculateCurrentDirection();\n    const camera = renderer.getActiveCamera();\n    // If the camera gets modified elsewhere, let's update the direction\n    internal.cameraModifiedSub = camera.onModified(publicAPI.calculateCurrentDirection);\n    interactor.requestAnimation(ANIMATION_REQUESTER);\n    internal.animationSub = interactor.onAnimation(() => move());\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.endMovement = () => {\n    if (internal.animationSub) {\n      internal.animationSub.unsubscribe();\n      internal.animationSub = null;\n    }\n    model._interactor.cancelAnimation(ANIMATION_REQUESTER);\n    if (internal.cameraModifiedSub) {\n      internal.cameraModifiedSub.unsubscribe();\n      internal.cameraModifiedSub = null;\n    }\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.calculateCurrentDirection = () => {\n    if (internal.skipUpdateDirection) {\n      return;\n    }\n\n    // Reset\n    internal.direction = [0, 0, 0];\n    const {\n      renderer\n    } = model;\n    if (!renderer) {\n      return;\n    }\n    const camera = renderer.getActiveCamera();\n    if (!camera) {\n      return;\n    }\n    if (internal.keysDown.length === 0) {\n      return;\n    }\n    let directions = internal.keysDown.map(key => publicAPI.getDirectionFromKey(key, camera));\n    directions = directions.filter(item => item);\n    if (directions.length === 0) {\n      return;\n    }\n    const netDirection = directions.reduce((a, b) => {\n      add(a, b, b);\n      return b;\n    });\n    normalize(netDirection);\n    internal.direction = netDirection;\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.getDirectionFromKey = (key, camera) => {\n    let direction;\n    if (model.moveForwardKeys.includes(key)) {\n      // Move forward\n      direction = camera.getDirectionOfProjection();\n    } else if (model.moveLeftKeys.includes(key)) {\n      // Move left\n      const dirProj = camera.getDirectionOfProjection();\n      direction = [0, 0, 0];\n      cross(camera.getViewUp(), dirProj, direction);\n    } else if (model.moveBackwardKeys.includes(key)) {\n      // Move backward\n      direction = camera.getDirectionOfProjection().map(e => -e);\n    } else if (model.moveRightKeys.includes(key)) {\n      // Move right\n      const dirProj = camera.getDirectionOfProjection();\n      direction = [0, 0, 0];\n      cross(dirProj, camera.getViewUp(), direction);\n    } else if (model.moveUpKeys.includes(key)) {\n      // Move up\n      direction = camera.getViewUp();\n    } else if (model.moveDownKeys.includes(key)) {\n      // Move down\n      direction = camera.getViewUp().map(e => -e);\n    } else {\n      return undefined;\n    }\n    normalize(direction);\n    return direction;\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.moveCamera = (camera, direction, speed) => {\n    const position = camera.getPosition();\n    const focalPoint = camera.getFocalPoint();\n    camera.setFocalPoint(focalPoint[0] + direction[0] * speed, focalPoint[1] + direction[1] * speed, focalPoint[2] + direction[2] * speed);\n    camera.setPosition(position[0] + direction[0] * speed, position[1] + direction[1] * speed, position[2] + direction[2] * speed);\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onKeyPress = (interactor, renderer, key) => {};\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onKeyDown = (interactor, renderer, key) => {\n    if (!internal.keysDown.includes(key)) {\n      internal.keysDown.push(key);\n      publicAPI.calculateCurrentDirection();\n    }\n    if (!publicAPI.inMotion()) {\n      Object.assign(model, {\n        interactor,\n        renderer\n      });\n      publicAPI.startMovement();\n    }\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onKeyUp = (interactor, renderer, key) => {\n    // The following is case insensitive for when the user\n    // presses/releases the shift key while this key is down.\n    internal.keysDown = internal.keysDown.filter(item => item.toUpperCase() !== key.toUpperCase());\n    publicAPI.calculateCurrentDirection();\n    if (internal.keysDown.length === 0) {\n      publicAPI.endMovement();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // The movementSpeed is the magnitude of the camera translation\n  // for each animation frame (which occur each 1/60 second)\n  // If null, publicAPI.resetMovementSpeed() will be called when\n  // movement starts.\n  movementSpeed: null,\n  moveForwardKeys: ['w', 'W', 'ArrowUp'],\n  moveLeftKeys: ['a', 'A', 'ArrowLeft'],\n  moveBackwardKeys: ['s', 'S', 'ArrowDown'],\n  moveRightKeys: ['d', 'D', 'ArrowRight'],\n  moveUpKeys: [' '],\n  moveDownKeys: ['Shift'],\n  interactor: null,\n  renderer: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeKeyboardManipulator.extend(publicAPI, model, initialValues);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['movementSpeed', 'moveForwardKeys', 'moveLeftKeys', 'moveBackwardKeys', 'moveRightKeys', 'moveUpKeys', 'moveDownKeys', 'interactor', 'renderer']);\n\n  // Object specific methods\n  vtkKeyboardCameraManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkKeyboardCameraManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkKeyboardCameraManipulator$1 = {\n  newInstance,\n  extend\n};\nexport { vtkKeyboardCameraManipulator$1 as default, extend, newInstance };","map":{"version":3,"names":["m","macro","vtkBoundingBox","vtkCompositeKeyboardManipulator","k","add","l","normalize","j","cross","vtkErrorMacro","ANIMATION_REQUESTER","vtkKeyboardCameraManipulator","publicAPI","model","classHierarchy","push","internal","keysDown","direction","skipUpdateDirection","animationSub","cameraModifiedSub","inMotion","resetMovementSpeed","renderer","bounds","computeVisiblePropBounds","divisor","movementSpeed","getMaxLength","startMovement","interactor","move","length","moveCamera","getActiveCamera","resetCameraClippingRange","getLightFollowCamera","updateLightsGeometryToFollowCamera","calculateCurrentDirection","camera","onModified","requestAnimation","onAnimation","endMovement","unsubscribe","_interactor","cancelAnimation","directions","map","key","getDirectionFromKey","filter","item","netDirection","reduce","a","b","moveForwardKeys","includes","getDirectionOfProjection","moveLeftKeys","dirProj","getViewUp","moveBackwardKeys","e","moveRightKeys","moveUpKeys","moveDownKeys","undefined","speed","position","getPosition","focalPoint","getFocalPoint","setFocalPoint","setPosition","onKeyPress","onKeyDown","Object","assign","onKeyUp","toUpperCase","DEFAULT_VALUES","extend","initialValues","arguments","obj","setGet","newInstance","vtkKeyboardCameraManipulator$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Interaction/Manipulators/KeyboardCameraManipulator.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkCompositeKeyboardManipulator from './CompositeKeyboardManipulator.js';\nimport { k as add, l as normalize, j as cross } from '../../Common/Core/Math/index.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst ANIMATION_REQUESTER = 'vtkKeyboardCameraManipulator';\n\n// ----------------------------------------------------------------------------\n// vtkKeyboardCameraManipulator methods\n// ----------------------------------------------------------------------------\n\nfunction vtkKeyboardCameraManipulator(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkKeyboardCameraManipulator');\n  const internal = {\n    keysDown: [],\n    direction: [0, 0, 0],\n    skipUpdateDirection: false,\n    animationSub: null,\n    cameraModifiedSub: null\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.inMotion = () => internal.animationSub !== null;\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.resetMovementSpeed = () => {\n    // Reset the movement speed to be proportional to the longest length\n    // of the renderer's bounds.\n    const {\n      renderer\n    } = model;\n    const bounds = renderer.computeVisiblePropBounds();\n\n    // Just a number that seems to work okay for our examples...\n    const divisor = 500;\n    model.movementSpeed = vtkBoundingBox.getMaxLength(bounds) / divisor;\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.startMovement = () => {\n    if (publicAPI.inMotion()) {\n      vtkErrorMacro('Camera is already in motion!');\n      return;\n    }\n    if (model.movementSpeed === null) {\n      publicAPI.resetMovementSpeed();\n    }\n    const {\n      interactor,\n      renderer\n    } = model;\n    const move = () => {\n      if (internal.keysDown.length === 0) {\n        return;\n      }\n\n      // No need to update the direction when we move the camera here...\n      internal.skipUpdateDirection = true;\n      publicAPI.moveCamera(renderer.getActiveCamera(), internal.direction, model.movementSpeed);\n      renderer.resetCameraClippingRange();\n      if (interactor.getLightFollowCamera()) {\n        renderer.updateLightsGeometryToFollowCamera();\n      }\n      internal.skipUpdateDirection = false;\n    };\n    publicAPI.calculateCurrentDirection();\n    const camera = renderer.getActiveCamera();\n    // If the camera gets modified elsewhere, let's update the direction\n    internal.cameraModifiedSub = camera.onModified(publicAPI.calculateCurrentDirection);\n    interactor.requestAnimation(ANIMATION_REQUESTER);\n    internal.animationSub = interactor.onAnimation(() => move());\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.endMovement = () => {\n    if (internal.animationSub) {\n      internal.animationSub.unsubscribe();\n      internal.animationSub = null;\n    }\n    model._interactor.cancelAnimation(ANIMATION_REQUESTER);\n    if (internal.cameraModifiedSub) {\n      internal.cameraModifiedSub.unsubscribe();\n      internal.cameraModifiedSub = null;\n    }\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.calculateCurrentDirection = () => {\n    if (internal.skipUpdateDirection) {\n      return;\n    }\n\n    // Reset\n    internal.direction = [0, 0, 0];\n    const {\n      renderer\n    } = model;\n    if (!renderer) {\n      return;\n    }\n    const camera = renderer.getActiveCamera();\n    if (!camera) {\n      return;\n    }\n    if (internal.keysDown.length === 0) {\n      return;\n    }\n    let directions = internal.keysDown.map(key => publicAPI.getDirectionFromKey(key, camera));\n    directions = directions.filter(item => item);\n    if (directions.length === 0) {\n      return;\n    }\n    const netDirection = directions.reduce((a, b) => {\n      add(a, b, b);\n      return b;\n    });\n    normalize(netDirection);\n    internal.direction = netDirection;\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.getDirectionFromKey = (key, camera) => {\n    let direction;\n    if (model.moveForwardKeys.includes(key)) {\n      // Move forward\n      direction = camera.getDirectionOfProjection();\n    } else if (model.moveLeftKeys.includes(key)) {\n      // Move left\n      const dirProj = camera.getDirectionOfProjection();\n      direction = [0, 0, 0];\n      cross(camera.getViewUp(), dirProj, direction);\n    } else if (model.moveBackwardKeys.includes(key)) {\n      // Move backward\n      direction = camera.getDirectionOfProjection().map(e => -e);\n    } else if (model.moveRightKeys.includes(key)) {\n      // Move right\n      const dirProj = camera.getDirectionOfProjection();\n      direction = [0, 0, 0];\n      cross(dirProj, camera.getViewUp(), direction);\n    } else if (model.moveUpKeys.includes(key)) {\n      // Move up\n      direction = camera.getViewUp();\n    } else if (model.moveDownKeys.includes(key)) {\n      // Move down\n      direction = camera.getViewUp().map(e => -e);\n    } else {\n      return undefined;\n    }\n    normalize(direction);\n    return direction;\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.moveCamera = (camera, direction, speed) => {\n    const position = camera.getPosition();\n    const focalPoint = camera.getFocalPoint();\n    camera.setFocalPoint(focalPoint[0] + direction[0] * speed, focalPoint[1] + direction[1] * speed, focalPoint[2] + direction[2] * speed);\n    camera.setPosition(position[0] + direction[0] * speed, position[1] + direction[1] * speed, position[2] + direction[2] * speed);\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onKeyPress = (interactor, renderer, key) => {};\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onKeyDown = (interactor, renderer, key) => {\n    if (!internal.keysDown.includes(key)) {\n      internal.keysDown.push(key);\n      publicAPI.calculateCurrentDirection();\n    }\n    if (!publicAPI.inMotion()) {\n      Object.assign(model, {\n        interactor,\n        renderer\n      });\n      publicAPI.startMovement();\n    }\n  };\n\n  //--------------------------------------------------------------------------\n\n  publicAPI.onKeyUp = (interactor, renderer, key) => {\n    // The following is case insensitive for when the user\n    // presses/releases the shift key while this key is down.\n    internal.keysDown = internal.keysDown.filter(item => item.toUpperCase() !== key.toUpperCase());\n    publicAPI.calculateCurrentDirection();\n    if (internal.keysDown.length === 0) {\n      publicAPI.endMovement();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // The movementSpeed is the magnitude of the camera translation\n  // for each animation frame (which occur each 1/60 second)\n  // If null, publicAPI.resetMovementSpeed() will be called when\n  // movement starts.\n  movementSpeed: null,\n  moveForwardKeys: ['w', 'W', 'ArrowUp'],\n  moveLeftKeys: ['a', 'A', 'ArrowLeft'],\n  moveBackwardKeys: ['s', 'S', 'ArrowDown'],\n  moveRightKeys: ['d', 'D', 'ArrowRight'],\n  moveUpKeys: [' '],\n  moveDownKeys: ['Shift'],\n  interactor: null,\n  renderer: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  vtkCompositeKeyboardManipulator.extend(publicAPI, model, initialValues);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['movementSpeed', 'moveForwardKeys', 'moveLeftKeys', 'moveBackwardKeys', 'moveRightKeys', 'moveUpKeys', 'moveDownKeys', 'interactor', 'renderer']);\n\n  // Object specific methods\n  vtkKeyboardCameraManipulator(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkKeyboardCameraManipulator');\n\n// ----------------------------------------------------------------------------\n\nvar vtkKeyboardCameraManipulator$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkKeyboardCameraManipulator$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}