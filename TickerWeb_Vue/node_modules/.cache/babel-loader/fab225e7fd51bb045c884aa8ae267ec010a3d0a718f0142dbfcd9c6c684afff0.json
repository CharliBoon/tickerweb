{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkImplicitFunction from './ImplicitFunction.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Bounding box intersection code from David Gobbi.  Go through the\n// bounding planes one at a time and compute the parametric coordinate\n// of each intersection and return the parametric values and the calculated points\nfunction intersectWithLine(bounds, p1, p2) {\n  let plane1 = -1;\n  let plane2 = -1;\n  let t1 = 0.0;\n  let t2 = 1.0;\n  for (let j = 0; j < 3; j++) {\n    for (let k = 0; k < 2; k++) {\n      // Compute distances of p1 and p2 from the plane along the plane normal\n      const i = 2 * j + k;\n      const d1 = (bounds[i] - p1[j]) * (1 - 2 * k);\n      const d2 = (bounds[i] - p2[j]) * (1 - 2 * k);\n\n      // If both distances are positive, both points are outside\n      if (d1 > 0 && d2 > 0) {\n        return;\n      }\n      // If one of the distances is positive, the line crosses the plane\n      if (d1 > 0 || d2 > 0) {\n        // Compute fractional distance \"t\" of the crossing between p1 & p2\n        let t = 0.0;\n        if (d1 !== 0) {\n          t = d1 / (d1 - d2);\n        }\n\n        // If point p1 was clipped, adjust t1\n        if (d1 > 0) {\n          if (t >= t1) {\n            t1 = t;\n            plane1 = i;\n          }\n        }\n        // else point p2 was clipped, so adjust t2\n        else if (t <= t2) {\n          t2 = t;\n          plane2 = i;\n        }\n        // If this happens, there's no line left\n        if (t1 > t2) {\n          // Allow for planes that are coincident or slightly inverted\n          if (plane1 < 0 || plane2 < 0) {\n            return;\n          }\n        }\n      }\n    }\n  }\n  function getValues(plane, t) {\n    const x = [0, 0, 0];\n    for (let count = 0; count < 2; count++) {\n      for (let i = 0; i < 3; i++) {\n        if (plane === 2 * i || plane === 2 * i + 1) {\n          x[i] = bounds[plane];\n        } else {\n          x[i] = p1[i] * (1.0 - t) + p2[i] * t;\n          if (x[i] < bounds[2 * i]) {\n            x[i] = bounds[2 * i];\n          }\n          if (x[i] > bounds[2 * i + 1]) {\n            x[i] = bounds[2 * i + 1];\n          }\n        }\n      }\n    }\n    return x;\n  }\n  const x1 = getValues(plane1, t1);\n  const x2 = getValues(plane2, t2);\n  const outObject = {\n    t1,\n    t2,\n    x1,\n    x2\n  };\n\n  // eslint-disable-next-line consistent-return\n  return outObject;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {};\n\n// ----------------------------------------------------------------------------\n// vtkBox methods\n// ----------------------------------------------------------------------------\nfunction vtkBox(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkBox');\n\n  // TODO: replace with macro.setArray ?\n  publicAPI.setBounds = function () {\n    let boundsArray = [];\n    for (var _len = arguments.length, bounds = new Array(_len), _key = 0; _key < _len; _key++) {\n      bounds[_key] = arguments[_key];\n    }\n    if (Array.isArray(bounds[0])) {\n      boundsArray = bounds[0];\n    } else {\n      for (let i = 0; i < bounds.length; i++) {\n        boundsArray.push(bounds[i]);\n      }\n    }\n    if (boundsArray.length !== 6) {\n      console.log('vtkBox.setBounds', boundsArray, bounds);\n      return;\n    }\n    vtkBoundingBox.setBounds(model.bbox, boundsArray);\n  };\n  publicAPI.getBounds = () => model.bbox;\n  publicAPI.evaluateFunction = (x, y, z) => {\n    const point = Array.isArray(x) ? x : [x, y, z];\n    let diff;\n    let dist;\n    let t;\n    let minDistance = -Number.MAX_VALUE;\n    let distance = 0;\n    const minPoint = vtkBoundingBox.getMinPoint(model.bbox);\n    const maxPoint = vtkBoundingBox.getMaxPoint(model.bbox);\n    let inside = 1;\n    for (let i = 0; i < 3; i++) {\n      diff = vtkBoundingBox.getLength(model.bbox, i);\n      if (diff !== 0.0) {\n        t = (point[i] - minPoint[i]) / diff;\n        if (t < 0.0) {\n          inside = 0;\n          dist = minPoint[i] - point[i];\n        } else if (t > 1.0) {\n          inside = 0;\n          dist = point[i] - maxPoint[i];\n        } else {\n          // want negative distance, we are inside\n          if (t <= 0.5) {\n            dist = minPoint[i] - point[i];\n          } else {\n            dist = point[i] - maxPoint[i];\n          }\n          if (dist > minDistance) {\n            // remember, it's negative\n            minDistance = dist;\n          }\n        } // end if inside\n      } else {\n        dist = Math.abs(point[i] - minPoint[i]);\n        if (dist > 0.0) {\n          inside = 0;\n        }\n      }\n      if (dist > 0.0) {\n        distance += dist * dist;\n      }\n    } // end for i\n    distance = Math.sqrt(distance);\n    if (inside) {\n      return minDistance;\n    }\n    return distance;\n  };\n  publicAPI.addBounds = function () {\n    let boundsArray = [];\n    if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {\n      boundsArray = arguments.length <= 0 ? undefined : arguments[0];\n    } else {\n      for (let i = 0; i < arguments.length; i++) {\n        boundsArray.push(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n      }\n    }\n    if (boundsArray.length !== 6) {\n      return;\n    }\n    vtkBoundingBox.addBounds(model.bbox, ...boundsArray);\n    publicAPI.modified();\n  };\n  publicAPI.addBox = other => publicAPI.addBounds(other.getBounds());\n  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(model.bbox, p1, p2);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bbox: [...vtkBoundingBox.INIT_BOUNDS]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  vtkImplicitFunction.extend(publicAPI, model, initialValues);\n  vtkBox(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkBox');\n\n// ----------------------------------------------------------------------------\n\nvar vtkBox$1 = {\n  newInstance,\n  extend,\n  intersectWithLine,\n  ...STATIC\n};\nexport { STATIC, vtkBox$1 as default, extend, intersectWithLine, newInstance };","map":{"version":3,"names":["m","macro","vtkBoundingBox","vtkImplicitFunction","intersectWithLine","bounds","p1","p2","plane1","plane2","t1","t2","j","k","i","d1","d2","t","getValues","plane","x","count","x1","x2","outObject","STATIC","vtkBox","publicAPI","model","classHierarchy","push","setBounds","boundsArray","_len","arguments","length","Array","_key","isArray","console","log","bbox","getBounds","evaluateFunction","y","z","point","diff","dist","minDistance","Number","MAX_VALUE","distance","minPoint","getMinPoint","maxPoint","getMaxPoint","inside","getLength","Math","abs","sqrt","addBounds","undefined","modified","addBox","other","DEFAULT_VALUES","INIT_BOUNDS","extend","initialValues","Object","assign","newInstance","vtkBox$1","default"],"sources":["/home/ims/VSCodeProjects/TickerWeb/TickerWeb_Vue/node_modules/@kitware/vtk.js/Common/DataModel/Box.js"],"sourcesContent":["import { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkImplicitFunction from './ImplicitFunction.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Bounding box intersection code from David Gobbi.  Go through the\n// bounding planes one at a time and compute the parametric coordinate\n// of each intersection and return the parametric values and the calculated points\nfunction intersectWithLine(bounds, p1, p2) {\n  let plane1 = -1;\n  let plane2 = -1;\n  let t1 = 0.0;\n  let t2 = 1.0;\n  for (let j = 0; j < 3; j++) {\n    for (let k = 0; k < 2; k++) {\n      // Compute distances of p1 and p2 from the plane along the plane normal\n      const i = 2 * j + k;\n      const d1 = (bounds[i] - p1[j]) * (1 - 2 * k);\n      const d2 = (bounds[i] - p2[j]) * (1 - 2 * k);\n\n      // If both distances are positive, both points are outside\n      if (d1 > 0 && d2 > 0) {\n        return;\n      }\n      // If one of the distances is positive, the line crosses the plane\n      if (d1 > 0 || d2 > 0) {\n        // Compute fractional distance \"t\" of the crossing between p1 & p2\n        let t = 0.0;\n        if (d1 !== 0) {\n          t = d1 / (d1 - d2);\n        }\n\n        // If point p1 was clipped, adjust t1\n        if (d1 > 0) {\n          if (t >= t1) {\n            t1 = t;\n            plane1 = i;\n          }\n        }\n        // else point p2 was clipped, so adjust t2\n        else if (t <= t2) {\n          t2 = t;\n          plane2 = i;\n        }\n        // If this happens, there's no line left\n        if (t1 > t2) {\n          // Allow for planes that are coincident or slightly inverted\n          if (plane1 < 0 || plane2 < 0) {\n            return;\n          }\n        }\n      }\n    }\n  }\n  function getValues(plane, t) {\n    const x = [0, 0, 0];\n    for (let count = 0; count < 2; count++) {\n      for (let i = 0; i < 3; i++) {\n        if (plane === 2 * i || plane === 2 * i + 1) {\n          x[i] = bounds[plane];\n        } else {\n          x[i] = p1[i] * (1.0 - t) + p2[i] * t;\n          if (x[i] < bounds[2 * i]) {\n            x[i] = bounds[2 * i];\n          }\n          if (x[i] > bounds[2 * i + 1]) {\n            x[i] = bounds[2 * i + 1];\n          }\n        }\n      }\n    }\n    return x;\n  }\n  const x1 = getValues(plane1, t1);\n  const x2 = getValues(plane2, t2);\n  const outObject = {\n    t1,\n    t2,\n    x1,\n    x2\n  };\n\n  // eslint-disable-next-line consistent-return\n  return outObject;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {};\n\n// ----------------------------------------------------------------------------\n// vtkBox methods\n// ----------------------------------------------------------------------------\nfunction vtkBox(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkBox');\n\n  // TODO: replace with macro.setArray ?\n  publicAPI.setBounds = function () {\n    let boundsArray = [];\n    for (var _len = arguments.length, bounds = new Array(_len), _key = 0; _key < _len; _key++) {\n      bounds[_key] = arguments[_key];\n    }\n    if (Array.isArray(bounds[0])) {\n      boundsArray = bounds[0];\n    } else {\n      for (let i = 0; i < bounds.length; i++) {\n        boundsArray.push(bounds[i]);\n      }\n    }\n    if (boundsArray.length !== 6) {\n      console.log('vtkBox.setBounds', boundsArray, bounds);\n      return;\n    }\n    vtkBoundingBox.setBounds(model.bbox, boundsArray);\n  };\n  publicAPI.getBounds = () => model.bbox;\n  publicAPI.evaluateFunction = (x, y, z) => {\n    const point = Array.isArray(x) ? x : [x, y, z];\n    let diff;\n    let dist;\n    let t;\n    let minDistance = -Number.MAX_VALUE;\n    let distance = 0;\n    const minPoint = vtkBoundingBox.getMinPoint(model.bbox);\n    const maxPoint = vtkBoundingBox.getMaxPoint(model.bbox);\n    let inside = 1;\n    for (let i = 0; i < 3; i++) {\n      diff = vtkBoundingBox.getLength(model.bbox, i);\n      if (diff !== 0.0) {\n        t = (point[i] - minPoint[i]) / diff;\n        if (t < 0.0) {\n          inside = 0;\n          dist = minPoint[i] - point[i];\n        } else if (t > 1.0) {\n          inside = 0;\n          dist = point[i] - maxPoint[i];\n        } else {\n          // want negative distance, we are inside\n          if (t <= 0.5) {\n            dist = minPoint[i] - point[i];\n          } else {\n            dist = point[i] - maxPoint[i];\n          }\n          if (dist > minDistance) {\n            // remember, it's negative\n            minDistance = dist;\n          }\n        } // end if inside\n      } else {\n        dist = Math.abs(point[i] - minPoint[i]);\n        if (dist > 0.0) {\n          inside = 0;\n        }\n      }\n      if (dist > 0.0) {\n        distance += dist * dist;\n      }\n    } // end for i\n    distance = Math.sqrt(distance);\n    if (inside) {\n      return minDistance;\n    }\n    return distance;\n  };\n  publicAPI.addBounds = function () {\n    let boundsArray = [];\n    if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {\n      boundsArray = arguments.length <= 0 ? undefined : arguments[0];\n    } else {\n      for (let i = 0; i < arguments.length; i++) {\n        boundsArray.push(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n      }\n    }\n    if (boundsArray.length !== 6) {\n      return;\n    }\n    vtkBoundingBox.addBounds(model.bbox, ...boundsArray);\n    publicAPI.modified();\n  };\n  publicAPI.addBox = other => publicAPI.addBounds(other.getBounds());\n  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(model.bbox, p1, p2);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bbox: [...vtkBoundingBox.INIT_BOUNDS]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  vtkImplicitFunction.extend(publicAPI, model, initialValues);\n  vtkBox(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkBox');\n\n// ----------------------------------------------------------------------------\n\nvar vtkBox$1 = {\n  newInstance,\n  extend,\n  intersectWithLine,\n  ...STATIC\n};\n\nexport { STATIC, vtkBox$1 as default, extend, intersectWithLine, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}