{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { vec3, mat4 } from 'gl-matrix';\nimport * as d3 from 'd3-scale';\nimport { O as normalize2D, P as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkActor from './Actor.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkMapper from './Mapper.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTexture from './Texture.js';\n\n// ----------------------------------------------------------------------------\n// vtkCubeAxesActor\n// ----------------------------------------------------------------------------\n// faces are -x x -y y -z z\n// point 0 is 0,0,0 and then +x fastest changing, +y then +z\nconst faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];\nconst faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];\nconst edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];\nconst edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];\nconst faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];\n\n//\n// Developer note: This class is broken into the main class and a helper\n// class. The main class holds view independent properties (those properties\n// that do not change as the view's resolution/aspect ratio change). The\n// helper class is instantiated one per view and holds properties that can\n// depend on view specific values such as resolution. The helper class code\n// could have been left to the View specific implementation (such as\n// vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by\n// multiple rendering backends.\n//\n\n// some shared temp variables to reduce heap allocs\nconst ptv3 = new Float64Array(3);\nconst pt2v3 = new Float64Array(3);\nconst tmpv3 = new Float64Array(3);\nconst tmp2v3 = new Float64Array(3);\nconst xDir = new Float64Array(3);\nconst yDir = new Float64Array(3);\nconst invmat = new Float64Array(16);\nfunction applyTextStyle(ctx, style) {\n  ctx.strokeStyle = style.strokeColor;\n  ctx.lineWidth = style.strokeSize;\n  ctx.fillStyle = style.fontColor;\n  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;\n}\nfunction defaultGenerateTicks(dataBounds) {\n  const ticks = [];\n  const tickStrings = [];\n  for (let i = 0; i < 3; i++) {\n    const scale = d3.scaleLinear().domain([dataBounds[i * 2], dataBounds[i * 2 + 1]]);\n    ticks[i] = scale.ticks(5);\n    const format = scale.tickFormat(5);\n    tickStrings[i] = ticks[i].map(format);\n  }\n  return {\n    ticks,\n    tickStrings\n  };\n}\n\n// many properties of this actor depend on the API specific view The main\n// dependency being the resolution as that drives what font sizes to use.\n// Bacause of this we need to do some of the calculations in a API specific\n// subclass. But... we don't want a lot of duplicated code between WebGL and\n// WebGPU for example so we have this helper class, that is designed to be\n// fairly API independent so that API specific views can call this to do\n// most of the work.\nfunction vtkCubeAxesActorHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActorHelper');\n  publicAPI.setRenderable = renderable => {\n    if (model.renderable === renderable) {\n      return;\n    }\n    model.renderable = renderable;\n    model.tmActor.addTexture(model.renderable.getTmTexture());\n    model.tmActor.setProperty(renderable.getProperty());\n    model.tmActor.setParentProp(renderable);\n    publicAPI.modified();\n  };\n\n  // called by updateTexturePolyData\n  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {\n    const value = model.renderable.get_tmAtlas().get(text);\n    if (!value) {\n      return;\n    }\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n\n    // compute pixel to distance factors\n    const size = model.lastSize;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    vec3.transformMat4(tmpv3, ptv3, cmat);\n    // moving 0.1 in NDC\n    tmpv3[0] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(xDir, pt2v3, ptv3);\n    tmpv3[0] -= 0.1;\n    tmpv3[1] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(yDir, pt2v3, ptv3);\n    for (let i = 0; i < 3; i++) {\n      xDir[i] /= 0.5 * 0.1 * size[0];\n      yDir[i] /= 0.5 * 0.1 * size[1];\n    }\n\n    // have to find the four corners of the texture polygon for this label\n    // convert anchor point to View Coords\n    let ptIdx = results.ptIdx;\n    let cellIdx = results.cellIdx;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    // horizontal left, right, or middle alignment based on dir[0]\n    if (dir[0] < -0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width);\n    } else if (dir[0] > 0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset);\n    } else {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width / 2.0);\n    }\n    vec3.add(ptv3, ptv3, tmpv3);\n    vec3.scale(tmpv3, yDir, dir[1] * offset - value.height / 2.0);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[0];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[2];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];\n    ptIdx++;\n    vec3.scale(tmpv3, yDir, value.height);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[4];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.subtract(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[6];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];\n    ptIdx++;\n\n    // add the two triangles to represent the quad\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 3;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 2;\n    cellIdx++;\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 2;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 1;\n    results.ptIdx += 4;\n    results.cellIdx += 2;\n  };\n\n  // update the polydata associated with drawing the text labels\n  // specifically the quads used for each label and their associated tcoords\n  // etc. This changes every time the camera viewpoint changes\n  publicAPI.updateTexturePolyData = () => {\n    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);\n    mat4.transpose(cmat, cmat);\n\n    // update the polydata\n    const numLabels = model.renderable.getTextValues().length;\n    const numPts = numLabels * 4;\n    const numTris = numLabels * 2;\n    const points = new Float64Array(numPts * 3);\n    const polys = new Uint16Array(numTris * 4);\n    const tcoords = new Float32Array(numPts * 2);\n    mat4.invert(invmat, cmat);\n    const results = {\n      ptIdx: 0,\n      cellIdx: 0,\n      polys,\n      points,\n      tcoords\n    };\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisIdx = 0;\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n    const textValues = model.renderable.getTextValues();\n    while (ptIdx < coords.length / 3) {\n      // compute the direction to move out\n      ptv3[0] = coords[ptIdx * 3];\n      ptv3[1] = coords[ptIdx * 3 + 1];\n      ptv3[2] = coords[ptIdx * 3 + 2];\n      vec3.transformMat4(tmpv3, ptv3, cmat);\n      ptv3[0] = coords[ptIdx * 3 + 3];\n      ptv3[1] = coords[ptIdx * 3 + 4];\n      ptv3[2] = coords[ptIdx * 3 + 5];\n      vec3.transformMat4(tmp2v3, ptv3, cmat);\n      vec3.subtract(tmpv3, tmpv3, tmp2v3);\n      const dir = [tmpv3[0], tmpv3[1]];\n      normalize2D(dir);\n\n      // write the axis label\n      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);\n      ptIdx += 2;\n      textIdx++;\n\n      // write the tick labels\n      for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {\n        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);\n        ptIdx++;\n        textIdx++;\n      }\n      axisIdx++;\n    }\n    const tcoordDA = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoords,\n      name: 'TextureCoordinates'\n    });\n    model.tmPolyData.getPointData().setTCoords(tcoordDA);\n    model.tmPolyData.getPoints().setData(points, 3);\n    model.tmPolyData.getPoints().modified();\n    model.tmPolyData.getPolys().setData(polys, 1);\n    model.tmPolyData.getPolys().modified();\n    model.tmPolyData.modified();\n  };\n  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {\n    // has the size changed?\n    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {\n      model.lastSize[0] = size[0];\n      model.lastSize[1] = size[1];\n      model.lastAspectRatio = size[0] / size[1];\n      model.forceUpdate = true;\n    }\n    model.camera = camera;\n\n    // compute bounds for label quads whenever the camera changes\n    publicAPI.updateTexturePolyData();\n  };\n}\nconst newCubeAxesActorHelper = macro.newInstance(function (publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    renderable: null\n  };\n  Object.assign(model, {}, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  model.tmPolyData = vtkPolyData.newInstance();\n  model.tmMapper = vtkMapper.newInstance();\n  model.tmMapper.setInputData(model.tmPolyData);\n  model.tmActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  });\n  model.tmActor.setMapper(model.tmMapper);\n  macro.setGet(publicAPI, model, ['renderable']);\n  macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);\n  model.forceUpdate = false;\n  model.lastRedrawTime = {};\n  macro.obj(model.lastRedrawTime, {\n    mtime: 0\n  });\n  model.lastRebuildTime = {};\n  macro.obj(model.lastRebuildTime, {\n    mtime: 0\n  });\n  model.lastSize = [-1, -1];\n\n  // internal variables\n  model.lastTickBounds = [];\n  vtkCubeAxesActorHelper(publicAPI, model);\n}, 'vtkCubeAxesActorHelper');\nfunction vtkCubeAxesActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActor');\n  publicAPI.setCamera = cam => {\n    if (model.camera === cam) {\n      return;\n    }\n    if (model.cameraModifiedSub) {\n      model.cameraModifiedSub.unsubscribe();\n      model.cameraModifiedSub = null;\n    }\n    model.camera = cam;\n    if (cam) {\n      model.cameraModifiedSub = cam.onModified(publicAPI.update);\n    }\n    publicAPI.update();\n    publicAPI.modified();\n  };\n\n  // estimate from a camera model what faces to draw\n  // return true if the list of faces to draw has changed\n  publicAPI.computeFacesToDraw = () => {\n    const cmat = model.camera.getViewMatrix();\n    mat4.transpose(cmat, cmat);\n    let changed = false;\n    const length = vtkBoundingBox.getDiagonalLength(model.dataBounds);\n    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);\n    for (let f = 0; f < 6; f++) {\n      let drawit = false;\n      const faceAxis = Math.floor(f / 2);\n      const otherAxis1 = (faceAxis + 1) % 3;\n      const otherAxis2 = (faceAxis + 2) % 3;\n      // only for non degenerate axes\n      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {\n        // for each face transform the center and off center to get a direction vector\n        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];\n        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);\n        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);\n        vec3.transformMat4(tmpv3, ptv3, cmat);\n        ptv3[faceAxis] = model.dataBounds[f];\n        vec3.transformMat4(tmp2v3, ptv3, cmat);\n        vec3.subtract(tmpv3, tmp2v3, tmpv3);\n        vec3.normalize(tmpv3, tmpv3);\n        // tmpv3 now holds the face normal vector\n        drawit = tmpv3[2] > faceDot;\n        // for perspctive we need the view direction to the plane\n        if (!model.camera.getParallelProjection()) {\n          vec3.normalize(tmp2v3, tmp2v3);\n          drawit = vec3.dot(tmp2v3, tmpv3) > faceDot;\n        }\n      }\n      if (drawit !== model.lastFacesToDraw[f]) {\n        model.lastFacesToDraw[f] = drawit;\n        changed = true;\n      }\n    }\n    return changed;\n  };\n\n  // update the polydata that represents the boundingd edges and gridlines\n  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks) => {\n    // compute the number of points and lines required\n    let numPts = 0;\n    let numLines = 0;\n    numPts += 8; // always start with the 8 cube points\n\n    // count edgesToDraw\n    let numEdgesToDraw = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        numEdgesToDraw++;\n      }\n    }\n    numLines += numEdgesToDraw;\n\n    // add values for gridlines\n    if (model.gridLines) {\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;\n          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;\n        }\n      }\n    }\n\n    // now allocate the memory\n    const points = new Float64Array(numPts * 3);\n    const lines = new Uint32Array(numLines * 3);\n    let ptIdx = 0;\n    let lineIdx = 0;\n\n    // add the 8 corner points\n    for (let z = 0; z < 2; z++) {\n      for (let y = 0; y < 2; y++) {\n        for (let x = 0; x < 2; x++) {\n          points[ptIdx * 3] = model.dataBounds[x];\n          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];\n          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];\n          ptIdx++;\n        }\n      }\n    }\n\n    // draw the edges\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        lines[lineIdx * 3] = 2;\n        lines[lineIdx * 3 + 1] = edgePoints[e][0];\n        lines[lineIdx * 3 + 2] = edgePoints[e][1];\n        lineIdx++;\n      }\n    }\n\n    // now handle gridlines\n    // grid lines are tick[axis1] + ticks[axes2] lines each having two points\n    // for simplicity we don;t worry about duplicating points, this is tiny\n\n    if (model.gridLines) {\n      // for each visible face\n      // add the points\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          const faceIdx = Math.floor(f / 2);\n          let aticks = ticks[faceAxes[f][0]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n          aticks = ticks[faceAxes[f][1]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n        }\n      }\n    }\n    model.polyData.getPoints().setData(points, 3);\n    model.polyData.getPoints().modified();\n    model.polyData.getLines().setData(lines, 1);\n    model.polyData.getLines().modified();\n    model.polyData.modified();\n  };\n\n  // update the data that represents where to put the labels\n  // in world coordinates. This only changes when faces to draw changes\n  // of dataBounds changes\n  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks, tickStrings) => {\n    // count outside edgesToDraw\n    let textPointCount = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] === 1) {\n        textPointCount += 2;\n        textPointCount += ticks[edgeAxes[e]].length;\n      }\n    }\n    const points = model.polyData.getPoints().getData();\n    const textPoints = new Float64Array(textPointCount * 3);\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisCount = 0;\n    for (let f = 0; f < 6; f++) {\n      if (facesToDraw[f]) {\n        for (let e = 0; e < 4; e++) {\n          const edgeIdx = faceEdges[f][e];\n          if (edgesToDraw[edgeIdx] === 1) {\n            const edgeAxis = edgeAxes[edgeIdx];\n            // add a middle point on the edge\n            const ptIdx1 = edgePoints[edgeIdx][0] * 3;\n            const ptIdx2 = edgePoints[edgeIdx][1] * 3;\n            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);\n            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);\n            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);\n            ptIdx++;\n            // add a middle face point, we use this to\n            // move the labels away from the edge in the right direction\n            const faceIdx = Math.floor(f / 2);\n            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);\n            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);\n            ptIdx++;\n            // set the text\n            model.textValues[textIdx] = model.axisLabels[edgeAxis];\n            textIdx++;\n\n            // now add the tick marks along the edgeAxis\n            const otherAxis1 = (edgeAxis + 1) % 3;\n            const otherAxis2 = (edgeAxis + 2) % 3;\n            const aticks = ticks[edgeAxis];\n            const atickStrings = tickStrings[edgeAxis];\n            model.tickCounts[axisCount] = aticks.length;\n            for (let t = 0; t < aticks.length; t++) {\n              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];\n              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];\n              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];\n              ptIdx++;\n              // set the text\n              model.textValues[textIdx] = atickStrings[t];\n              textIdx++;\n            }\n            axisCount++;\n          }\n        }\n      }\n    }\n    model.textPolyData.getPoints().setData(textPoints, 3);\n    model.textPolyData.modified();\n  };\n\n  // main method to rebuild the cube axes, gets called on camera modify\n  // and changes to key members\n  publicAPI.update = () => {\n    // Can't do anything if we don't have a camera...\n    if (!model.camera) {\n      return;\n    }\n\n    // compute what faces to draw\n    const facesChanged = publicAPI.computeFacesToDraw();\n    const facesToDraw = model.lastFacesToDraw;\n\n    // have the bounds changed?\n    let boundsChanged = false;\n    for (let i = 0; i < 6; i++) {\n      if (model.dataBounds[i] !== model.lastTickBounds[i]) {\n        boundsChanged = true;\n        model.lastTickBounds[i] = model.dataBounds[i];\n      }\n    }\n\n    // did something significant change? If so rebuild a lot of things\n    if (facesChanged || boundsChanged || model.forceUpdate) {\n      // compute the edges to draw\n      // for each drawn face, mark edges, all single mark edges we draw\n      const edgesToDraw = new Array(12).fill(0);\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          for (let e = 0; e < 4; e++) {\n            edgesToDraw[faceEdges[f][e]]++;\n          }\n        }\n      }\n\n      // compute tick marks for axes\n      const t = model.generateTicks(model.dataBounds);\n\n      // update gridlines / edge lines\n      publicAPI.updatePolyData(facesToDraw, edgesToDraw, t.ticks);\n\n      // compute label world coords and text\n      publicAPI.updateTextData(facesToDraw, edgesToDraw, t.ticks, t.tickStrings);\n\n      // rebuild the texture only when force or changed bounds, face\n      // visibility changes do to change the atlas\n      if (boundsChanged || model.forceUpdate) {\n        publicAPI.updateTextureAtlas(t.tickStrings);\n      }\n    }\n    model.forceUpdate = false;\n  };\n\n  // create the texture map atlas that contains the rendering of\n  // all the text strings. Only needs to be called when the text strings\n  // have changed (labels and ticks)\n  publicAPI.updateTextureAtlas = tickStrings => {\n    // compute the width and height we need\n\n    // set the text properties\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n\n    // first the three labels\n    model._tmAtlas.clear();\n    let maxWidth = 0;\n    let totalHeight = 1; // start one pixel in so we have a border\n    for (let i = 0; i < 3; i++) {\n      if (!model._tmAtlas.has(model.axisLabels[i])) {\n        applyTextStyle(model.tmContext, model.axisTextStyle);\n        const metrics = model.tmContext.measureText(model.axisLabels[i]);\n        const entry = {\n          height: metrics.actualBoundingBoxAscent + 2,\n          startingHeight: totalHeight,\n          width: metrics.width + 2,\n          textStyle: model.axisTextStyle\n        };\n        model._tmAtlas.set(model.axisLabels[i], entry);\n        totalHeight += entry.height;\n        if (maxWidth < entry.width) {\n          maxWidth = entry.width;\n        }\n      }\n      // and the ticks\n      applyTextStyle(model.tmContext, model.tickTextStyle);\n      for (let t = 0; t < tickStrings[i].length; t++) {\n        if (!model._tmAtlas.has(tickStrings[i][t])) {\n          const metrics = model.tmContext.measureText(tickStrings[i][t]);\n          const entry = {\n            height: metrics.actualBoundingBoxAscent + 2,\n            startingHeight: totalHeight,\n            width: metrics.width + 2,\n            textStyle: model.tickTextStyle\n          };\n          model._tmAtlas.set(tickStrings[i][t], entry);\n          totalHeight += entry.height;\n          if (maxWidth < entry.width) {\n            maxWidth = entry.width;\n          }\n        }\n      }\n    }\n\n    // always use power of two to avoid interpolation\n    // in cases where PO2 is required\n    maxWidth = nearestPowerOfTwo(maxWidth);\n    totalHeight = nearestPowerOfTwo(totalHeight);\n\n    // set the tcoord values\n    model._tmAtlas.forEach(value => {\n      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];\n    });\n\n    // make sure we have power of two dimensions\n    model.tmCanvas.width = maxWidth;\n    model.tmCanvas.height = totalHeight;\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);\n\n    // draw the text onto the texture\n    model._tmAtlas.forEach((value, key) => {\n      applyTextStyle(model.tmContext, value.textStyle);\n      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);\n    });\n    model.tmTexture.setCanvas(model.tmCanvas);\n    model.tmTexture.modified();\n  };\n\n  // Make sure the data is correct\n  publicAPI.onModified(() => {\n    model.forceUpdate = true;\n    publicAPI.update();\n  });\n  publicAPI.setTickTextStyle = tickStyle => {\n    model.tickTextStyle = {\n      ...model.tickTextStyle,\n      ...tickStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.setAxisTextStyle = axisStyle => {\n    model.axisTextStyle = {\n      ...model.axisTextStyle,\n      ...axisStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.get_tmAtlas = () => model._tmAtlas;\n\n  // try to get the bounds for the annotation. This is complicated\n  // as it relies on the pixel size of the window. Every time the camera\n  // changes the bounds change. This method simplifies by just expanding\n  // the grid bounds by a user specified factor.\n  publicAPI.getBounds = () => {\n    publicAPI.update();\n    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());\n    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);\n    return model.bounds;\n  };\n\n  // Make sure the grid share the actor property\n  const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);\n  publicAPI.setProperty = p => _setProp(p)[0];\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(publicAPI, model, initialValues) {\n  return {\n    boundsScaleFactor: 1.3,\n    camera: null,\n    dataBounds: [...vtkBoundingBox.INIT_BOUNDS],\n    faceVisibilityAngle: 8,\n    gridLines: true,\n    axisLabels: null,\n    axisTitlePixelOffset: 35.0,\n    tickLabelPixelOffset: 12.0,\n    generateTicks: defaultGenerateTicks,\n    ...initialValues,\n    axisTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 18,\n      fontFamily: 'serif',\n      ...initialValues?.axisTextStyle\n    },\n    tickTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 14,\n      fontFamily: 'serif',\n      ...initialValues?.tickTextStyle\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Inheritance\n  vtkActor.extend(publicAPI, model, defaultValues(publicAPI, model, initialValues));\n\n  // internal variables\n  model.lastFacesToDraw = [false, false, false, false, false, false];\n  model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];\n  model.tickCounts = [];\n  model.textValues = [];\n  model.lastTickBounds = [];\n  model.tmCanvas = document.createElement('canvas');\n  model.tmContext = model.tmCanvas.getContext('2d');\n  model._tmAtlas = new Map();\n\n  // for texture atlas\n  model.tmTexture = vtkTexture.newInstance({\n    resizable: true\n  });\n  model.tmTexture.setInterpolate(false);\n  publicAPI.getProperty().setDiffuse(0.0);\n  publicAPI.getProperty().setAmbient(1.0);\n  model.gridMapper = vtkMapper.newInstance();\n  model.polyData = vtkPolyData.newInstance();\n  model.gridMapper.setInputData(model.polyData);\n  model.gridActor = vtkActor.newInstance();\n  model.gridActor.setMapper(model.gridMapper);\n  model.gridActor.setProperty(publicAPI.getProperty());\n  model.gridActor.setParentProp(publicAPI);\n  model.textPolyData = vtkPolyData.newInstance();\n  macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset', 'generateTicks']);\n  macro.setGetArray(publicAPI, model, ['dataBounds'], 6);\n  macro.setGetArray(publicAPI, model, ['axisLabels'], 3);\n  macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']);\n\n  // Object methods\n  vtkCubeAxesActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCubeAxesActor');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCubeAxesActor$1 = {\n  newInstance,\n  extend,\n  newCubeAxesActorHelper,\n  defaultGenerateTicks\n};\nexport { vtkCubeAxesActor$1 as default, extend, newInstance };","map":{"version":3,"names":["vec3","mat4","d3","O","normalize2D","P","nearestPowerOfTwo","m","macro","vtkActor","vtkBoundingBox","vtkDataArray","vtkMapper","vtkPolyData","vtkTexture","faceNormals","faceEdges","edgePoints","edgeAxes","faceAxes","ptv3","Float64Array","pt2v3","tmpv3","tmp2v3","xDir","yDir","invmat","applyTextStyle","ctx","style","strokeStyle","strokeColor","lineWidth","strokeSize","fillStyle","fontColor","font","fontStyle","fontSize","fontFamily","defaultGenerateTicks","dataBounds","ticks","tickStrings","i","scale","scaleLinear","domain","format","tickFormat","map","vtkCubeAxesActorHelper","publicAPI","model","classHierarchy","push","setRenderable","renderable","tmActor","addTexture","getTmTexture","setProperty","getProperty","setParentProp","modified","createPolyDataForOneLabel","text","pos","cmat","imat","dir","offset","results","value","get_tmAtlas","get","coords","getTextPolyData","getPoints","getData","size","lastSize","transformMat4","subtract","ptIdx","cellIdx","width","add","height","points","tcoords","polys","updateTexturePolyData","camera","getCompositeProjectionMatrix","lastAspectRatio","transpose","numLabels","getTextValues","length","numPts","numTris","Uint16Array","Float32Array","invert","textIdx","axisIdx","textValues","getAxisTitlePixelOffset","t","getTickCounts","getTickLabelPixelOffset","tcoordDA","newInstance","numberOfComponents","values","name","tmPolyData","getPointData","setTCoords","setData","getPolys","updateAPISpecificData","renderWindow","forceUpdate","newCubeAxesActorHelper","initialValues","arguments","undefined","Object","assign","obj","tmMapper","setInputData","parentProp","setMapper","setGet","lastRedrawTime","mtime","lastRebuildTime","lastTickBounds","vtkCubeAxesActor","setCamera","cam","cameraModifiedSub","unsubscribe","onModified","update","computeFacesToDraw","getViewMatrix","changed","getDiagonalLength","faceDot","Math","sin","faceVisibilityAngle","PI","f","drawit","faceAxis","floor","otherAxis1","otherAxis2","normalize","getParallelProjection","dot","lastFacesToDraw","updatePolyData","facesToDraw","edgesToDraw","numLines","numEdgesToDraw","e","gridLines","lines","Uint32Array","lineIdx","z","y","x","faceIdx","aticks","polyData","getLines","updateTextData","textPointCount","textPoints","axisCount","edgeIdx","edgeAxis","ptIdx1","ptIdx2","axisLabels","atickStrings","tickCounts","textPolyData","facesChanged","boundsChanged","Array","fill","generateTicks","updateTextureAtlas","tmContext","textBaseline","textAlign","_tmAtlas","clear","maxWidth","totalHeight","has","axisTextStyle","metrics","measureText","entry","actualBoundingBoxAscent","startingHeight","textStyle","set","tickTextStyle","forEach","tmCanvas","clearRect","key","fillText","tmTexture","setCanvas","setTickTextStyle","tickStyle","setAxisTextStyle","axisStyle","getBounds","setBounds","bounds","gridActor","scaleAboutCenter","boundsScaleFactor","_setProp","chain","p","defaultValues","INIT_BOUNDS","axisTitlePixelOffset","tickLabelPixelOffset","extend","document","createElement","getContext","Map","resizable","setInterpolate","setDiffuse","setAmbient","gridMapper","setGetArray","vtkCubeAxesActor$1","default"],"sources":["C:/Users/Malcolm/Projects/Web/TickerWeb/node_modules/@kitware/vtk.js/Rendering/Core/CubeAxesActor.js"],"sourcesContent":["import { vec3, mat4 } from 'gl-matrix';\nimport * as d3 from 'd3-scale';\nimport { O as normalize2D, P as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkActor from './Actor.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkMapper from './Mapper.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkTexture from './Texture.js';\n\n// ----------------------------------------------------------------------------\n// vtkCubeAxesActor\n// ----------------------------------------------------------------------------\n// faces are -x x -y y -z z\n// point 0 is 0,0,0 and then +x fastest changing, +y then +z\nconst faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];\nconst faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];\nconst edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];\nconst edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];\nconst faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];\n\n//\n// Developer note: This class is broken into the main class and a helper\n// class. The main class holds view independent properties (those properties\n// that do not change as the view's resolution/aspect ratio change). The\n// helper class is instantiated one per view and holds properties that can\n// depend on view specific values such as resolution. The helper class code\n// could have been left to the View specific implementation (such as\n// vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by\n// multiple rendering backends.\n//\n\n// some shared temp variables to reduce heap allocs\nconst ptv3 = new Float64Array(3);\nconst pt2v3 = new Float64Array(3);\nconst tmpv3 = new Float64Array(3);\nconst tmp2v3 = new Float64Array(3);\nconst xDir = new Float64Array(3);\nconst yDir = new Float64Array(3);\nconst invmat = new Float64Array(16);\nfunction applyTextStyle(ctx, style) {\n  ctx.strokeStyle = style.strokeColor;\n  ctx.lineWidth = style.strokeSize;\n  ctx.fillStyle = style.fontColor;\n  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;\n}\nfunction defaultGenerateTicks(dataBounds) {\n  const ticks = [];\n  const tickStrings = [];\n  for (let i = 0; i < 3; i++) {\n    const scale = d3.scaleLinear().domain([dataBounds[i * 2], dataBounds[i * 2 + 1]]);\n    ticks[i] = scale.ticks(5);\n    const format = scale.tickFormat(5);\n    tickStrings[i] = ticks[i].map(format);\n  }\n  return {\n    ticks,\n    tickStrings\n  };\n}\n\n// many properties of this actor depend on the API specific view The main\n// dependency being the resolution as that drives what font sizes to use.\n// Bacause of this we need to do some of the calculations in a API specific\n// subclass. But... we don't want a lot of duplicated code between WebGL and\n// WebGPU for example so we have this helper class, that is designed to be\n// fairly API independent so that API specific views can call this to do\n// most of the work.\nfunction vtkCubeAxesActorHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActorHelper');\n  publicAPI.setRenderable = renderable => {\n    if (model.renderable === renderable) {\n      return;\n    }\n    model.renderable = renderable;\n    model.tmActor.addTexture(model.renderable.getTmTexture());\n    model.tmActor.setProperty(renderable.getProperty());\n    model.tmActor.setParentProp(renderable);\n    publicAPI.modified();\n  };\n\n  // called by updateTexturePolyData\n  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {\n    const value = model.renderable.get_tmAtlas().get(text);\n    if (!value) {\n      return;\n    }\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n\n    // compute pixel to distance factors\n    const size = model.lastSize;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    vec3.transformMat4(tmpv3, ptv3, cmat);\n    // moving 0.1 in NDC\n    tmpv3[0] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(xDir, pt2v3, ptv3);\n    tmpv3[0] -= 0.1;\n    tmpv3[1] += 0.1;\n    vec3.transformMat4(pt2v3, tmpv3, imat);\n    // results in WC move of\n    vec3.subtract(yDir, pt2v3, ptv3);\n    for (let i = 0; i < 3; i++) {\n      xDir[i] /= 0.5 * 0.1 * size[0];\n      yDir[i] /= 0.5 * 0.1 * size[1];\n    }\n\n    // have to find the four corners of the texture polygon for this label\n    // convert anchor point to View Coords\n    let ptIdx = results.ptIdx;\n    let cellIdx = results.cellIdx;\n    ptv3[0] = coords[pos * 3];\n    ptv3[1] = coords[pos * 3 + 1];\n    ptv3[2] = coords[pos * 3 + 2];\n    // horizontal left, right, or middle alignment based on dir[0]\n    if (dir[0] < -0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width);\n    } else if (dir[0] > 0.5) {\n      vec3.scale(tmpv3, xDir, dir[0] * offset);\n    } else {\n      vec3.scale(tmpv3, xDir, dir[0] * offset - value.width / 2.0);\n    }\n    vec3.add(ptv3, ptv3, tmpv3);\n    vec3.scale(tmpv3, yDir, dir[1] * offset - value.height / 2.0);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[0];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[2];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];\n    ptIdx++;\n    vec3.scale(tmpv3, yDir, value.height);\n    vec3.add(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[4];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];\n    ptIdx++;\n    vec3.scale(tmpv3, xDir, value.width);\n    vec3.subtract(ptv3, ptv3, tmpv3);\n    results.points[ptIdx * 3] = ptv3[0];\n    results.points[ptIdx * 3 + 1] = ptv3[1];\n    results.points[ptIdx * 3 + 2] = ptv3[2];\n    results.tcoords[ptIdx * 2] = value.tcoords[6];\n    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];\n    ptIdx++;\n\n    // add the two triangles to represent the quad\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 3;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 2;\n    cellIdx++;\n    results.polys[cellIdx * 4] = 3;\n    results.polys[cellIdx * 4 + 1] = ptIdx - 4;\n    results.polys[cellIdx * 4 + 2] = ptIdx - 2;\n    results.polys[cellIdx * 4 + 3] = ptIdx - 1;\n    results.ptIdx += 4;\n    results.cellIdx += 2;\n  };\n\n  // update the polydata associated with drawing the text labels\n  // specifically the quads used for each label and their associated tcoords\n  // etc. This changes every time the camera viewpoint changes\n  publicAPI.updateTexturePolyData = () => {\n    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);\n    mat4.transpose(cmat, cmat);\n\n    // update the polydata\n    const numLabels = model.renderable.getTextValues().length;\n    const numPts = numLabels * 4;\n    const numTris = numLabels * 2;\n    const points = new Float64Array(numPts * 3);\n    const polys = new Uint16Array(numTris * 4);\n    const tcoords = new Float32Array(numPts * 2);\n    mat4.invert(invmat, cmat);\n    const results = {\n      ptIdx: 0,\n      cellIdx: 0,\n      polys,\n      points,\n      tcoords\n    };\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisIdx = 0;\n    const coords = model.renderable.getTextPolyData().getPoints().getData();\n    const textValues = model.renderable.getTextValues();\n    while (ptIdx < coords.length / 3) {\n      // compute the direction to move out\n      ptv3[0] = coords[ptIdx * 3];\n      ptv3[1] = coords[ptIdx * 3 + 1];\n      ptv3[2] = coords[ptIdx * 3 + 2];\n      vec3.transformMat4(tmpv3, ptv3, cmat);\n      ptv3[0] = coords[ptIdx * 3 + 3];\n      ptv3[1] = coords[ptIdx * 3 + 4];\n      ptv3[2] = coords[ptIdx * 3 + 5];\n      vec3.transformMat4(tmp2v3, ptv3, cmat);\n      vec3.subtract(tmpv3, tmpv3, tmp2v3);\n      const dir = [tmpv3[0], tmpv3[1]];\n      normalize2D(dir);\n\n      // write the axis label\n      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);\n      ptIdx += 2;\n      textIdx++;\n\n      // write the tick labels\n      for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {\n        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);\n        ptIdx++;\n        textIdx++;\n      }\n      axisIdx++;\n    }\n    const tcoordDA = vtkDataArray.newInstance({\n      numberOfComponents: 2,\n      values: tcoords,\n      name: 'TextureCoordinates'\n    });\n    model.tmPolyData.getPointData().setTCoords(tcoordDA);\n    model.tmPolyData.getPoints().setData(points, 3);\n    model.tmPolyData.getPoints().modified();\n    model.tmPolyData.getPolys().setData(polys, 1);\n    model.tmPolyData.getPolys().modified();\n    model.tmPolyData.modified();\n  };\n  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {\n    // has the size changed?\n    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {\n      model.lastSize[0] = size[0];\n      model.lastSize[1] = size[1];\n      model.lastAspectRatio = size[0] / size[1];\n      model.forceUpdate = true;\n    }\n    model.camera = camera;\n\n    // compute bounds for label quads whenever the camera changes\n    publicAPI.updateTexturePolyData();\n  };\n}\nconst newCubeAxesActorHelper = macro.newInstance(function (publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    renderable: null\n  };\n  Object.assign(model, {}, initialValues);\n\n  // Inheritance\n  macro.obj(publicAPI, model);\n  model.tmPolyData = vtkPolyData.newInstance();\n  model.tmMapper = vtkMapper.newInstance();\n  model.tmMapper.setInputData(model.tmPolyData);\n  model.tmActor = vtkActor.newInstance({\n    parentProp: publicAPI\n  });\n  model.tmActor.setMapper(model.tmMapper);\n  macro.setGet(publicAPI, model, ['renderable']);\n  macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);\n  model.forceUpdate = false;\n  model.lastRedrawTime = {};\n  macro.obj(model.lastRedrawTime, {\n    mtime: 0\n  });\n  model.lastRebuildTime = {};\n  macro.obj(model.lastRebuildTime, {\n    mtime: 0\n  });\n  model.lastSize = [-1, -1];\n\n  // internal variables\n  model.lastTickBounds = [];\n  vtkCubeAxesActorHelper(publicAPI, model);\n}, 'vtkCubeAxesActorHelper');\nfunction vtkCubeAxesActor(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCubeAxesActor');\n  publicAPI.setCamera = cam => {\n    if (model.camera === cam) {\n      return;\n    }\n    if (model.cameraModifiedSub) {\n      model.cameraModifiedSub.unsubscribe();\n      model.cameraModifiedSub = null;\n    }\n    model.camera = cam;\n    if (cam) {\n      model.cameraModifiedSub = cam.onModified(publicAPI.update);\n    }\n    publicAPI.update();\n    publicAPI.modified();\n  };\n\n  // estimate from a camera model what faces to draw\n  // return true if the list of faces to draw has changed\n  publicAPI.computeFacesToDraw = () => {\n    const cmat = model.camera.getViewMatrix();\n    mat4.transpose(cmat, cmat);\n    let changed = false;\n    const length = vtkBoundingBox.getDiagonalLength(model.dataBounds);\n    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);\n    for (let f = 0; f < 6; f++) {\n      let drawit = false;\n      const faceAxis = Math.floor(f / 2);\n      const otherAxis1 = (faceAxis + 1) % 3;\n      const otherAxis2 = (faceAxis + 2) % 3;\n      // only for non degenerate axes\n      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {\n        // for each face transform the center and off center to get a direction vector\n        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];\n        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);\n        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);\n        vec3.transformMat4(tmpv3, ptv3, cmat);\n        ptv3[faceAxis] = model.dataBounds[f];\n        vec3.transformMat4(tmp2v3, ptv3, cmat);\n        vec3.subtract(tmpv3, tmp2v3, tmpv3);\n        vec3.normalize(tmpv3, tmpv3);\n        // tmpv3 now holds the face normal vector\n        drawit = tmpv3[2] > faceDot;\n        // for perspctive we need the view direction to the plane\n        if (!model.camera.getParallelProjection()) {\n          vec3.normalize(tmp2v3, tmp2v3);\n          drawit = vec3.dot(tmp2v3, tmpv3) > faceDot;\n        }\n      }\n      if (drawit !== model.lastFacesToDraw[f]) {\n        model.lastFacesToDraw[f] = drawit;\n        changed = true;\n      }\n    }\n    return changed;\n  };\n\n  // update the polydata that represents the boundingd edges and gridlines\n  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks) => {\n    // compute the number of points and lines required\n    let numPts = 0;\n    let numLines = 0;\n    numPts += 8; // always start with the 8 cube points\n\n    // count edgesToDraw\n    let numEdgesToDraw = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        numEdgesToDraw++;\n      }\n    }\n    numLines += numEdgesToDraw;\n\n    // add values for gridlines\n    if (model.gridLines) {\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;\n          numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;\n        }\n      }\n    }\n\n    // now allocate the memory\n    const points = new Float64Array(numPts * 3);\n    const lines = new Uint32Array(numLines * 3);\n    let ptIdx = 0;\n    let lineIdx = 0;\n\n    // add the 8 corner points\n    for (let z = 0; z < 2; z++) {\n      for (let y = 0; y < 2; y++) {\n        for (let x = 0; x < 2; x++) {\n          points[ptIdx * 3] = model.dataBounds[x];\n          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];\n          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];\n          ptIdx++;\n        }\n      }\n    }\n\n    // draw the edges\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] > 0) {\n        lines[lineIdx * 3] = 2;\n        lines[lineIdx * 3 + 1] = edgePoints[e][0];\n        lines[lineIdx * 3 + 2] = edgePoints[e][1];\n        lineIdx++;\n      }\n    }\n\n    // now handle gridlines\n    // grid lines are tick[axis1] + ticks[axes2] lines each having two points\n    // for simplicity we don;t worry about duplicating points, this is tiny\n\n    if (model.gridLines) {\n      // for each visible face\n      // add the points\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          const faceIdx = Math.floor(f / 2);\n          let aticks = ticks[faceAxes[f][0]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n          aticks = ticks[faceAxes[f][1]];\n          for (let t = 0; t < aticks.length; t++) {\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];\n            ptIdx++;\n            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];\n            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];\n            ptIdx++;\n            lines[lineIdx * 3] = 2;\n            lines[lineIdx * 3 + 1] = ptIdx - 2;\n            lines[lineIdx * 3 + 2] = ptIdx - 1;\n            lineIdx++;\n          }\n        }\n      }\n    }\n    model.polyData.getPoints().setData(points, 3);\n    model.polyData.getPoints().modified();\n    model.polyData.getLines().setData(lines, 1);\n    model.polyData.getLines().modified();\n    model.polyData.modified();\n  };\n\n  // update the data that represents where to put the labels\n  // in world coordinates. This only changes when faces to draw changes\n  // of dataBounds changes\n  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks, tickStrings) => {\n    // count outside edgesToDraw\n    let textPointCount = 0;\n    for (let e = 0; e < 12; e++) {\n      if (edgesToDraw[e] === 1) {\n        textPointCount += 2;\n        textPointCount += ticks[edgeAxes[e]].length;\n      }\n    }\n    const points = model.polyData.getPoints().getData();\n    const textPoints = new Float64Array(textPointCount * 3);\n    let ptIdx = 0;\n    let textIdx = 0;\n    let axisCount = 0;\n    for (let f = 0; f < 6; f++) {\n      if (facesToDraw[f]) {\n        for (let e = 0; e < 4; e++) {\n          const edgeIdx = faceEdges[f][e];\n          if (edgesToDraw[edgeIdx] === 1) {\n            const edgeAxis = edgeAxes[edgeIdx];\n            // add a middle point on the edge\n            const ptIdx1 = edgePoints[edgeIdx][0] * 3;\n            const ptIdx2 = edgePoints[edgeIdx][1] * 3;\n            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);\n            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);\n            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);\n            ptIdx++;\n            // add a middle face point, we use this to\n            // move the labels away from the edge in the right direction\n            const faceIdx = Math.floor(f / 2);\n            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];\n            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);\n            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);\n            ptIdx++;\n            // set the text\n            model.textValues[textIdx] = model.axisLabels[edgeAxis];\n            textIdx++;\n\n            // now add the tick marks along the edgeAxis\n            const otherAxis1 = (edgeAxis + 1) % 3;\n            const otherAxis2 = (edgeAxis + 2) % 3;\n            const aticks = ticks[edgeAxis];\n            const atickStrings = tickStrings[edgeAxis];\n            model.tickCounts[axisCount] = aticks.length;\n            for (let t = 0; t < aticks.length; t++) {\n              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];\n              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];\n              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];\n              ptIdx++;\n              // set the text\n              model.textValues[textIdx] = atickStrings[t];\n              textIdx++;\n            }\n            axisCount++;\n          }\n        }\n      }\n    }\n    model.textPolyData.getPoints().setData(textPoints, 3);\n    model.textPolyData.modified();\n  };\n\n  // main method to rebuild the cube axes, gets called on camera modify\n  // and changes to key members\n  publicAPI.update = () => {\n    // Can't do anything if we don't have a camera...\n    if (!model.camera) {\n      return;\n    }\n\n    // compute what faces to draw\n    const facesChanged = publicAPI.computeFacesToDraw();\n    const facesToDraw = model.lastFacesToDraw;\n\n    // have the bounds changed?\n    let boundsChanged = false;\n    for (let i = 0; i < 6; i++) {\n      if (model.dataBounds[i] !== model.lastTickBounds[i]) {\n        boundsChanged = true;\n        model.lastTickBounds[i] = model.dataBounds[i];\n      }\n    }\n\n    // did something significant change? If so rebuild a lot of things\n    if (facesChanged || boundsChanged || model.forceUpdate) {\n      // compute the edges to draw\n      // for each drawn face, mark edges, all single mark edges we draw\n      const edgesToDraw = new Array(12).fill(0);\n      for (let f = 0; f < 6; f++) {\n        if (facesToDraw[f]) {\n          for (let e = 0; e < 4; e++) {\n            edgesToDraw[faceEdges[f][e]]++;\n          }\n        }\n      }\n\n      // compute tick marks for axes\n      const t = model.generateTicks(model.dataBounds);\n\n      // update gridlines / edge lines\n      publicAPI.updatePolyData(facesToDraw, edgesToDraw, t.ticks);\n\n      // compute label world coords and text\n      publicAPI.updateTextData(facesToDraw, edgesToDraw, t.ticks, t.tickStrings);\n\n      // rebuild the texture only when force or changed bounds, face\n      // visibility changes do to change the atlas\n      if (boundsChanged || model.forceUpdate) {\n        publicAPI.updateTextureAtlas(t.tickStrings);\n      }\n    }\n    model.forceUpdate = false;\n  };\n\n  // create the texture map atlas that contains the rendering of\n  // all the text strings. Only needs to be called when the text strings\n  // have changed (labels and ticks)\n  publicAPI.updateTextureAtlas = tickStrings => {\n    // compute the width and height we need\n\n    // set the text properties\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n\n    // first the three labels\n    model._tmAtlas.clear();\n    let maxWidth = 0;\n    let totalHeight = 1; // start one pixel in so we have a border\n    for (let i = 0; i < 3; i++) {\n      if (!model._tmAtlas.has(model.axisLabels[i])) {\n        applyTextStyle(model.tmContext, model.axisTextStyle);\n        const metrics = model.tmContext.measureText(model.axisLabels[i]);\n        const entry = {\n          height: metrics.actualBoundingBoxAscent + 2,\n          startingHeight: totalHeight,\n          width: metrics.width + 2,\n          textStyle: model.axisTextStyle\n        };\n        model._tmAtlas.set(model.axisLabels[i], entry);\n        totalHeight += entry.height;\n        if (maxWidth < entry.width) {\n          maxWidth = entry.width;\n        }\n      }\n      // and the ticks\n      applyTextStyle(model.tmContext, model.tickTextStyle);\n      for (let t = 0; t < tickStrings[i].length; t++) {\n        if (!model._tmAtlas.has(tickStrings[i][t])) {\n          const metrics = model.tmContext.measureText(tickStrings[i][t]);\n          const entry = {\n            height: metrics.actualBoundingBoxAscent + 2,\n            startingHeight: totalHeight,\n            width: metrics.width + 2,\n            textStyle: model.tickTextStyle\n          };\n          model._tmAtlas.set(tickStrings[i][t], entry);\n          totalHeight += entry.height;\n          if (maxWidth < entry.width) {\n            maxWidth = entry.width;\n          }\n        }\n      }\n    }\n\n    // always use power of two to avoid interpolation\n    // in cases where PO2 is required\n    maxWidth = nearestPowerOfTwo(maxWidth);\n    totalHeight = nearestPowerOfTwo(totalHeight);\n\n    // set the tcoord values\n    model._tmAtlas.forEach(value => {\n      value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];\n    });\n\n    // make sure we have power of two dimensions\n    model.tmCanvas.width = maxWidth;\n    model.tmCanvas.height = totalHeight;\n    model.tmContext.textBaseline = 'bottom';\n    model.tmContext.textAlign = 'left';\n    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);\n\n    // draw the text onto the texture\n    model._tmAtlas.forEach((value, key) => {\n      applyTextStyle(model.tmContext, value.textStyle);\n      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);\n    });\n    model.tmTexture.setCanvas(model.tmCanvas);\n    model.tmTexture.modified();\n  };\n\n  // Make sure the data is correct\n  publicAPI.onModified(() => {\n    model.forceUpdate = true;\n    publicAPI.update();\n  });\n  publicAPI.setTickTextStyle = tickStyle => {\n    model.tickTextStyle = {\n      ...model.tickTextStyle,\n      ...tickStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.setAxisTextStyle = axisStyle => {\n    model.axisTextStyle = {\n      ...model.axisTextStyle,\n      ...axisStyle\n    };\n    publicAPI.modified();\n  };\n  publicAPI.get_tmAtlas = () => model._tmAtlas;\n\n  // try to get the bounds for the annotation. This is complicated\n  // as it relies on the pixel size of the window. Every time the camera\n  // changes the bounds change. This method simplifies by just expanding\n  // the grid bounds by a user specified factor.\n  publicAPI.getBounds = () => {\n    publicAPI.update();\n    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());\n    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);\n    return model.bounds;\n  };\n\n  // Make sure the grid share the actor property\n  const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);\n  publicAPI.setProperty = p => _setProp(p)[0];\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(publicAPI, model, initialValues) {\n  return {\n    boundsScaleFactor: 1.3,\n    camera: null,\n    dataBounds: [...vtkBoundingBox.INIT_BOUNDS],\n    faceVisibilityAngle: 8,\n    gridLines: true,\n    axisLabels: null,\n    axisTitlePixelOffset: 35.0,\n    tickLabelPixelOffset: 12.0,\n    generateTicks: defaultGenerateTicks,\n    ...initialValues,\n    axisTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 18,\n      fontFamily: 'serif',\n      ...initialValues?.axisTextStyle\n    },\n    tickTextStyle: {\n      fontColor: 'white',\n      fontStyle: 'normal',\n      fontSize: 14,\n      fontFamily: 'serif',\n      ...initialValues?.tickTextStyle\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Inheritance\n  vtkActor.extend(publicAPI, model, defaultValues(publicAPI, model, initialValues));\n\n  // internal variables\n  model.lastFacesToDraw = [false, false, false, false, false, false];\n  model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];\n  model.tickCounts = [];\n  model.textValues = [];\n  model.lastTickBounds = [];\n  model.tmCanvas = document.createElement('canvas');\n  model.tmContext = model.tmCanvas.getContext('2d');\n  model._tmAtlas = new Map();\n\n  // for texture atlas\n  model.tmTexture = vtkTexture.newInstance({\n    resizable: true\n  });\n  model.tmTexture.setInterpolate(false);\n  publicAPI.getProperty().setDiffuse(0.0);\n  publicAPI.getProperty().setAmbient(1.0);\n  model.gridMapper = vtkMapper.newInstance();\n  model.polyData = vtkPolyData.newInstance();\n  model.gridMapper.setInputData(model.polyData);\n  model.gridActor = vtkActor.newInstance();\n  model.gridActor.setMapper(model.gridMapper);\n  model.gridActor.setProperty(publicAPI.getProperty());\n  model.gridActor.setParentProp(publicAPI);\n  model.textPolyData = vtkPolyData.newInstance();\n  macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset', 'generateTicks']);\n  macro.setGetArray(publicAPI, model, ['dataBounds'], 6);\n  macro.setGetArray(publicAPI, model, ['axisLabels'], 3);\n  macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']);\n\n  // Object methods\n  vtkCubeAxesActor(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCubeAxesActor');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCubeAxesActor$1 = {\n  newInstance,\n  extend,\n  newCubeAxesActorHelper,\n  defaultGenerateTicks\n};\n\nexport { vtkCubeAxesActor$1 as default, extend, newInstance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}